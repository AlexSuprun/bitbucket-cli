/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket API
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@bitbucket.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface Account extends ModelObject {
    'links'?: AccountLinks;
    'created_on'?: string;
    'display_name'?: string;
    'uuid'?: string;
}
/**
 * Links related to an Account.
 */
export interface AccountLinks {
    [key: string]: any;

    'avatar'?: Link;
}
export interface AppUser extends Account {
    /**
     * The user\'s Atlassian account ID.
     */
    'account_id'?: string;
    /**
     * The status of the account. Currently the only possible value is \"active\", but more values may be added in the future.
     */
    'account_status'?: string;
    /**
     * The kind of App User.
     */
    'kind'?: string;
}
/**
 * An application property. It is a caller defined JSON object that Bitbucket will store and return.  The `_attributes` field at its top level can be used to control who is allowed to read and update the property.  The keys of the JSON object must match an allowed pattern. For details,  see [Application properties](/cloud/bitbucket/application-properties/). 
 */
export interface ApplicationProperty {
    [key: string]: any;

    '_attributes'?: Array<ApplicationPropertyAttributesEnum>;
}

export const ApplicationPropertyAttributesEnum = {
    Public: 'public',
    ReadOnly: 'read_only'
} as const;

export type ApplicationPropertyAttributesEnum = typeof ApplicationPropertyAttributesEnum[keyof typeof ApplicationPropertyAttributesEnum];

export interface Author extends ModelObject {
    /**
     * The raw author value from the repository. This may be the only value available if the author does not match a user in Bitbucket.
     */
    'raw'?: string;
    'user'?: Account;
}
export interface BaseCommit extends ModelObject {
    'hash'?: string;
    'date'?: string;
    'author'?: Author;
    'committer'?: Committer;
    'message'?: string;
    'summary'?: object;
    'parents'?: Array<BaseCommit>;
}
export interface BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema {
    'permission': BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchemaPermissionEnum;
}

export const BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchemaPermissionEnum = {
    Read: 'read',
    Write: 'write',
    CreateRepo: 'create-repo',
    Admin: 'admin'
} as const;

export type BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchemaPermissionEnum = typeof BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchemaPermissionEnum[keyof typeof BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchemaPermissionEnum];

export interface BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchema {
    'permission': BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchemaPermissionEnum;
}

export const BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchemaPermissionEnum = {
    Read: 'read',
    Write: 'write',
    Admin: 'admin'
} as const;

export type BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchemaPermissionEnum = typeof BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchemaPermissionEnum[keyof typeof BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchemaPermissionEnum];

export interface Branch {
    'type': string;
    'links'?: object;
    /**
     * The name of the ref.
     */
    'name'?: string;
    'target'?: Commit;
    /**
     * Available merge strategies for pull requests targeting this branch.
     */
    'merge_strategies'?: Array<BranchMergeStrategiesEnum>;
    /**
     * The default merge strategy for pull requests targeting this branch.
     */
    'default_merge_strategy'?: string;
}

export const BranchMergeStrategiesEnum = {
    MergeCommit: 'merge_commit',
    Squash: 'squash',
    FastForward: 'fast_forward',
    SquashFastForward: 'squash_fast_forward',
    RebaseFastForward: 'rebase_fast_forward',
    RebaseMerge: 'rebase_merge'
} as const;

export type BranchMergeStrategiesEnum = typeof BranchMergeStrategiesEnum[keyof typeof BranchMergeStrategiesEnum];

export interface BranchingModel extends ModelObject {
    /**
     * The active branch types.
     */
    'branch_types'?: Set<object>;
    'development'?: object;
    'production'?: object;
}
export interface BranchingModelSettings extends ModelObject {
    'links'?: object;
    'branch_types'?: Set<object>;
    'development'?: object;
    'production'?: object;
}
export interface Branchrestriction extends ModelObject {
    'links'?: object;
    /**
     * The branch restriction status\' id.
     */
    'id'?: number;
    /**
     * The type of restriction that is being applied.
     */
    'kind': BranchrestrictionKindEnum;
    /**
     * Indicates how the restriction is matched against a branch. The default is `glob`.
     */
    'branch_match_kind': BranchrestrictionBranchMatchKindEnum;
    /**
     * Apply the restriction to branches of this type. Active when `branch_match_kind` is `branching_model`. The branch type will be calculated using the branching model configured for the repository.
     */
    'branch_type'?: BranchrestrictionBranchTypeEnum;
    /**
     * Apply the restriction to branches that match this pattern. Active when `branch_match_kind` is `glob`. Will be empty when `branch_match_kind` is `branching_model`.
     */
    'pattern': string;
    /**
     * Value with kind-specific semantics:  * `require_approvals_to_merge` uses it to require a minimum number of approvals on a PR.  * `require_default_reviewer_approvals_to_merge` uses it to require a minimum number of approvals from default reviewers on a PR.  * `require_passing_builds_to_merge` uses it to require a minimum number of passing builds.  * `require_commits_behind` uses it to require the current branch is up to a maximum number of commits behind it destination.
     */
    'value'?: number;
    'users'?: Array<Account>;
    'groups'?: Array<Group>;
}

export const BranchrestrictionKindEnum = {
    Push: 'push',
    Delete: 'delete',
    Force: 'force',
    RestrictMerges: 'restrict_merges',
    RequireTasksToBeCompleted: 'require_tasks_to_be_completed',
    RequireApprovalsToMerge: 'require_approvals_to_merge',
    RequireReviewGroupApprovalsToMerge: 'require_review_group_approvals_to_merge',
    RequireDefaultReviewerApprovalsToMerge: 'require_default_reviewer_approvals_to_merge',
    RequireNoChangesRequested: 'require_no_changes_requested',
    RequirePassingBuildsToMerge: 'require_passing_builds_to_merge',
    RequireCommitsBehind: 'require_commits_behind',
    ResetPullrequestApprovalsOnChange: 'reset_pullrequest_approvals_on_change',
    SmartResetPullrequestApprovals: 'smart_reset_pullrequest_approvals',
    ResetPullrequestChangesRequestedOnChange: 'reset_pullrequest_changes_requested_on_change',
    RequireAllDependenciesMerged: 'require_all_dependencies_merged',
    EnforceMergeChecks: 'enforce_merge_checks',
    AllowAutoMergeWhenBuildsPass: 'allow_auto_merge_when_builds_pass',
    RequireAllCommentsResolved: 'require_all_comments_resolved'
} as const;

export type BranchrestrictionKindEnum = typeof BranchrestrictionKindEnum[keyof typeof BranchrestrictionKindEnum];
export const BranchrestrictionBranchMatchKindEnum = {
    BranchingModel: 'branching_model',
    Glob: 'glob'
} as const;

export type BranchrestrictionBranchMatchKindEnum = typeof BranchrestrictionBranchMatchKindEnum[keyof typeof BranchrestrictionBranchMatchKindEnum];
export const BranchrestrictionBranchTypeEnum = {
    Feature: 'feature',
    Bugfix: 'bugfix',
    Release: 'release',
    Hotfix: 'hotfix',
    Development: 'development',
    Production: 'production'
} as const;

export type BranchrestrictionBranchTypeEnum = typeof BranchrestrictionBranchTypeEnum[keyof typeof BranchrestrictionBranchTypeEnum];

export interface Comment extends ModelObject {
    'id'?: number;
    'created_on'?: string;
    'updated_on'?: string;
    'content'?: object;
    'user'?: Account;
    'deleted'?: boolean;
    'parent'?: Comment;
    'inline'?: object;
    'links'?: object;
}
/**
 * The resolution object for a Comment.
 */
export interface CommentResolution {
    [key: string]: any;

    'type': string;
    'user'?: Account;
    /**
     * The ISO8601 timestamp the resolution was created.
     */
    'created_on'?: string;
}
export interface Commit extends BaseCommit {
    'repository'?: Repository;
    'participants'?: Array<Participant>;
}
export interface CommitComment extends Comment {
    'commit'?: Commit;
}
/**
 * A file object, representing a file at a commit in a repository
 */
export interface CommitFile {
    [key: string]: any;

    'type': string;
    /**
     * The path in the repository
     */
    'path'?: string;
    'commit'?: Commit;
    'attributes'?: CommitFileAttributesEnum;
    /**
     * The escaped version of the path as it appears in a diff. If the path does not require escaping this will be the same as path.
     */
    'escaped_path'?: string;
}

export const CommitFileAttributesEnum = {
    Link: 'link',
    Executable: 'executable',
    Subrepository: 'subrepository',
    Binary: 'binary',
    Lfs: 'lfs'
} as const;

export type CommitFileAttributesEnum = typeof CommitFileAttributesEnum[keyof typeof CommitFileAttributesEnum];

export interface Commitstatus extends ModelObject {
    'links'?: object;
    /**
     * The commit status\' id.
     */
    'uuid'?: string;
    /**
     * An identifier for the status that\'s unique to         its type (current \"build\" is the only supported type) and the vendor,         e.g. BB-DEPLOY
     */
    'key'?: string;
    /**
     *  The name of the ref that pointed to this commit at the time the status object was created. Note that this the ref may since have moved off of the commit. This optional field can be useful for build systems whose build triggers and configuration are branch-dependent (e.g. a Pipeline build). It is legitimate for this field to not be set, or even apply (e.g. a static linting job).
     */
    'refname'?: string;
    /**
     * A URL linking back to the vendor or build system, for providing more information about whatever process produced this status. Accepts context variables `repository` and `commit` that Bitbucket will evaluate at runtime whenever at runtime. For example, one could use https://foo.com/builds/{repository.full_name} which Bitbucket will turn into https://foo.com/builds/foo/bar at render time.
     */
    'url'?: string;
    /**
     * Provides some indication of the status of this commit
     */
    'state'?: CommitstatusStateEnum;
    /**
     * An identifier for the build itself, e.g. BB-DEPLOY-1
     */
    'name'?: string;
    /**
     * A description of the build (e.g. \"Unit tests in Bamboo\")
     */
    'description'?: string;
    'created_on'?: string;
    'updated_on'?: string;
}

export const CommitstatusStateEnum = {
    Failed: 'FAILED',
    Inprogress: 'INPROGRESS',
    Stopped: 'STOPPED',
    Successful: 'SUCCESSFUL'
} as const;

export type CommitstatusStateEnum = typeof CommitstatusStateEnum[keyof typeof CommitstatusStateEnum];

export interface Committer extends ModelObject {
    /**
     * The raw committer value from the repository. This may be the only value available if the committer does not match a user in Bitbucket.
     */
    'raw'?: string;
    'user'?: Account;
}
export interface Component extends ModelObject {
    'links'?: object;
    'name'?: string;
    'id'?: number;
}
/**
 * Object containing a user that is a default reviewer and the type of reviewer
 */
export interface DefaultReviewerAndType {
    [key: string]: any;

    'type': string;
    'reviewer_type'?: string;
    'user'?: User;
}
export interface DeployKey extends ModelObject {
    /**
     * The deploy key value.
     */
    'key'?: string;
    'repository'?: Repository;
    /**
     * The comment parsed from the deploy key (if present)
     */
    'comment'?: string;
    /**
     * The user-defined label for the deploy key
     */
    'label'?: string;
    'added_on'?: string;
    'last_used'?: string;
    'links'?: object;
    'owner'?: Account;
}
export interface Deployment extends ModelObject {
    /**
     * The UUID identifying the deployment.
     */
    'uuid'?: string;
    'state'?: DeploymentState;
    'environment'?: DeploymentEnvironment;
    'release'?: DeploymentRelease;
}
export interface DeploymentEnvironment extends ModelObject {
    /**
     * The UUID identifying the environment.
     */
    'uuid'?: string;
    /**
     * The name of the environment.
     */
    'name'?: string;
}
export interface DeploymentRelease extends ModelObject {
    /**
     * The UUID identifying the release.
     */
    'uuid'?: string;
    /**
     * The name of the release.
     */
    'name'?: string;
    /**
     * Link to the pipeline that produced the release.
     */
    'url'?: string;
    'commit'?: Commit;
    /**
     * The timestamp when the release was created.
     */
    'created_on'?: string;
}
export interface DeploymentState extends ModelObject {
}
export interface DeploymentStateCompleted extends DeploymentState {
    /**
     * The name of deployment state (COMPLETED).
     */
    'name'?: DeploymentStateCompletedNameEnum;
    /**
     * Link to the deployment result.
     */
    'url'?: string;
    'deployer'?: Account;
    'status'?: DeploymentStateCompletedStatus;
    /**
     * The timestamp when the deployment was started.
     */
    'start_date'?: string;
    /**
     * The timestamp when the deployment completed.
     */
    'completion_date'?: string;
}

export const DeploymentStateCompletedNameEnum = {
    Completed: 'COMPLETED'
} as const;

export type DeploymentStateCompletedNameEnum = typeof DeploymentStateCompletedNameEnum[keyof typeof DeploymentStateCompletedNameEnum];

export interface DeploymentStateCompletedStatus extends ModelObject {
}
export interface DeploymentStateCompletedStatusFailed extends DeploymentStateCompletedStatus {
    /**
     * The name of the completed deployment status (FAILED).
     */
    'name'?: DeploymentStateCompletedStatusFailedNameEnum;
}

export const DeploymentStateCompletedStatusFailedNameEnum = {
    Failed: 'FAILED'
} as const;

export type DeploymentStateCompletedStatusFailedNameEnum = typeof DeploymentStateCompletedStatusFailedNameEnum[keyof typeof DeploymentStateCompletedStatusFailedNameEnum];

export interface DeploymentStateCompletedStatusStopped extends DeploymentStateCompletedStatus {
    /**
     * The name of the completed deployment status (STOPPED).
     */
    'name'?: DeploymentStateCompletedStatusStoppedNameEnum;
}

export const DeploymentStateCompletedStatusStoppedNameEnum = {
    Stopped: 'STOPPED'
} as const;

export type DeploymentStateCompletedStatusStoppedNameEnum = typeof DeploymentStateCompletedStatusStoppedNameEnum[keyof typeof DeploymentStateCompletedStatusStoppedNameEnum];

export interface DeploymentStateCompletedStatusSuccessful extends DeploymentStateCompletedStatus {
    /**
     * The name of the completed deployment status (SUCCESSFUL).
     */
    'name'?: DeploymentStateCompletedStatusSuccessfulNameEnum;
}

export const DeploymentStateCompletedStatusSuccessfulNameEnum = {
    Successful: 'SUCCESSFUL'
} as const;

export type DeploymentStateCompletedStatusSuccessfulNameEnum = typeof DeploymentStateCompletedStatusSuccessfulNameEnum[keyof typeof DeploymentStateCompletedStatusSuccessfulNameEnum];

export interface DeploymentStateInProgress extends DeploymentState {
    /**
     * The name of deployment state (IN_PROGRESS).
     */
    'name'?: DeploymentStateInProgressNameEnum;
    /**
     * Link to the deployment result.
     */
    'url'?: string;
    'deployer'?: Account;
    /**
     * The timestamp when the deployment was started.
     */
    'start_date'?: string;
}

export const DeploymentStateInProgressNameEnum = {
    InProgress: 'IN_PROGRESS'
} as const;

export type DeploymentStateInProgressNameEnum = typeof DeploymentStateInProgressNameEnum[keyof typeof DeploymentStateInProgressNameEnum];

export interface DeploymentStateUndeployed extends DeploymentState {
    /**
     * The name of deployment state (UNDEPLOYED).
     */
    'name'?: DeploymentStateUndeployedNameEnum;
    /**
     * Link to trigger the deployment.
     */
    'trigger_url'?: string;
}

export const DeploymentStateUndeployedNameEnum = {
    Undeployed: 'UNDEPLOYED'
} as const;

export type DeploymentStateUndeployedNameEnum = typeof DeploymentStateUndeployedNameEnum[keyof typeof DeploymentStateUndeployedNameEnum];

export interface DeploymentVariable extends ModelObject {
    /**
     * The UUID identifying the variable.
     */
    'uuid'?: string;
    /**
     * The unique name of the variable.
     */
    'key'?: string;
    /**
     * The value of the variable. If the variable is secured, this will be empty.
     */
    'value'?: string;
    /**
     * If true, this variable will be treated as secured. The value will never be exposed in the logs or the REST API.
     */
    'secured'?: boolean;
}
/**
 * A diffstat object that includes a summary of changes made to a file between two commits.
 */
export interface Diffstat {
    [key: string]: any;

    'type': string;
    'status'?: DiffstatStatusEnum;
    'lines_added'?: number;
    'lines_removed'?: number;
    'old'?: CommitFile;
    'new'?: CommitFile;
}

export const DiffstatStatusEnum = {
    Added: 'added',
    Removed: 'removed',
    Modified: 'modified',
    Renamed: 'renamed'
} as const;

export type DiffstatStatusEnum = typeof DiffstatStatusEnum[keyof typeof DiffstatStatusEnum];

export interface EffectiveRepoBranchingModel extends ModelObject {
    /**
     * The active branch types.
     */
    'branch_types'?: Set<object>;
    'development'?: object;
    'production'?: object;
}
/**
 * Options for issue export.
 */
export interface ExportOptions {
    [key: string]: any;

    'type': string;
    'project_key'?: string;
    'project_name'?: string;
    'send_email'?: boolean;
    'include_attachments'?: boolean;
}
export interface GPGAccountKey extends ModelObject {
    'owner'?: Account;
    /**
     * The GPG key value in X format.
     */
    'key'?: string;
    /**
     * The unique identifier for the GPG key
     */
    'key_id'?: string;
    /**
     * The GPG key fingerprint.
     */
    'fingerprint'?: string;
    /**
     * The fingerprint of the parent key. This value is null unless the current key is a subkey.
     */
    'parent_fingerprint'?: string;
    /**
     * The comment parsed from the GPG key (if present)
     */
    'comment'?: string;
    /**
     * The user-defined label for the GPG key
     */
    'name'?: string;
    'expires_on'?: string;
    'created_on'?: string;
    'added_on'?: string;
    'last_used'?: string;
    'subkeys'?: Set<GPGAccountKey>;
    'links'?: object;
}
export interface Group extends ModelObject {
    'links'?: object;
    'owner'?: Account;
    'workspace'?: Workspace;
    'name'?: string;
    /**
     * The \"sluggified\" version of the group\'s name. This contains only ASCII characters and can therefore be slightly different than the name
     */
    'slug'?: string;
    /**
     * The concatenation of the workspace\'s slug and the group\'s slug, separated with a colon (e.g. `acme:developers`) 
     */
    'full_slug'?: string;
}
/**
 * An event, associated with a resource or subject type.
 */
export interface HookEvent {
    /**
     * The event identifier.
     */
    'event'?: HookEventEventEnum;
    /**
     * The category this event belongs to.
     */
    'category'?: string;
    /**
     * Summary of the webhook event type.
     */
    'label'?: string;
    /**
     * More detailed description of the webhook event type.
     */
    'description'?: string;
}

export const HookEventEventEnum = {
    IssueCommentCreated: 'issue:comment_created',
    IssueCreated: 'issue:created',
    IssueUpdated: 'issue:updated',
    ProjectUpdated: 'project:updated',
    PullrequestApproved: 'pullrequest:approved',
    PullrequestChangesRequestCreated: 'pullrequest:changes_request_created',
    PullrequestChangesRequestRemoved: 'pullrequest:changes_request_removed',
    PullrequestCommentCreated: 'pullrequest:comment_created',
    PullrequestCommentDeleted: 'pullrequest:comment_deleted',
    PullrequestCommentReopened: 'pullrequest:comment_reopened',
    PullrequestCommentResolved: 'pullrequest:comment_resolved',
    PullrequestCommentUpdated: 'pullrequest:comment_updated',
    PullrequestCreated: 'pullrequest:created',
    PullrequestFulfilled: 'pullrequest:fulfilled',
    PullrequestPush: 'pullrequest:push',
    PullrequestRejected: 'pullrequest:rejected',
    PullrequestUnapproved: 'pullrequest:unapproved',
    PullrequestUpdated: 'pullrequest:updated',
    RepoCommitCommentCreated: 'repo:commit_comment_created',
    RepoCommitStatusCreated: 'repo:commit_status_created',
    RepoCommitStatusUpdated: 'repo:commit_status_updated',
    RepoCreated: 'repo:created',
    RepoDeleted: 'repo:deleted',
    RepoFork: 'repo:fork',
    RepoImported: 'repo:imported',
    RepoPush: 'repo:push',
    RepoTransfer: 'repo:transfer',
    RepoUpdated: 'repo:updated'
} as const;

export type HookEventEventEnum = typeof HookEventEventEnum[keyof typeof HookEventEventEnum];

export interface Issue extends ModelObject {
    'links'?: object;
    'id'?: number;
    'repository'?: Repository;
    'title'?: string;
    'reporter'?: Account;
    'assignee'?: Account;
    'created_on'?: string;
    'updated_on'?: string;
    'edited_on'?: string;
    'state'?: IssueStateEnum;
    'kind'?: IssueKindEnum;
    'priority'?: IssuePriorityEnum;
    'milestone'?: Milestone;
    'version'?: Version;
    'component'?: Component;
    'votes'?: number;
    'content'?: object;
}

export const IssueStateEnum = {
    Submitted: 'submitted',
    New: 'new',
    Open: 'open',
    Resolved: 'resolved',
    OnHold: 'on hold',
    Invalid: 'invalid',
    Duplicate: 'duplicate',
    Wontfix: 'wontfix',
    Closed: 'closed'
} as const;

export type IssueStateEnum = typeof IssueStateEnum[keyof typeof IssueStateEnum];
export const IssueKindEnum = {
    Bug: 'bug',
    Enhancement: 'enhancement',
    Proposal: 'proposal',
    Task: 'task'
} as const;

export type IssueKindEnum = typeof IssueKindEnum[keyof typeof IssueKindEnum];
export const IssuePriorityEnum = {
    Trivial: 'trivial',
    Minor: 'minor',
    Major: 'major',
    Critical: 'critical',
    Blocker: 'blocker'
} as const;

export type IssuePriorityEnum = typeof IssuePriorityEnum[keyof typeof IssuePriorityEnum];

export interface IssueAttachment extends ModelObject {
    'links'?: object;
    'name'?: string;
}
/**
 * An issue change.
 */
export interface IssueChange {
    [key: string]: any;

    'type': string;
    'links'?: object;
    'name'?: string;
    'created_on'?: string;
    'user'?: Account;
    'issue'?: Issue;
    'changes'?: object;
    'message'?: object;
}
export interface IssueComment extends Comment {
    'issue'?: Issue;
}
/**
 * The status of an import or export job
 */
export interface IssueJobStatus {
    'type'?: string;
    /**
     * The status of the import/export job
     */
    'status'?: IssueJobStatusStatusEnum;
    /**
     * The phase of the import/export job
     */
    'phase'?: string;
    /**
     * The total number of issues being imported/exported
     */
    'total'?: number;
    /**
     * The total number of issues already imported/exported
     */
    'count'?: number;
    /**
     * The percentage of issues already imported/exported
     */
    'pct'?: number;
}

export const IssueJobStatusStatusEnum = {
    Accepted: 'ACCEPTED',
    Started: 'STARTED',
    Running: 'RUNNING',
    Failure: 'FAILURE'
} as const;

export type IssueJobStatusStatusEnum = typeof IssueJobStatusStatusEnum[keyof typeof IssueJobStatusStatusEnum];

/**
 * A link to a resource related to this object.
 */
export interface Link {
    'href'?: string;
    'name'?: string;
}
export interface Milestone extends ModelObject {
    'links'?: object;
    'name'?: string;
    'id'?: number;
}
/**
 * Base type for most resource objects. It defines the common `type` element that identifies an object\'s type. It also identifies the element as Swagger\'s `discriminator`.
 */
export interface ModelError {
    [key: string]: any;

    'type': string;
    'error'?: object;
}
/**
 * Base type for most resource objects. It defines the common `type` element that identifies an object\'s type. It also identifies the element as Swagger\'s `discriminator`.
 */
export interface ModelObject {
    [key: string]: any;

    'type': string;
}
/**
 * A paginated list of accounts.
 */
export interface PaginatedAccounts {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Account>;
}
/**
 * A paginated list of annotations.
 */
export interface PaginatedAnnotations {
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * The values of the current page.
     */
    'values'?: Array<ReportAnnotation>;
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
}
/**
 * A paginated list of branches.
 */
export interface PaginatedBranches {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Branch>;
}
/**
 * A paginated list of branch restriction rules.
 */
export interface PaginatedBranchrestrictions {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Branchrestriction>;
}
/**
 * A paginated list of commits.
 */
export interface PaginatedChangeset {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<BaseCommit>;
}
/**
 * A paginated list of commit comments.
 */
export interface PaginatedCommitComments {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<CommitComment>;
}
/**
 * A paginated list of commit status objects.
 */
export interface PaginatedCommitstatuses {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Commitstatus>;
}
/**
 * A paginated list of issue tracker components.
 */
export interface PaginatedComponents {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Component>;
}
/**
 * A paginated list of default reviewers with reviewer type.
 */
export interface PaginatedDefaultReviewerAndType {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<DefaultReviewerAndType>;
}
/**
 * A paginated list of deploy keys.
 */
export interface PaginatedDeployKeys {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<DeployKey>;
}
/**
 * A paged list of deployment variables.
 */
export interface PaginatedDeploymentVariable {
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * The values of the current page.
     */
    'values'?: Array<DeploymentVariable>;
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
}
/**
 * A paged list of deployments
 */
export interface PaginatedDeployments {
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * The values of the current page.
     */
    'values'?: Array<Deployment>;
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
}
/**
 * A paginated list of diffstats.
 */
export interface PaginatedDiffstats {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 500 with 5000 being the maximum allowed value.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Diffstat>;
}
/**
 * A paged list of environments
 */
export interface PaginatedEnvironments {
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * The values of the current page.
     */
    'values'?: Array<DeploymentEnvironment>;
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
}
/**
 * A paginated list of commit_file objects.
 */
export interface PaginatedFiles {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<CommitFile>;
}
/**
 * A paginated list of GPG keys.
 */
export interface PaginatedGpgUserKeys {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<GPGAccountKey>;
}
/**
 * A paginated list of webhook types available to subscribe on.
 */
export interface PaginatedHookEvents {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<HookEvent>;
}
/**
 * A paginated list of issue attachments.
 */
export interface PaginatedIssueAttachments {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Array<IssueAttachment>;
}
/**
 * A paginated list of issue comments.
 */
export interface PaginatedIssueComments {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<IssueComment>;
}
/**
 * A paginated list of issues.
 */
export interface PaginatedIssues {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Issue>;
}
/**
 * A paginated list of issue changes.
 */
export interface PaginatedLogEntries {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Array<IssueChange>;
}
/**
 * A paginated list of issue tracker milestones.
 */
export interface PaginatedMilestones {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Milestone>;
}
/**
 * A paged list of pipeline caches
 */
export interface PaginatedPipelineCaches {
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * The values of the current page.
     */
    'values'?: Array<PipelineCache>;
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
}
/**
 * A paged list of known hosts.
 */
export interface PaginatedPipelineKnownHosts {
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * The values of the current page.
     */
    'values'?: Array<PipelineKnownHost>;
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
}
/**
 * A paged list of the executions of a schedule.
 */
export interface PaginatedPipelineScheduleExecutions {
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * The values of the current page.
     */
    'values'?: Array<PipelineScheduleExecution>;
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
}
/**
 * A paged list of schedules
 */
export interface PaginatedPipelineSchedules {
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * The values of the current page.
     */
    'values'?: Array<PipelineSchedule>;
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
}
/**
 * A paged list of pipeline steps.
 */
export interface PaginatedPipelineSteps {
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * The values of the current page.
     */
    'values'?: Array<PipelineStep>;
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
}
/**
 * A paged list of variables.
 */
export interface PaginatedPipelineVariables {
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * The values of the current page.
     */
    'values'?: Array<PipelineVariable>;
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
}
/**
 * A paged list of pipelines
 */
export interface PaginatedPipelines {
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * The values of the current page.
     */
    'values'?: Array<Pipeline>;
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
}
/**
 * A paginated list of project deploy keys.
 */
export interface PaginatedProjectDeployKeys {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<ProjectDeployKey>;
}
/**
 * A paginated list of project group permissions.
 */
export interface PaginatedProjectGroupPermissions {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<ProjectGroupPermission>;
}
/**
 * A paginated list of project user permissions.
 */
export interface PaginatedProjectUserPermissions {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<ProjectUserPermission>;
}
/**
 * A paginated list of projects
 */
export interface PaginatedProjects {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Project>;
}
/**
 * A paginated list of pullrequest comments.
 */
export interface PaginatedPullrequestComments {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<PullrequestComment>;
}
/**
 * A paginated list of pullrequests.
 */
export interface PaginatedPullrequests {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Pullrequest>;
}
/**
 * A paginated list of refs.
 */
export interface PaginatedRefs {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Ref>;
}
/**
 * A paginated list of reports.
 */
export interface PaginatedReports {
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * The values of the current page.
     */
    'values'?: Array<Report>;
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
}
/**
 * A paginated list of repositories.
 */
export interface PaginatedRepositories {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Repository>;
}
/**
 * A paginated list of repository group permissions.
 */
export interface PaginatedRepositoryGroupPermissions {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<RepositoryGroupPermission>;
}
/**
 * A paginated list of repository permissions.
 */
export interface PaginatedRepositoryPermissions {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<RepositoryPermission>;
}
/**
 * A paginated list of repository user permissions.
 */
export interface PaginatedRepositoryUserPermissions {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<RepositoryUserPermission>;
}
/**
 * A paginated list of snippet comments.
 */
export interface PaginatedSnippetComments {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<SnippetComment>;
}
/**
 * A paginated list of snippet commits.
 */
export interface PaginatedSnippetCommit {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Array<SnippetCommit>;
}
/**
 * A paginated list of snippets.
 */
export interface PaginatedSnippets {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Snippet>;
}
/**
 * A paginated list of SSH keys.
 */
export interface PaginatedSshUserKeys {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<SshAccountKey>;
}
/**
 * A paginated list of tags.
 */
export interface PaginatedTags {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Tag>;
}
/**
 * A paginated list of tasks.
 */
export interface PaginatedTasks {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<PullrequestCommentTask>;
}
/**
 * A paginated list of commit_file and/or commit_directory objects.
 */
export interface PaginatedTreeentries {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Treeentry>;
}
/**
 * A paginated list of issue tracker versions.
 */
export interface PaginatedVersions {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Version>;
}
/**
 * A paginated list of webhook subscriptions
 */
export interface PaginatedWebhookSubscriptions {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<WebhookSubscription>;
}
/**
 * A paginated list of workspace memberships.
 */
export interface PaginatedWorkspaceMemberships {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<WorkspaceMembership>;
}
/**
 * A paginated list of workspaces.
 */
export interface PaginatedWorkspaces {
    /**
     * Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
     */
    'size'?: number;
    /**
     * Page number of the current results. This is an optional element that is not provided in all responses.
     */
    'page'?: number;
    /**
     * Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
     */
    'pagelen'?: number;
    /**
     * Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'next'?: string;
    /**
     * Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
     */
    'previous'?: string;
    'values'?: Set<Workspace>;
}
export interface Participant extends ModelObject {
    'user'?: Account;
    'role'?: ParticipantRoleEnum;
    'approved'?: boolean;
    'state'?: ParticipantStateEnum;
    /**
     * The ISO8601 timestamp of the participant\'s action. For approvers, this is the time of their approval. For commenters and pull request reviewers who are not approvers, this is the time they last commented, or null if they have not commented.
     */
    'participated_on'?: string;
}

export const ParticipantRoleEnum = {
    Participant: 'PARTICIPANT',
    Reviewer: 'REVIEWER'
} as const;

export type ParticipantRoleEnum = typeof ParticipantRoleEnum[keyof typeof ParticipantRoleEnum];
export const ParticipantStateEnum = {
    Approved: 'approved',
    ChangesRequested: 'changes_requested'
} as const;

export type ParticipantStateEnum = typeof ParticipantStateEnum[keyof typeof ParticipantStateEnum];

export interface Pipeline extends ModelObject {
    /**
     * The UUID identifying the pipeline.
     */
    'uuid'?: string;
    /**
     * The build number of the pipeline.
     */
    'build_number'?: number;
    'creator'?: Account;
    'repository'?: Repository;
    'target'?: PipelineTarget;
    'trigger'?: PipelineTrigger;
    'state'?: PipelineState;
    /**
     * The variables for the pipeline.
     */
    'variables'?: Array<PipelineVariable>;
    /**
     * The timestamp when the pipeline was created.
     */
    'created_on'?: string;
    /**
     * The timestamp when the Pipeline was completed. This is not set if the pipeline is still in progress.
     */
    'completed_on'?: string;
    /**
     * The number of build seconds used by this pipeline.
     */
    'build_seconds_used'?: number;
    /**
     * An ordered list of sources of the pipeline configuration
     */
    'configuration_sources'?: Array<PipelineConfigurationSource>;
    'links'?: PipelinesPipelineLinks;
}
export interface PipelineBuildNumber extends ModelObject {
    /**
     * The next number that will be used as build number.
     */
    'next'?: number;
}
export interface PipelineCache extends ModelObject {
    /**
     * The UUID identifying the pipeline cache.
     */
    'uuid'?: string;
    /**
     * The UUID of the pipeline that created the cache.
     */
    'pipeline_uuid'?: string;
    /**
     * The uuid of the step that created the cache.
     */
    'step_uuid'?: string;
    /**
     * The name of the cache.
     */
    'name'?: string;
    /**
     * The key hash of the cache version.
     */
    'key_hash'?: string;
    /**
     * The path where the cache contents were retrieved from.
     */
    'path'?: string;
    /**
     * The size of the file containing the archive of the cache.
     */
    'file_size_bytes'?: number;
    /**
     * The timestamp when the cache was created.
     */
    'created_on'?: string;
}
/**
 * A representation of the location of pipeline cache content.
 */
export interface PipelineCacheContentUri {
    /**
     * The uri for pipeline cache content.
     */
    'uri'?: string;
}
/**
 * An executable pipeline command.
 */
export interface PipelineCommand {
    /**
     * The name of the command.
     */
    'name'?: string;
    /**
     * The executable command.
     */
    'command'?: string;
}
export interface PipelineCommitTarget extends PipelineTarget {
    'commit'?: Commit;
    'selector'?: PipelineSelector;
}
/**
 * Information about the source of the pipeline configuration
 */
export interface PipelineConfigurationSource {
    /**
     * Identifier of the configuration source
     */
    'source': string;
    /**
     * Link to the configuration source view or its immediate content
     */
    'uri': string;
}
export interface PipelineError extends ModelObject {
    /**
     * The error key.
     */
    'key'?: string;
    /**
     * The error message.
     */
    'message'?: string;
}
/**
 * The definition of a Docker image that can be used for a Bitbucket Pipelines step execution context.
 */
export interface PipelineImage {
    /**
     * The name of the image. If the image is hosted on DockerHub the short name can be used, otherwise the fully qualified name is required here.
     */
    'name'?: string;
    /**
     * The username needed to authenticate with the Docker registry. Only required when using a private Docker image.
     */
    'username'?: string;
    /**
     * The password needed to authenticate with the Docker registry. Only required when using a private Docker image.
     */
    'password'?: string;
    /**
     * The email needed to authenticate with the Docker registry. Only required when using a private Docker image.
     */
    'email'?: string;
}
export interface PipelineKnownHost extends ModelObject {
    /**
     * The UUID identifying the known host.
     */
    'uuid'?: string;
    /**
     * The hostname of the known host.
     */
    'hostname'?: string;
    'public_key'?: PipelineSshPublicKey;
}
export interface PipelineRefTarget extends PipelineTarget {
    /**
     * The type of reference (branch/tag).
     */
    'ref_type'?: PipelineRefTargetRefTypeEnum;
    /**
     * The name of the reference.
     */
    'ref_name'?: string;
    'commit'?: Commit;
    'selector'?: PipelineSelector;
}

export const PipelineRefTargetRefTypeEnum = {
    Branch: 'branch',
    Tag: 'tag',
    NamedBranch: 'named_branch',
    Bookmark: 'bookmark'
} as const;

export type PipelineRefTargetRefTypeEnum = typeof PipelineRefTargetRefTypeEnum[keyof typeof PipelineRefTargetRefTypeEnum];

export interface PipelineSchedule extends ModelObject {
    /**
     * The UUID identifying the schedule.
     */
    'uuid'?: string;
    /**
     * Whether the schedule is enabled.
     */
    'enabled'?: boolean;
    'target'?: PipelineRefTarget;
    /**
     * The cron expression with second precision (7 fields) that the schedule applies. For example, for expression: 0 0 12 * * ? *, will execute at 12pm UTC every day.
     */
    'cron_pattern'?: string;
    /**
     * The timestamp when the schedule was created.
     */
    'created_on'?: string;
    /**
     * The timestamp when the schedule was updated.
     */
    'updated_on'?: string;
}
export interface PipelineScheduleExecution extends ModelObject {
}
export interface PipelineScheduleExecutionErrored extends PipelineScheduleExecution {
    'error'?: PipelineError;
}
export interface PipelineScheduleExecutionExecuted extends PipelineScheduleExecution {
    'pipeline'?: Pipeline;
}
export interface PipelineSchedulePostRequestBody extends ModelObject {
    'target': RequestBodyForPipelineSchedulePOSTRequestTarget;
    /**
     * Whether the schedule is enabled.
     */
    'enabled'?: boolean;
    /**
     * The cron expression with second precision (7 fields) that the schedule applies. For example, for expression: 0 0 12 * * ? *, will execute at 12pm UTC every day.
     */
    'cron_pattern': string;
}
export interface PipelineSchedulePutRequestBody extends ModelObject {
    /**
     * Whether the schedule is enabled.
     */
    'enabled'?: boolean;
}
export interface PipelineSelector extends ModelObject {
    /**
     * The type of selector.
     */
    'type': PipelineSelectorTypeEnum;
    /**
     * The name of the matching pipeline definition.
     */
    'pattern'?: string;
}

export const PipelineSelectorTypeEnum = {
    Branches: 'branches',
    Tags: 'tags',
    Bookmarks: 'bookmarks',
    Default: 'default',
    Custom: 'custom'
} as const;

export type PipelineSelectorTypeEnum = typeof PipelineSelectorTypeEnum[keyof typeof PipelineSelectorTypeEnum];

export interface PipelineSshKeyPair extends ModelObject {
    /**
     * The SSH private key. This value will be empty when retrieving the SSH key pair.
     */
    'private_key'?: string;
    /**
     * The SSH public key.
     */
    'public_key'?: string;
}
export interface PipelineSshPublicKey extends ModelObject {
    /**
     * The type of the public key.
     */
    'key_type'?: string;
    /**
     * The base64 encoded public key.
     */
    'key'?: string;
    /**
     * The MD5 fingerprint of the public key.
     */
    'md5_fingerprint'?: string;
    /**
     * The SHA-256 fingerprint of the public key.
     */
    'sha256_fingerprint'?: string;
}
export interface PipelineState extends ModelObject {
}
export interface PipelineStateCompleted extends PipelineState {
    /**
     * The name of pipeline state (COMPLETED).
     */
    'name'?: PipelineStateCompletedNameEnum;
    'result'?: PipelineStateCompletedResult;
}

export const PipelineStateCompletedNameEnum = {
    Completed: 'COMPLETED'
} as const;

export type PipelineStateCompletedNameEnum = typeof PipelineStateCompletedNameEnum[keyof typeof PipelineStateCompletedNameEnum];

export interface PipelineStateCompletedError extends PipelineStateCompletedResult {
    /**
     * The name of the result (ERROR)
     */
    'name'?: PipelineStateCompletedErrorNameEnum;
    'error'?: PipelineError;
}

export const PipelineStateCompletedErrorNameEnum = {
    Error: 'ERROR'
} as const;

export type PipelineStateCompletedErrorNameEnum = typeof PipelineStateCompletedErrorNameEnum[keyof typeof PipelineStateCompletedErrorNameEnum];

export interface PipelineStateCompletedExpired extends PipelineStateCompletedResult {
    /**
     * The name of the stopped result (EXPIRED).
     */
    'name'?: PipelineStateCompletedExpiredNameEnum;
}

export const PipelineStateCompletedExpiredNameEnum = {
    Expired: 'EXPIRED'
} as const;

export type PipelineStateCompletedExpiredNameEnum = typeof PipelineStateCompletedExpiredNameEnum[keyof typeof PipelineStateCompletedExpiredNameEnum];

export interface PipelineStateCompletedFailed extends PipelineStateCompletedResult {
    /**
     * The name of the failed result (FAILED).
     */
    'name'?: PipelineStateCompletedFailedNameEnum;
}

export const PipelineStateCompletedFailedNameEnum = {
    Failed: 'FAILED'
} as const;

export type PipelineStateCompletedFailedNameEnum = typeof PipelineStateCompletedFailedNameEnum[keyof typeof PipelineStateCompletedFailedNameEnum];

export interface PipelineStateCompletedResult extends ModelObject {
}
export interface PipelineStateCompletedStopped extends PipelineStateCompletedResult {
    /**
     * The name of the stopped result (STOPPED).
     */
    'name'?: PipelineStateCompletedStoppedNameEnum;
}

export const PipelineStateCompletedStoppedNameEnum = {
    Stopped: 'STOPPED'
} as const;

export type PipelineStateCompletedStoppedNameEnum = typeof PipelineStateCompletedStoppedNameEnum[keyof typeof PipelineStateCompletedStoppedNameEnum];

export interface PipelineStateCompletedSuccessful extends PipelineStateCompletedResult {
    /**
     * The name of the successful result (SUCCESSFUL).
     */
    'name'?: PipelineStateCompletedSuccessfulNameEnum;
}

export const PipelineStateCompletedSuccessfulNameEnum = {
    Successful: 'SUCCESSFUL'
} as const;

export type PipelineStateCompletedSuccessfulNameEnum = typeof PipelineStateCompletedSuccessfulNameEnum[keyof typeof PipelineStateCompletedSuccessfulNameEnum];

export interface PipelineStateInProgress extends PipelineState {
    /**
     * The name of pipeline state (IN_PROGRESS).
     */
    'name'?: PipelineStateInProgressNameEnum;
    'stage'?: PipelineStateInProgressStage;
}

export const PipelineStateInProgressNameEnum = {
    InProgress: 'IN_PROGRESS'
} as const;

export type PipelineStateInProgressNameEnum = typeof PipelineStateInProgressNameEnum[keyof typeof PipelineStateInProgressNameEnum];

export interface PipelineStateInProgressPaused extends PipelineStateInProgressStage {
    /**
     * The name of the stage (PAUSED)
     */
    'name'?: PipelineStateInProgressPausedNameEnum;
}

export const PipelineStateInProgressPausedNameEnum = {
    Paused: 'PAUSED'
} as const;

export type PipelineStateInProgressPausedNameEnum = typeof PipelineStateInProgressPausedNameEnum[keyof typeof PipelineStateInProgressPausedNameEnum];

export interface PipelineStateInProgressRunning extends PipelineStateInProgressStage {
    /**
     * The name of the stage (RUNNING)
     */
    'name'?: PipelineStateInProgressRunningNameEnum;
}

export const PipelineStateInProgressRunningNameEnum = {
    Running: 'RUNNING'
} as const;

export type PipelineStateInProgressRunningNameEnum = typeof PipelineStateInProgressRunningNameEnum[keyof typeof PipelineStateInProgressRunningNameEnum];

export interface PipelineStateInProgressStage extends ModelObject {
}
export interface PipelineStatePending extends PipelineState {
    /**
     * The name of pipeline state (PENDING).
     */
    'name'?: PipelineStatePendingNameEnum;
}

export const PipelineStatePendingNameEnum = {
    Pending: 'PENDING'
} as const;

export type PipelineStatePendingNameEnum = typeof PipelineStatePendingNameEnum[keyof typeof PipelineStatePendingNameEnum];

export interface PipelineStep extends ModelObject {
    /**
     * The UUID identifying the step.
     */
    'uuid'?: string;
    /**
     * The timestamp when the step execution was started. This is not set when the step hasn\'t executed yet.
     */
    'started_on'?: string;
    /**
     * The timestamp when the step execution was completed. This is not set if the step is still in progress.
     */
    'completed_on'?: string;
    'state'?: PipelineStepState;
    'image'?: PipelineImage;
    /**
     * The list of commands that are executed as part of the setup phase of the build. These commands are executed outside the build container.
     */
    'setup_commands'?: Array<PipelineCommand>;
    /**
     * The list of build commands. These commands are executed in the build container.
     */
    'script_commands'?: Array<PipelineCommand>;
}
export interface PipelineStepError extends ModelObject {
    /**
     * The error key.
     */
    'key'?: string;
    /**
     * The error message.
     */
    'message'?: string;
}
export interface PipelineStepState extends ModelObject {
}
export interface PipelineStepStateCompleted extends PipelineStepState {
    /**
     * The name of pipeline step state (COMPLETED).
     */
    'name'?: PipelineStepStateCompletedNameEnum;
    'result'?: PipelineStepStateCompletedResult;
}

export const PipelineStepStateCompletedNameEnum = {
    Completed: 'COMPLETED'
} as const;

export type PipelineStepStateCompletedNameEnum = typeof PipelineStepStateCompletedNameEnum[keyof typeof PipelineStepStateCompletedNameEnum];

export interface PipelineStepStateCompletedError extends PipelineStepStateCompletedResult {
    /**
     * The name of the result (ERROR)
     */
    'name'?: PipelineStepStateCompletedErrorNameEnum;
    'error'?: PipelineStepError;
}

export const PipelineStepStateCompletedErrorNameEnum = {
    Error: 'ERROR'
} as const;

export type PipelineStepStateCompletedErrorNameEnum = typeof PipelineStepStateCompletedErrorNameEnum[keyof typeof PipelineStepStateCompletedErrorNameEnum];

export interface PipelineStepStateCompletedExpired extends PipelineStepStateCompletedResult {
    /**
     * The name of the result (EXPIRED)
     */
    'name'?: PipelineStepStateCompletedExpiredNameEnum;
}

export const PipelineStepStateCompletedExpiredNameEnum = {
    Expired: 'EXPIRED'
} as const;

export type PipelineStepStateCompletedExpiredNameEnum = typeof PipelineStepStateCompletedExpiredNameEnum[keyof typeof PipelineStepStateCompletedExpiredNameEnum];

export interface PipelineStepStateCompletedFailed extends PipelineStepStateCompletedResult {
    /**
     * The name of the result (FAILED)
     */
    'name'?: PipelineStepStateCompletedFailedNameEnum;
}

export const PipelineStepStateCompletedFailedNameEnum = {
    Failed: 'FAILED'
} as const;

export type PipelineStepStateCompletedFailedNameEnum = typeof PipelineStepStateCompletedFailedNameEnum[keyof typeof PipelineStepStateCompletedFailedNameEnum];

export interface PipelineStepStateCompletedNotRun extends PipelineStepStateCompletedResult {
    /**
     * The name of the result (NOT_RUN)
     */
    'name'?: PipelineStepStateCompletedNotRunNameEnum;
}

export const PipelineStepStateCompletedNotRunNameEnum = {
    NotRun: 'NOT_RUN'
} as const;

export type PipelineStepStateCompletedNotRunNameEnum = typeof PipelineStepStateCompletedNotRunNameEnum[keyof typeof PipelineStepStateCompletedNotRunNameEnum];

export interface PipelineStepStateCompletedResult extends ModelObject {
}
export interface PipelineStepStateCompletedStopped extends PipelineStepStateCompletedResult {
    /**
     * The name of the result (STOPPED)
     */
    'name'?: PipelineStepStateCompletedStoppedNameEnum;
}

export const PipelineStepStateCompletedStoppedNameEnum = {
    Stopped: 'STOPPED'
} as const;

export type PipelineStepStateCompletedStoppedNameEnum = typeof PipelineStepStateCompletedStoppedNameEnum[keyof typeof PipelineStepStateCompletedStoppedNameEnum];

export interface PipelineStepStateCompletedSuccessful extends PipelineStepStateCompletedResult {
    /**
     * The name of the result (SUCCESSFUL)
     */
    'name'?: PipelineStepStateCompletedSuccessfulNameEnum;
}

export const PipelineStepStateCompletedSuccessfulNameEnum = {
    Successful: 'SUCCESSFUL'
} as const;

export type PipelineStepStateCompletedSuccessfulNameEnum = typeof PipelineStepStateCompletedSuccessfulNameEnum[keyof typeof PipelineStepStateCompletedSuccessfulNameEnum];

export interface PipelineStepStateInProgress extends PipelineStepState {
    /**
     * The name of pipeline step state (IN_PROGRESS).
     */
    'name'?: PipelineStepStateInProgressNameEnum;
}

export const PipelineStepStateInProgressNameEnum = {
    InProgress: 'IN_PROGRESS'
} as const;

export type PipelineStepStateInProgressNameEnum = typeof PipelineStepStateInProgressNameEnum[keyof typeof PipelineStepStateInProgressNameEnum];

export interface PipelineStepStatePending extends PipelineStepState {
    /**
     * The name of pipeline step state (PENDING).
     */
    'name'?: PipelineStepStatePendingNameEnum;
}

export const PipelineStepStatePendingNameEnum = {
    Pending: 'PENDING'
} as const;

export type PipelineStepStatePendingNameEnum = typeof PipelineStepStatePendingNameEnum[keyof typeof PipelineStepStatePendingNameEnum];

export interface PipelineStepStateReady extends PipelineStepState {
    /**
     * The name of pipeline step state (READY).
     */
    'name'?: PipelineStepStateReadyNameEnum;
}

export const PipelineStepStateReadyNameEnum = {
    Ready: 'READY'
} as const;

export type PipelineStepStateReadyNameEnum = typeof PipelineStepStateReadyNameEnum[keyof typeof PipelineStepStateReadyNameEnum];

export interface PipelineTarget extends ModelObject {
}
export interface PipelineTrigger extends ModelObject {
}
export interface PipelineTriggerManual extends PipelineTrigger {
}
export interface PipelineTriggerPush extends PipelineTrigger {
}
export interface PipelineVariable extends ModelObject {
    /**
     * The UUID identifying the variable.
     */
    'uuid'?: string;
    /**
     * The unique name of the variable.
     */
    'key'?: string;
    /**
     * The value of the variable. If the variable is secured, this will be empty.
     */
    'value'?: string;
    /**
     * If true, this variable will be treated as secured. The value will never be exposed in the logs or the REST API.
     */
    'secured'?: boolean;
}
export interface PipelinesConfig extends ModelObject {
    /**
     * Whether Pipelines is enabled for the repository.
     */
    'enabled'?: boolean;
    'repository'?: Repository;
}
export interface PipelinesLinksSectionHref extends ModelObject {
    /**
     * A link
     */
    'href'?: string;
}
export interface PipelinesPipelineLinks extends ModelObject {
    'self'?: PipelinesLinksSectionHref;
    'steps'?: PipelinesLinksSectionHref;
}
export interface Project extends ModelObject {
    'links'?: object;
    /**
     * The project\'s immutable id.
     */
    'uuid'?: string;
    /**
     * The project\'s key.
     */
    'key'?: string;
    'owner'?: Team;
    /**
     * The name of the project.
     */
    'name'?: string;
    'description'?: string;
    /**
     *  Indicates whether the project is publicly accessible, or whether it is private to the team and consequently only visible to team members. Note that private projects cannot contain public repositories.
     */
    'is_private'?: boolean;
    'created_on'?: string;
    'updated_on'?: string;
    /**
     *  Indicates whether the project contains publicly visible repositories. Note that private projects cannot contain public repositories.
     */
    'has_publicly_visible_repos'?: boolean;
}
export interface ProjectBranchingModel extends ModelObject {
    /**
     * The active branch types.
     */
    'branch_types'?: Set<object>;
    'development'?: object;
    'production'?: object;
}
export interface ProjectDeployKey extends ModelObject {
    /**
     * The deploy key value.
     */
    'key'?: string;
    'project'?: Project;
    /**
     * The comment parsed from the deploy key (if present)
     */
    'comment'?: string;
    /**
     * The user-defined label for the deploy key
     */
    'label'?: string;
    'added_on'?: string;
    'last_used'?: string;
    'links'?: object;
    'created_by'?: Account;
}
/**
 * A group\'s permission for a given project.
 */
export interface ProjectGroupPermission {
    [key: string]: any;

    'type': string;
    'links'?: object;
    'permission'?: ProjectGroupPermissionPermissionEnum;
    'group'?: Group;
    'project'?: Project;
}

export const ProjectGroupPermissionPermissionEnum = {
    Read: 'read',
    Write: 'write',
    CreateRepo: 'create-repo',
    Admin: 'admin',
    None: 'none'
} as const;

export type ProjectGroupPermissionPermissionEnum = typeof ProjectGroupPermissionPermissionEnum[keyof typeof ProjectGroupPermissionPermissionEnum];

/**
 * A user\'s direct permission for a given project.
 */
export interface ProjectUserPermission {
    [key: string]: any;

    'type': string;
    'links'?: object;
    'permission'?: ProjectUserPermissionPermissionEnum;
    'user'?: User;
    'project'?: Project;
}

export const ProjectUserPermissionPermissionEnum = {
    Read: 'read',
    Write: 'write',
    CreateRepo: 'create-repo',
    Admin: 'admin',
    None: 'none'
} as const;

export type ProjectUserPermissionPermissionEnum = typeof ProjectUserPermissionPermissionEnum[keyof typeof ProjectUserPermissionPermissionEnum];

export interface Pullrequest extends ModelObject {
    'links'?: object;
    /**
     * The pull request\'s unique ID. Note that pull request IDs are only unique within their associated repository.
     */
    'id'?: number;
    /**
     * Title of the pull request.
     */
    'title'?: string;
    /**
     * User provided pull request text, interpreted in a markup language and rendered in HTML
     */
    'rendered'?: object;
    'summary'?: object;
    /**
     * The pull request\'s current status.
     */
    'state'?: PullrequestStateEnum;
    'author'?: Account;
    'source'?: PullrequestEndpoint;
    'destination'?: PullrequestEndpoint;
    'merge_commit'?: object;
    /**
     * The number of comments for a specific pull request.
     */
    'comment_count'?: number;
    /**
     * The number of open tasks for a specific pull request.
     */
    'task_count'?: number;
    /**
     * A boolean flag indicating if merging the pull request closes the source branch.
     */
    'close_source_branch'?: boolean;
    'closed_by'?: Account;
    /**
     * Explains why a pull request was declined. This field is only applicable to pull requests in rejected state.
     */
    'reason'?: string;
    /**
     * The ISO8601 timestamp the request was created.
     */
    'created_on'?: string;
    /**
     * The ISO8601 timestamp the request was last updated.
     */
    'updated_on'?: string;
    /**
     * The list of users that were added as reviewers on this pull request when it was created. For performance reasons, the API only includes this list on a pull request\'s `self` URL.
     */
    'reviewers'?: Array<Account>;
    /**
     *         The list of users that are collaborating on this pull request.         Collaborators are user that:          * are added to the pull request as a reviewer (part of the reviewers           list)         * are not explicit reviewers, but have commented on the pull request         * are not explicit reviewers, but have approved the pull request          Each user is wrapped in an object that indicates the user\'s role and         whether they have approved the pull request. For performance reasons,         the API only returns this list when an API requests a pull request by         id.         
     */
    'participants'?: Array<Participant>;
    /**
     * A boolean flag indicating whether the pull request is a draft.
     */
    'draft'?: boolean;
    /**
     * A boolean flag indicating whether the pull request is queued
     */
    'queued'?: boolean;
}

export const PullrequestStateEnum = {
    Open: 'OPEN',
    Merged: 'MERGED',
    Declined: 'DECLINED',
    Superseded: 'SUPERSEDED'
} as const;

export type PullrequestStateEnum = typeof PullrequestStateEnum[keyof typeof PullrequestStateEnum];

export interface PullrequestComment extends Comment {
    'pullrequest'?: Pullrequest;
    'resolution'?: CommentResolution;
    'pending'?: boolean;
}
export interface PullrequestCommentTask {
    'id'?: number;
    'created_on': string;
    'updated_on': string;
    'state': PullrequestCommentTaskStateEnum;
    'content': object;
    'creator': Account;
    'pending'?: boolean;
    /**
     * The ISO8601 timestamp for when the task was resolved.
     */
    'resolved_on'?: string;
    'resolved_by'?: Account;
    'links'?: object;
    'comment'?: Comment;
}

export const PullrequestCommentTaskStateEnum = {
    Resolved: 'RESOLVED',
    Unresolved: 'UNRESOLVED'
} as const;

export type PullrequestCommentTaskStateEnum = typeof PullrequestCommentTaskStateEnum[keyof typeof PullrequestCommentTaskStateEnum];

export interface PullrequestEndpoint {
    'repository'?: Repository;
    'branch'?: object;
    'commit'?: object;
}
/**
 * The metadata that describes a pull request merge.
 */
export interface PullrequestMergeParameters {
    [key: string]: any;

    'type': string;
    /**
     * The commit message that will be used on the resulting commit. Note that the size of the message is limited to 128 KiB.
     */
    'message'?: string;
    /**
     * Whether the source branch should be deleted. If this is not provided, we fallback to the value used when the pull request was created, which defaults to False
     */
    'close_source_branch'?: boolean;
    /**
     * The merge strategy that will be used to merge the pull request.
     */
    'merge_strategy'?: PullrequestMergeParametersMergeStrategyEnum;
}

export const PullrequestMergeParametersMergeStrategyEnum = {
    MergeCommit: 'merge_commit',
    Squash: 'squash',
    FastForward: 'fast_forward',
    SquashFastForward: 'squash_fast_forward',
    RebaseFastForward: 'rebase_fast_forward',
    RebaseMerge: 'rebase_merge'
} as const;

export type PullrequestMergeParametersMergeStrategyEnum = typeof PullrequestMergeParametersMergeStrategyEnum[keyof typeof PullrequestMergeParametersMergeStrategyEnum];

export interface PullrequestTask {
    'id'?: number;
    'created_on': string;
    'updated_on': string;
    'state': PullrequestTaskStateEnum;
    'content': object;
    'creator': Account;
    'pending'?: boolean;
    /**
     * The ISO8601 timestamp for when the task was resolved.
     */
    'resolved_on'?: string;
    'resolved_by'?: Account;
    'links'?: object;
}

export const PullrequestTaskStateEnum = {
    Resolved: 'RESOLVED',
    Unresolved: 'UNRESOLVED'
} as const;

export type PullrequestTaskStateEnum = typeof PullrequestTaskStateEnum[keyof typeof PullrequestTaskStateEnum];

/**
 * A pullrequest task create
 */
export interface PullrequestTaskCreate {
    /**
     * task raw content
     */
    'content': object;
    'comment'?: Comment;
    'pending'?: boolean;
}
/**
 * A pullrequest task update
 */
export interface PullrequestTaskUpdate {
    /**
     * task raw content
     */
    'content'?: object;
    'state'?: PullrequestTaskUpdateStateEnum;
}

export const PullrequestTaskUpdateStateEnum = {
    Resolved: 'RESOLVED',
    Unresolved: 'UNRESOLVED'
} as const;

export type PullrequestTaskUpdateStateEnum = typeof PullrequestTaskUpdateStateEnum[keyof typeof PullrequestTaskUpdateStateEnum];

/**
 * A ref object, representing a branch or tag in a repository.
 */
export interface Ref {
    [key: string]: any;

    'type': string;
    'links'?: object;
    /**
     * The name of the ref.
     */
    'name'?: string;
    'target'?: Commit;
}
export interface Report extends ModelObject {
    /**
     * The UUID that can be used to identify the report.
     */
    'uuid'?: string;
    /**
     * The title of the report.
     */
    'title'?: string;
    /**
     * A string to describe the purpose of the report.
     */
    'details'?: string;
    /**
     * ID of the report provided by the report creator. It can be used to identify the report as an alternative to it\'s generated uuid. It is not used by Bitbucket, but only by the report creator for updating or deleting this specific report. Needs to be unique.
     */
    'external_id'?: string;
    /**
     * A string to describe the tool or company who created the report.
     */
    'reporter'?: string;
    /**
     * A URL linking to the results of the report in an external tool.
     */
    'link'?: string;
    /**
     * If enabled, a remote link is created in Jira for the work item associated with the commit the report belongs to.
     */
    'remote_link_enabled'?: boolean;
    /**
     * A URL to the report logo. If none is provided, the default insights logo will be used.
     */
    'logo_url'?: string;
    /**
     * The type of the report.
     */
    'report_type'?: ReportReportTypeEnum;
    /**
     * The state of the report. May be set to PENDING and later updated.
     */
    'result'?: ReportResultEnum;
    /**
     * An array of data fields to display information on the report. Maximum 10.
     */
    'data'?: Array<ReportData>;
    /**
     * The timestamp when the report was created.
     */
    'created_on'?: string;
    /**
     * The timestamp when the report was updated.
     */
    'updated_on'?: string;
}

export const ReportReportTypeEnum = {
    Security: 'SECURITY',
    Coverage: 'COVERAGE',
    Test: 'TEST',
    Bug: 'BUG'
} as const;

export type ReportReportTypeEnum = typeof ReportReportTypeEnum[keyof typeof ReportReportTypeEnum];
export const ReportResultEnum = {
    Passed: 'PASSED',
    Failed: 'FAILED',
    Pending: 'PENDING'
} as const;

export type ReportResultEnum = typeof ReportResultEnum[keyof typeof ReportResultEnum];

export interface ReportAnnotation extends ModelObject {
    /**
     * ID of the annotation provided by the annotation creator. It can be used to identify the annotation as an alternative to it\'s generated uuid. It is not used by Bitbucket, but only by the annotation creator for updating or deleting this specific annotation. Needs to be unique.
     */
    'external_id'?: string;
    /**
     * The UUID that can be used to identify the annotation.
     */
    'uuid'?: string;
    /**
     * The type of the report.
     */
    'annotation_type'?: ReportAnnotationAnnotationTypeEnum;
    /**
     * The path of the file on which this annotation should be placed. This is the path of the file relative to the git repository. If no path is provided, then it will appear in the overview modal on all pull requests where the tip of the branch is the given commit, regardless of which files were modified.
     */
    'path'?: string;
    /**
     * The line number that the annotation should belong to. If no line number is provided, then it will default to 0 and in a pull request it will appear at the top of the file specified by the path field.
     */
    'line'?: number;
    /**
     * The message to display to users.
     */
    'summary'?: string;
    /**
     * The details to show to users when clicking on the annotation.
     */
    'details'?: string;
    /**
     * The state of the report. May be set to PENDING and later updated.
     */
    'result'?: ReportAnnotationResultEnum;
    /**
     * The severity of the annotation.
     */
    'severity'?: ReportAnnotationSeverityEnum;
    /**
     * A URL linking to the annotation in an external tool.
     */
    'link'?: string;
    /**
     * The timestamp when the report was created.
     */
    'created_on'?: string;
    /**
     * The timestamp when the report was updated.
     */
    'updated_on'?: string;
}

export const ReportAnnotationAnnotationTypeEnum = {
    Vulnerability: 'VULNERABILITY',
    CodeSmell: 'CODE_SMELL',
    Bug: 'BUG'
} as const;

export type ReportAnnotationAnnotationTypeEnum = typeof ReportAnnotationAnnotationTypeEnum[keyof typeof ReportAnnotationAnnotationTypeEnum];
export const ReportAnnotationResultEnum = {
    Passed: 'PASSED',
    Failed: 'FAILED',
    Skipped: 'SKIPPED',
    Ignored: 'IGNORED'
} as const;

export type ReportAnnotationResultEnum = typeof ReportAnnotationResultEnum[keyof typeof ReportAnnotationResultEnum];
export const ReportAnnotationSeverityEnum = {
    Critical: 'CRITICAL',
    High: 'HIGH',
    Medium: 'MEDIUM',
    Low: 'LOW'
} as const;

export type ReportAnnotationSeverityEnum = typeof ReportAnnotationSeverityEnum[keyof typeof ReportAnnotationSeverityEnum];

/**
 * A key-value element that will be displayed along with the report.
 */
export interface ReportData {
    /**
     * The type of data contained in the value field. If not provided, then the value will be detected as a boolean, number or string.
     */
    'type'?: ReportDataTypeEnum;
    /**
     * A string describing what this data field represents.
     */
    'title'?: string;
    /**
     * The value of the data element.
     */
    'value'?: object;
}

export const ReportDataTypeEnum = {
    Boolean: 'BOOLEAN',
    Date: 'DATE',
    Duration: 'DURATION',
    Link: 'LINK',
    Number: 'NUMBER',
    Percentage: 'PERCENTAGE',
    Text: 'TEXT'
} as const;

export type ReportDataTypeEnum = typeof ReportDataTypeEnum[keyof typeof ReportDataTypeEnum];

export interface Repository extends ModelObject {
    'links'?: object;
    /**
     * The repository\'s immutable id. This can be used as a substitute for the slug segment in URLs. Doing this guarantees your URLs will survive renaming of the repository by its owner, or even transfer of the repository to a different user.
     */
    'uuid'?: string;
    /**
     * The concatenation of the repository owner\'s username and the slugified name, e.g. \"evzijst/interruptingcow\". This is the same string used in Bitbucket URLs.
     */
    'full_name'?: string;
    'is_private'?: boolean;
    'parent'?: Repository;
    'scm'?: RepositoryScmEnum;
    'owner'?: Account;
    'name'?: string;
    'description'?: string;
    'created_on'?: string;
    'updated_on'?: string;
    'size'?: number;
    'language'?: string;
    /**
     *  The issue tracker for this repository is enabled. Issue Tracker features are not supported for repositories in workspaces administered through admin.atlassian.com. 
     */
    'has_issues'?: boolean;
    /**
     *  The wiki for this repository is enabled. Wiki features are not supported for repositories in workspaces administered through admin.atlassian.com. 
     */
    'has_wiki'?: boolean;
    /**
     *  Controls the rules for forking this repository.  * **allow_forks**: unrestricted forking * **no_public_forks**: restrict forking to private forks (forks cannot   be made public later) * **no_forks**: deny all forking 
     */
    'fork_policy'?: RepositoryForkPolicyEnum;
    'project'?: Project;
    'mainbranch'?: Branch;
}

export const RepositoryScmEnum = {
    Git: 'git'
} as const;

export type RepositoryScmEnum = typeof RepositoryScmEnum[keyof typeof RepositoryScmEnum];
export const RepositoryForkPolicyEnum = {
    AllowForks: 'allow_forks',
    NoPublicForks: 'no_public_forks',
    NoForks: 'no_forks'
} as const;

export type RepositoryForkPolicyEnum = typeof RepositoryForkPolicyEnum[keyof typeof RepositoryForkPolicyEnum];

/**
 * A group\'s permission for a given repository.
 */
export interface RepositoryGroupPermission {
    [key: string]: any;

    'type': string;
    'links'?: object;
    'permission'?: RepositoryGroupPermissionPermissionEnum;
    'group'?: Group;
    'repository'?: Repository;
}

export const RepositoryGroupPermissionPermissionEnum = {
    Read: 'read',
    Write: 'write',
    Admin: 'admin',
    None: 'none'
} as const;

export type RepositoryGroupPermissionPermissionEnum = typeof RepositoryGroupPermissionPermissionEnum[keyof typeof RepositoryGroupPermissionPermissionEnum];

/**
 * A json object representing the repository\'s inheritance state values
 */
export interface RepositoryInheritanceState {
    [key: string]: any;

    'type': string;
    'override_settings'?: object;
}
/**
 * A user\'s permission for a given repository.
 */
export interface RepositoryPermission {
    [key: string]: any;

    'type': string;
    'permission'?: RepositoryPermissionPermissionEnum;
    'user'?: User;
    'repository'?: Repository;
}

export const RepositoryPermissionPermissionEnum = {
    Read: 'read',
    Write: 'write',
    Admin: 'admin',
    None: 'none'
} as const;

export type RepositoryPermissionPermissionEnum = typeof RepositoryPermissionPermissionEnum[keyof typeof RepositoryPermissionPermissionEnum];

/**
 * A user\'s direct permission for a given repository.
 */
export interface RepositoryUserPermission {
    [key: string]: any;

    'type': string;
    'permission'?: RepositoryUserPermissionPermissionEnum;
    'user'?: User;
    'repository'?: Repository;
    'links'?: object;
}

export const RepositoryUserPermissionPermissionEnum = {
    Read: 'read',
    Write: 'write',
    Admin: 'admin',
    None: 'none'
} as const;

export type RepositoryUserPermissionPermissionEnum = typeof RepositoryUserPermissionPermissionEnum[keyof typeof RepositoryUserPermissionPermissionEnum];

/**
 * The target on which the schedule will be executed.
 */
export interface RequestBodyForPipelineSchedulePOSTRequestTarget {
    'selector': PipelineSelector;
    /**
     * The name of the reference.
     */
    'ref_name': string;
    /**
     * The type of reference (branch only).
     */
    'ref_type': RequestBodyForPipelineSchedulePOSTRequestTargetRefTypeEnum;
}

export const RequestBodyForPipelineSchedulePOSTRequestTargetRefTypeEnum = {
    Branch: 'branch'
} as const;

export type RequestBodyForPipelineSchedulePOSTRequestTargetRefTypeEnum = typeof RequestBodyForPipelineSchedulePOSTRequestTargetRefTypeEnum[keyof typeof RequestBodyForPipelineSchedulePOSTRequestTargetRefTypeEnum];

export interface SearchCodeSearchResult {
    'type'?: string;
    'content_match_count'?: number;
    'content_matches'?: Array<SearchContentMatch>;
    'path_matches'?: Array<SearchSegment>;
    'file'?: CommitFile;
}
export interface SearchContentMatch {
    'lines'?: Array<SearchLine>;
}
export interface SearchLine {
    'line'?: number;
    'segments'?: Array<SearchSegment>;
}
export interface SearchResultPage {
    'size'?: number;
    'page'?: number;
    'pagelen'?: number;
    'query_substituted'?: boolean;
    'next'?: string;
    'previous'?: string;
    'values'?: Array<SearchCodeSearchResult>;
}
export interface SearchSegment {
    'text'?: string;
    'match'?: boolean;
}
export interface Snippet extends ModelObject {
    'id'?: number;
    'title'?: string;
    /**
     * The DVCS used to store the snippet.
     */
    'scm'?: SnippetScmEnum;
    'created_on'?: string;
    'updated_on'?: string;
    'owner'?: Account;
    'creator'?: Account;
    'is_private'?: boolean;
}

export const SnippetScmEnum = {
    Git: 'git'
} as const;

export type SnippetScmEnum = typeof SnippetScmEnum[keyof typeof SnippetScmEnum];

export interface SnippetComment extends ModelObject {
    'links'?: object;
    'snippet'?: Snippet;
}
export interface SnippetCommit extends BaseCommit {
    'links'?: object;
    'snippet'?: Snippet;
}
export interface SshAccountKey extends SshKey {
    'owner'?: Account;
    'expires_on'?: string;
    /**
     * The SSH key fingerprint in SHA-256 format.
     */
    'fingerprint'?: string;
}
export interface SshKey extends ModelObject {
    /**
     * The SSH key\'s immutable ID.
     */
    'uuid'?: string;
    /**
     * The SSH public key value in OpenSSH format.
     */
    'key'?: string;
    /**
     * The comment parsed from the SSH key (if present)
     */
    'comment'?: string;
    /**
     * The user-defined label for the SSH key
     */
    'label'?: string;
    'created_on'?: string;
    'last_used'?: string;
    'links'?: object;
}
/**
 * The mapping of resource/subject types pointing to their individual event types.
 */
export interface SubjectTypes {
    'repository'?: object;
    'workspace'?: object;
}
export interface Tag {
    'type': string;
    'links'?: object;
    /**
     * The name of the ref.
     */
    'name'?: string;
    'target'?: Commit;
    /**
     * The message associated with the tag, if available.
     */
    'message'?: string;
    /**
     * The date that the tag was created, if available
     */
    'date'?: string;
    'tagger'?: Author;
}
/**
 * A task object.
 */
export interface Task {
    'id'?: number;
    'created_on': string;
    'updated_on': string;
    'state': TaskStateEnum;
    'content': object;
    'creator': Account;
    'pending'?: boolean;
    /**
     * The ISO8601 timestamp for when the task was resolved.
     */
    'resolved_on'?: string;
    'resolved_by'?: Account;
}

export const TaskStateEnum = {
    Resolved: 'RESOLVED',
    Unresolved: 'UNRESOLVED'
} as const;

export type TaskStateEnum = typeof TaskStateEnum[keyof typeof TaskStateEnum];

export interface Team extends Account {
    'links'?: TeamLinks;
}
export interface TeamLinks {
    'avatar'?: Link;
    'self'?: Link;
    'html'?: Link;
    'members'?: Link;
    'projects'?: Link;
    'repositories'?: Link;
}
/**
 * Base type for most resource objects. It defines the common `type` element that identifies an object\'s type. It also identifies the element as Swagger\'s `discriminator`.
 */
export interface Treeentry {
    [key: string]: any;

    'type': string;
    /**
     * The path in the repository
     */
    'path'?: string;
    'commit'?: Commit;
}
export interface User extends Account {
    'links'?: UserLinks;
    /**
     * The user\'s Atlassian account ID.
     */
    'account_id'?: string;
    /**
     * The status of the account. Currently the only possible value is \"active\", but more values may be added in the future.
     */
    'account_status'?: string;
    'has_2fa_enabled'?: boolean;
    /**
     * Account name defined by the owner. Should be used instead of the \"username\" field. Note that \"nickname\" cannot be used in place of \"username\" in URLs and queries, as \"nickname\" is not guaranteed to be unique.
     */
    'nickname'?: string;
    'is_staff'?: boolean;
}
export interface UserLinks {
    'avatar'?: Link;
    'self'?: Link;
    'html'?: Link;
    'repositories'?: Link;
}
export interface Version extends ModelObject {
    'links'?: object;
    'name'?: string;
    'id'?: number;
}
export interface WebhookSubscription extends ModelObject {
    /**
     * The webhook\'s id
     */
    'uuid'?: string;
    /**
     * The URL events get delivered to.
     */
    'url'?: string;
    /**
     * A user-defined description of the webhook.
     */
    'description'?: string;
    /**
     * The type of entity. Set to either `repository` or `workspace` based on where the subscription is defined.
     */
    'subject_type'?: WebhookSubscriptionSubjectTypeEnum;
    'subject'?: object;
    'active'?: boolean;
    'created_at'?: string;
    /**
     * The events this webhook is subscribed to.
     */
    'events'?: Set<WebhookSubscriptionEventsEnum>;
    /**
     * Indicates whether or not the hook has an associated secret. It is not possible to see the hook\'s secret. This field is ignored during updates.
     */
    'secret_set'?: boolean;
    /**
     * The secret to associate with the hook. The secret is never returned via the API. As such, this field is only used during updates. The secret can be set to `null` or \"\" to remove the secret (or create a hook with no secret). Leaving out the secret field during updates will leave the secret unchanged. Leaving out the secret during creation will create a hook with no secret.
     */
    'secret'?: string;
}

export const WebhookSubscriptionSubjectTypeEnum = {
    Repository: 'repository',
    Workspace: 'workspace'
} as const;

export type WebhookSubscriptionSubjectTypeEnum = typeof WebhookSubscriptionSubjectTypeEnum[keyof typeof WebhookSubscriptionSubjectTypeEnum];
export const WebhookSubscriptionEventsEnum = {
    IssueCommentCreated: 'issue:comment_created',
    IssueCreated: 'issue:created',
    IssueUpdated: 'issue:updated',
    ProjectUpdated: 'project:updated',
    PullrequestApproved: 'pullrequest:approved',
    PullrequestChangesRequestCreated: 'pullrequest:changes_request_created',
    PullrequestChangesRequestRemoved: 'pullrequest:changes_request_removed',
    PullrequestCommentCreated: 'pullrequest:comment_created',
    PullrequestCommentDeleted: 'pullrequest:comment_deleted',
    PullrequestCommentReopened: 'pullrequest:comment_reopened',
    PullrequestCommentResolved: 'pullrequest:comment_resolved',
    PullrequestCommentUpdated: 'pullrequest:comment_updated',
    PullrequestCreated: 'pullrequest:created',
    PullrequestFulfilled: 'pullrequest:fulfilled',
    PullrequestPush: 'pullrequest:push',
    PullrequestRejected: 'pullrequest:rejected',
    PullrequestUnapproved: 'pullrequest:unapproved',
    PullrequestUpdated: 'pullrequest:updated',
    RepoCommitCommentCreated: 'repo:commit_comment_created',
    RepoCommitStatusCreated: 'repo:commit_status_created',
    RepoCommitStatusUpdated: 'repo:commit_status_updated',
    RepoCreated: 'repo:created',
    RepoDeleted: 'repo:deleted',
    RepoFork: 'repo:fork',
    RepoImported: 'repo:imported',
    RepoPush: 'repo:push',
    RepoTransfer: 'repo:transfer',
    RepoUpdated: 'repo:updated'
} as const;

export type WebhookSubscriptionEventsEnum = typeof WebhookSubscriptionEventsEnum[keyof typeof WebhookSubscriptionEventsEnum];

export interface Workspace extends ModelObject {
    'links'?: object;
    /**
     * The workspace\'s immutable id.
     */
    'uuid'?: string;
    /**
     * The name of the workspace.
     */
    'name'?: string;
    /**
     * The short label that identifies this workspace.
     */
    'slug'?: string;
    /**
     * Indicates whether the workspace is publicly accessible, or whether it is private to the members and consequently only visible to members.
     */
    'is_private'?: boolean;
    /**
     * Indicates whether the workspace enforces private content, or whether it allows public content.
     */
    'is_privacy_enforced'?: boolean;
    /**
     * Controls the rules for forking repositories within this workspace.  * **allow_forks**: unrestricted forking * **internal_only**: prevents forking of private repositories outside the workspace or to public repositories 
     */
    'forking_mode'?: WorkspaceForkingModeEnum;
    'created_on'?: string;
    'updated_on'?: string;
}

export const WorkspaceForkingModeEnum = {
    AllowForks: 'allow_forks',
    InternalOnly: 'internal_only'
} as const;

export type WorkspaceForkingModeEnum = typeof WorkspaceForkingModeEnum[keyof typeof WorkspaceForkingModeEnum];

export interface WorkspaceMembership extends ModelObject {
    'links'?: object;
    'user'?: Account;
    'workspace'?: Workspace;
}

/**
 * AddonApi - axios parameter creator
 */
export const AddonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the application for the user.  This endpoint is intended to be used by Bitbucket Connect apps and only supports JWT authentication -- that is how Bitbucket identifies the particular installation of the app. Developers with applications registered in the \"Develop Apps\" section of Bitbucket Marketplace need not use this endpoint as updates for those applications can be sent out via the UI of that section.  ``` $ curl -X DELETE https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" ```
         * @summary Delete an app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/addon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all [linkers](/cloud/bitbucket/modules/linker/) for the authenticated application.
         * @summary List linkers for an app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/addon/linkers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a [linker](/cloud/bitbucket/modules/linker/) specified by `linker_key` for the authenticated application.
         * @summary Get a linker for an app
         * @param {string} linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersLinkerKeyGet: async (linkerKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkerKey' is not null or undefined
            assertParamExists('addonLinkersLinkerKeyGet', 'linkerKey', linkerKey)
            const localVarPath = `/addon/linkers/{linker_key}`
                .replace(`{${"linker_key"}}`, encodeURIComponent(String(linkerKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.
         * @summary Delete all linker values
         * @param {string} linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersLinkerKeyValuesDelete: async (linkerKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkerKey' is not null or undefined
            assertParamExists('addonLinkersLinkerKeyValuesDelete', 'linkerKey', linkerKey)
            const localVarPath = `/addon/linkers/{linker_key}/values`
                .replace(`{${"linker_key"}}`, encodeURIComponent(String(linkerKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
         * @summary List linker values for a linker
         * @param {string} linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersLinkerKeyValuesGet: async (linkerKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkerKey' is not null or undefined
            assertParamExists('addonLinkersLinkerKeyValuesGet', 'linkerKey', linkerKey)
            const localVarPath = `/addon/linkers/{linker_key}/values`
                .replace(`{${"linker_key"}}`, encodeURIComponent(String(linkerKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a [linker](/cloud/bitbucket/modules/linker/) value for the specified linker of authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
         * @summary Create a linker value
         * @param {string} linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersLinkerKeyValuesPost: async (linkerKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkerKey' is not null or undefined
            assertParamExists('addonLinkersLinkerKeyValuesPost', 'linkerKey', linkerKey)
            const localVarPath = `/addon/linkers/{linker_key}/values`
                .replace(`{${"linker_key"}}`, encodeURIComponent(String(linkerKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk update [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
         * @summary Update a linker value
         * @param {string} linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersLinkerKeyValuesPut: async (linkerKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkerKey' is not null or undefined
            assertParamExists('addonLinkersLinkerKeyValuesPut', 'linkerKey', linkerKey)
            const localVarPath = `/addon/linkers/{linker_key}/values`
                .replace(`{${"linker_key"}}`, encodeURIComponent(String(linkerKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a single [linker](/cloud/bitbucket/modules/linker/) value of the authenticated application.
         * @summary Delete a linker value
         * @param {string} linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
         * @param {number} valueId The numeric ID of the linker value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersLinkerKeyValuesValueIdDelete: async (linkerKey: string, valueId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkerKey' is not null or undefined
            assertParamExists('addonLinkersLinkerKeyValuesValueIdDelete', 'linkerKey', linkerKey)
            // verify required parameter 'valueId' is not null or undefined
            assertParamExists('addonLinkersLinkerKeyValuesValueIdDelete', 'valueId', valueId)
            const localVarPath = `/addon/linkers/{linker_key}/values/{value_id}`
                .replace(`{${"linker_key"}}`, encodeURIComponent(String(linkerKey)))
                .replace(`{${"value_id"}}`, encodeURIComponent(String(valueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single [linker](/cloud/bitbucket/modules/linker/) value of the authenticated application.
         * @summary Get a linker value
         * @param {string} linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
         * @param {number} valueId The numeric ID of the linker value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersLinkerKeyValuesValueIdGet: async (linkerKey: string, valueId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkerKey' is not null or undefined
            assertParamExists('addonLinkersLinkerKeyValuesValueIdGet', 'linkerKey', linkerKey)
            // verify required parameter 'valueId' is not null or undefined
            assertParamExists('addonLinkersLinkerKeyValuesValueIdGet', 'valueId', valueId)
            const localVarPath = `/addon/linkers/{linker_key}/values/{value_id}`
                .replace(`{${"linker_key"}}`, encodeURIComponent(String(linkerKey)))
                .replace(`{${"value_id"}}`, encodeURIComponent(String(valueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the application installation for the user.  This endpoint is intended to be used by Bitbucket Connect apps and only supports JWT authentication -- that is how Bitbucket identifies the particular installation of the app. Developers with applications registered in the \"Develop Apps\" section of Bitbucket need not use this endpoint as updates for those applications can be sent out via the UI of that section.  Passing an empty body will update the installation using the existing descriptor URL.  ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{}\' ```  The new `descriptor` for the installation can be also provided in the body directly.  ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{\"descriptor\": $NEW_DESCRIPTOR}\' ```  In both these modes the URL of the descriptor cannot be changed. To change the descriptor location and upgrade an installation the request must be made exclusively with a `descriptor_url`.   ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{\"descriptor_url\": $NEW_URL}\' ```  The `descriptor_url` must exactly match the marketplace registration that Atlassian has for the application. Contact your Atlassian developer advocate to update this registration. Once the registration has been updated you may call this resource for each installation.  Note that the scopes of the application cannot be increased in the new descriptor nor reduced to none.
         * @summary Update an installed app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonPut: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/addon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddonApi - functional programming interface
 */
export const AddonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddonApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the application for the user.  This endpoint is intended to be used by Bitbucket Connect apps and only supports JWT authentication -- that is how Bitbucket identifies the particular installation of the app. Developers with applications registered in the \"Develop Apps\" section of Bitbucket Marketplace need not use this endpoint as updates for those applications can be sent out via the UI of that section.  ``` $ curl -X DELETE https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" ```
         * @summary Delete an app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addonDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addonDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonApi.addonDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a list of all [linkers](/cloud/bitbucket/modules/linker/) for the authenticated application.
         * @summary List linkers for an app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addonLinkersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addonLinkersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonApi.addonLinkersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a [linker](/cloud/bitbucket/modules/linker/) specified by `linker_key` for the authenticated application.
         * @summary Get a linker for an app
         * @param {string} linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addonLinkersLinkerKeyGet(linkerKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addonLinkersLinkerKeyGet(linkerKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonApi.addonLinkersLinkerKeyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete all [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.
         * @summary Delete all linker values
         * @param {string} linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addonLinkersLinkerKeyValuesDelete(linkerKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addonLinkersLinkerKeyValuesDelete(linkerKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonApi.addonLinkersLinkerKeyValuesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a list of all [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
         * @summary List linker values for a linker
         * @param {string} linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addonLinkersLinkerKeyValuesGet(linkerKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addonLinkersLinkerKeyValuesGet(linkerKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonApi.addonLinkersLinkerKeyValuesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a [linker](/cloud/bitbucket/modules/linker/) value for the specified linker of authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
         * @summary Create a linker value
         * @param {string} linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addonLinkersLinkerKeyValuesPost(linkerKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addonLinkersLinkerKeyValuesPost(linkerKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonApi.addonLinkersLinkerKeyValuesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk update [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
         * @summary Update a linker value
         * @param {string} linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addonLinkersLinkerKeyValuesPut(linkerKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addonLinkersLinkerKeyValuesPut(linkerKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonApi.addonLinkersLinkerKeyValuesPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a single [linker](/cloud/bitbucket/modules/linker/) value of the authenticated application.
         * @summary Delete a linker value
         * @param {string} linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
         * @param {number} valueId The numeric ID of the linker value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addonLinkersLinkerKeyValuesValueIdDelete(linkerKey: string, valueId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addonLinkersLinkerKeyValuesValueIdDelete(linkerKey, valueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonApi.addonLinkersLinkerKeyValuesValueIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a single [linker](/cloud/bitbucket/modules/linker/) value of the authenticated application.
         * @summary Get a linker value
         * @param {string} linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
         * @param {number} valueId The numeric ID of the linker value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addonLinkersLinkerKeyValuesValueIdGet(linkerKey: string, valueId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addonLinkersLinkerKeyValuesValueIdGet(linkerKey, valueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonApi.addonLinkersLinkerKeyValuesValueIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the application installation for the user.  This endpoint is intended to be used by Bitbucket Connect apps and only supports JWT authentication -- that is how Bitbucket identifies the particular installation of the app. Developers with applications registered in the \"Develop Apps\" section of Bitbucket need not use this endpoint as updates for those applications can be sent out via the UI of that section.  Passing an empty body will update the installation using the existing descriptor URL.  ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{}\' ```  The new `descriptor` for the installation can be also provided in the body directly.  ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{\"descriptor\": $NEW_DESCRIPTOR}\' ```  In both these modes the URL of the descriptor cannot be changed. To change the descriptor location and upgrade an installation the request must be made exclusively with a `descriptor_url`.   ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{\"descriptor_url\": $NEW_URL}\' ```  The `descriptor_url` must exactly match the marketplace registration that Atlassian has for the application. Contact your Atlassian developer advocate to update this registration. Once the registration has been updated you may call this resource for each installation.  Note that the scopes of the application cannot be increased in the new descriptor nor reduced to none.
         * @summary Update an installed app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addonPut(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addonPut(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonApi.addonPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddonApi - factory interface
 */
export const AddonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddonApiFp(configuration)
    return {
        /**
         * Deletes the application for the user.  This endpoint is intended to be used by Bitbucket Connect apps and only supports JWT authentication -- that is how Bitbucket identifies the particular installation of the app. Developers with applications registered in the \"Develop Apps\" section of Bitbucket Marketplace need not use this endpoint as updates for those applications can be sent out via the UI of that section.  ``` $ curl -X DELETE https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" ```
         * @summary Delete an app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonDelete(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addonDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all [linkers](/cloud/bitbucket/modules/linker/) for the authenticated application.
         * @summary List linkers for an app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addonLinkersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a [linker](/cloud/bitbucket/modules/linker/) specified by `linker_key` for the authenticated application.
         * @summary Get a linker for an app
         * @param {AddonApiAddonLinkersLinkerKeyGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersLinkerKeyGet(requestParameters: AddonApiAddonLinkersLinkerKeyGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addonLinkersLinkerKeyGet(requestParameters.linkerKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.
         * @summary Delete all linker values
         * @param {AddonApiAddonLinkersLinkerKeyValuesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersLinkerKeyValuesDelete(requestParameters: AddonApiAddonLinkersLinkerKeyValuesDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addonLinkersLinkerKeyValuesDelete(requestParameters.linkerKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
         * @summary List linker values for a linker
         * @param {AddonApiAddonLinkersLinkerKeyValuesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersLinkerKeyValuesGet(requestParameters: AddonApiAddonLinkersLinkerKeyValuesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addonLinkersLinkerKeyValuesGet(requestParameters.linkerKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a [linker](/cloud/bitbucket/modules/linker/) value for the specified linker of authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
         * @summary Create a linker value
         * @param {AddonApiAddonLinkersLinkerKeyValuesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersLinkerKeyValuesPost(requestParameters: AddonApiAddonLinkersLinkerKeyValuesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addonLinkersLinkerKeyValuesPost(requestParameters.linkerKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk update [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
         * @summary Update a linker value
         * @param {AddonApiAddonLinkersLinkerKeyValuesPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersLinkerKeyValuesPut(requestParameters: AddonApiAddonLinkersLinkerKeyValuesPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addonLinkersLinkerKeyValuesPut(requestParameters.linkerKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a single [linker](/cloud/bitbucket/modules/linker/) value of the authenticated application.
         * @summary Delete a linker value
         * @param {AddonApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersLinkerKeyValuesValueIdDelete(requestParameters: AddonApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addonLinkersLinkerKeyValuesValueIdDelete(requestParameters.linkerKey, requestParameters.valueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single [linker](/cloud/bitbucket/modules/linker/) value of the authenticated application.
         * @summary Get a linker value
         * @param {AddonApiAddonLinkersLinkerKeyValuesValueIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonLinkersLinkerKeyValuesValueIdGet(requestParameters: AddonApiAddonLinkersLinkerKeyValuesValueIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addonLinkersLinkerKeyValuesValueIdGet(requestParameters.linkerKey, requestParameters.valueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the application installation for the user.  This endpoint is intended to be used by Bitbucket Connect apps and only supports JWT authentication -- that is how Bitbucket identifies the particular installation of the app. Developers with applications registered in the \"Develop Apps\" section of Bitbucket need not use this endpoint as updates for those applications can be sent out via the UI of that section.  Passing an empty body will update the installation using the existing descriptor URL.  ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{}\' ```  The new `descriptor` for the installation can be also provided in the body directly.  ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{\"descriptor\": $NEW_DESCRIPTOR}\' ```  In both these modes the URL of the descriptor cannot be changed. To change the descriptor location and upgrade an installation the request must be made exclusively with a `descriptor_url`.   ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{\"descriptor_url\": $NEW_URL}\' ```  The `descriptor_url` must exactly match the marketplace registration that Atlassian has for the application. Contact your Atlassian developer advocate to update this registration. Once the registration has been updated you may call this resource for each installation.  Note that the scopes of the application cannot be increased in the new descriptor nor reduced to none.
         * @summary Update an installed app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addonPut(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addonPut(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddonApi - interface
 */
export interface AddonApiInterface {
    /**
     * Deletes the application for the user.  This endpoint is intended to be used by Bitbucket Connect apps and only supports JWT authentication -- that is how Bitbucket identifies the particular installation of the app. Developers with applications registered in the \"Develop Apps\" section of Bitbucket Marketplace need not use this endpoint as updates for those applications can be sent out via the UI of that section.  ``` $ curl -X DELETE https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" ```
     * @summary Delete an app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addonDelete(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Gets a list of all [linkers](/cloud/bitbucket/modules/linker/) for the authenticated application.
     * @summary List linkers for an app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addonLinkersGet(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Gets a [linker](/cloud/bitbucket/modules/linker/) specified by `linker_key` for the authenticated application.
     * @summary Get a linker for an app
     * @param {AddonApiAddonLinkersLinkerKeyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addonLinkersLinkerKeyGet(requestParameters: AddonApiAddonLinkersLinkerKeyGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete all [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.
     * @summary Delete all linker values
     * @param {AddonApiAddonLinkersLinkerKeyValuesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addonLinkersLinkerKeyValuesDelete(requestParameters: AddonApiAddonLinkersLinkerKeyValuesDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Gets a list of all [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
     * @summary List linker values for a linker
     * @param {AddonApiAddonLinkersLinkerKeyValuesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addonLinkersLinkerKeyValuesGet(requestParameters: AddonApiAddonLinkersLinkerKeyValuesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Creates a [linker](/cloud/bitbucket/modules/linker/) value for the specified linker of authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
     * @summary Create a linker value
     * @param {AddonApiAddonLinkersLinkerKeyValuesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addonLinkersLinkerKeyValuesPost(requestParameters: AddonApiAddonLinkersLinkerKeyValuesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Bulk update [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
     * @summary Update a linker value
     * @param {AddonApiAddonLinkersLinkerKeyValuesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addonLinkersLinkerKeyValuesPut(requestParameters: AddonApiAddonLinkersLinkerKeyValuesPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete a single [linker](/cloud/bitbucket/modules/linker/) value of the authenticated application.
     * @summary Delete a linker value
     * @param {AddonApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addonLinkersLinkerKeyValuesValueIdDelete(requestParameters: AddonApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Get a single [linker](/cloud/bitbucket/modules/linker/) value of the authenticated application.
     * @summary Get a linker value
     * @param {AddonApiAddonLinkersLinkerKeyValuesValueIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addonLinkersLinkerKeyValuesValueIdGet(requestParameters: AddonApiAddonLinkersLinkerKeyValuesValueIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Updates the application installation for the user.  This endpoint is intended to be used by Bitbucket Connect apps and only supports JWT authentication -- that is how Bitbucket identifies the particular installation of the app. Developers with applications registered in the \"Develop Apps\" section of Bitbucket need not use this endpoint as updates for those applications can be sent out via the UI of that section.  Passing an empty body will update the installation using the existing descriptor URL.  ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{}\' ```  The new `descriptor` for the installation can be also provided in the body directly.  ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{\"descriptor\": $NEW_DESCRIPTOR}\' ```  In both these modes the URL of the descriptor cannot be changed. To change the descriptor location and upgrade an installation the request must be made exclusively with a `descriptor_url`.   ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{\"descriptor_url\": $NEW_URL}\' ```  The `descriptor_url` must exactly match the marketplace registration that Atlassian has for the application. Contact your Atlassian developer advocate to update this registration. Once the registration has been updated you may call this resource for each installation.  Note that the scopes of the application cannot be increased in the new descriptor nor reduced to none.
     * @summary Update an installed app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addonPut(options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for addonLinkersLinkerKeyGet operation in AddonApi.
 */
export interface AddonApiAddonLinkersLinkerKeyGetRequest {
    /**
     * The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
     */
    readonly linkerKey: string
}

/**
 * Request parameters for addonLinkersLinkerKeyValuesDelete operation in AddonApi.
 */
export interface AddonApiAddonLinkersLinkerKeyValuesDeleteRequest {
    /**
     * The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
     */
    readonly linkerKey: string
}

/**
 * Request parameters for addonLinkersLinkerKeyValuesGet operation in AddonApi.
 */
export interface AddonApiAddonLinkersLinkerKeyValuesGetRequest {
    /**
     * The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
     */
    readonly linkerKey: string
}

/**
 * Request parameters for addonLinkersLinkerKeyValuesPost operation in AddonApi.
 */
export interface AddonApiAddonLinkersLinkerKeyValuesPostRequest {
    /**
     * The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
     */
    readonly linkerKey: string
}

/**
 * Request parameters for addonLinkersLinkerKeyValuesPut operation in AddonApi.
 */
export interface AddonApiAddonLinkersLinkerKeyValuesPutRequest {
    /**
     * The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
     */
    readonly linkerKey: string
}

/**
 * Request parameters for addonLinkersLinkerKeyValuesValueIdDelete operation in AddonApi.
 */
export interface AddonApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest {
    /**
     * The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
     */
    readonly linkerKey: string

    /**
     * The numeric ID of the linker value.
     */
    readonly valueId: number
}

/**
 * Request parameters for addonLinkersLinkerKeyValuesValueIdGet operation in AddonApi.
 */
export interface AddonApiAddonLinkersLinkerKeyValuesValueIdGetRequest {
    /**
     * The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
     */
    readonly linkerKey: string

    /**
     * The numeric ID of the linker value.
     */
    readonly valueId: number
}

/**
 * AddonApi - object-oriented interface
 */
export class AddonApi extends BaseAPI implements AddonApiInterface {
    /**
     * Deletes the application for the user.  This endpoint is intended to be used by Bitbucket Connect apps and only supports JWT authentication -- that is how Bitbucket identifies the particular installation of the app. Developers with applications registered in the \"Develop Apps\" section of Bitbucket Marketplace need not use this endpoint as updates for those applications can be sent out via the UI of that section.  ``` $ curl -X DELETE https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" ```
     * @summary Delete an app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addonDelete(options?: RawAxiosRequestConfig) {
        return AddonApiFp(this.configuration).addonDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all [linkers](/cloud/bitbucket/modules/linker/) for the authenticated application.
     * @summary List linkers for an app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addonLinkersGet(options?: RawAxiosRequestConfig) {
        return AddonApiFp(this.configuration).addonLinkersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a [linker](/cloud/bitbucket/modules/linker/) specified by `linker_key` for the authenticated application.
     * @summary Get a linker for an app
     * @param {AddonApiAddonLinkersLinkerKeyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addonLinkersLinkerKeyGet(requestParameters: AddonApiAddonLinkersLinkerKeyGetRequest, options?: RawAxiosRequestConfig) {
        return AddonApiFp(this.configuration).addonLinkersLinkerKeyGet(requestParameters.linkerKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.
     * @summary Delete all linker values
     * @param {AddonApiAddonLinkersLinkerKeyValuesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addonLinkersLinkerKeyValuesDelete(requestParameters: AddonApiAddonLinkersLinkerKeyValuesDeleteRequest, options?: RawAxiosRequestConfig) {
        return AddonApiFp(this.configuration).addonLinkersLinkerKeyValuesDelete(requestParameters.linkerKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
     * @summary List linker values for a linker
     * @param {AddonApiAddonLinkersLinkerKeyValuesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addonLinkersLinkerKeyValuesGet(requestParameters: AddonApiAddonLinkersLinkerKeyValuesGetRequest, options?: RawAxiosRequestConfig) {
        return AddonApiFp(this.configuration).addonLinkersLinkerKeyValuesGet(requestParameters.linkerKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a [linker](/cloud/bitbucket/modules/linker/) value for the specified linker of authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
     * @summary Create a linker value
     * @param {AddonApiAddonLinkersLinkerKeyValuesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addonLinkersLinkerKeyValuesPost(requestParameters: AddonApiAddonLinkersLinkerKeyValuesPostRequest, options?: RawAxiosRequestConfig) {
        return AddonApiFp(this.configuration).addonLinkersLinkerKeyValuesPost(requestParameters.linkerKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk update [linker](/cloud/bitbucket/modules/linker/) values for the specified linker of the authenticated application.  A linker value lets applications supply values to modify its regular expression.  The base regular expression must use a Bitbucket-specific match group `(?K)` which will be translated to `([\\w\\-]+)`. A value must match this pattern.  [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
     * @summary Update a linker value
     * @param {AddonApiAddonLinkersLinkerKeyValuesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addonLinkersLinkerKeyValuesPut(requestParameters: AddonApiAddonLinkersLinkerKeyValuesPutRequest, options?: RawAxiosRequestConfig) {
        return AddonApiFp(this.configuration).addonLinkersLinkerKeyValuesPut(requestParameters.linkerKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a single [linker](/cloud/bitbucket/modules/linker/) value of the authenticated application.
     * @summary Delete a linker value
     * @param {AddonApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addonLinkersLinkerKeyValuesValueIdDelete(requestParameters: AddonApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return AddonApiFp(this.configuration).addonLinkersLinkerKeyValuesValueIdDelete(requestParameters.linkerKey, requestParameters.valueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single [linker](/cloud/bitbucket/modules/linker/) value of the authenticated application.
     * @summary Get a linker value
     * @param {AddonApiAddonLinkersLinkerKeyValuesValueIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addonLinkersLinkerKeyValuesValueIdGet(requestParameters: AddonApiAddonLinkersLinkerKeyValuesValueIdGetRequest, options?: RawAxiosRequestConfig) {
        return AddonApiFp(this.configuration).addonLinkersLinkerKeyValuesValueIdGet(requestParameters.linkerKey, requestParameters.valueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the application installation for the user.  This endpoint is intended to be used by Bitbucket Connect apps and only supports JWT authentication -- that is how Bitbucket identifies the particular installation of the app. Developers with applications registered in the \"Develop Apps\" section of Bitbucket need not use this endpoint as updates for those applications can be sent out via the UI of that section.  Passing an empty body will update the installation using the existing descriptor URL.  ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{}\' ```  The new `descriptor` for the installation can be also provided in the body directly.  ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{\"descriptor\": $NEW_DESCRIPTOR}\' ```  In both these modes the URL of the descriptor cannot be changed. To change the descriptor location and upgrade an installation the request must be made exclusively with a `descriptor_url`.   ``` $ curl -X PUT https://api.bitbucket.org/2.0/addon \\   -H \"Authorization: JWT <JWT Token>\" \\   --header \"Content-Type: application/json\" \\   --data \'{\"descriptor_url\": $NEW_URL}\' ```  The `descriptor_url` must exactly match the marketplace registration that Atlassian has for the application. Contact your Atlassian developer advocate to update this registration. Once the registration has been updated you may call this resource for each installation.  Note that the scopes of the application cannot be increased in the new descriptor nor reduced to none.
     * @summary Update an installed app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addonPut(options?: RawAxiosRequestConfig) {
        return AddonApiFp(this.configuration).addonPut(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BranchRestrictionsApi - axios parameter creator
 */
export const BranchRestrictionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a paginated list of all branch restrictions on the repository.
         * @summary List branch restrictions
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [kind] Branch restrictions of this type
         * @param {string} [pattern] Branch restrictions applied to branches of this pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchRestrictionsGet: async (repoSlug: string, workspace: string, kind?: string, pattern?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/branch-restrictions`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (pattern !== undefined) {
                localVarQueryParameter['pattern'] = pattern;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing branch restriction rule.
         * @summary Delete a branch restriction rule
         * @param {string} id The restriction rule\&#39;s id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete: async (id: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete', 'id', id)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/branch-restrictions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific branch restriction rule.
         * @summary Get a branch restriction rule
         * @param {string} id The restriction rule\&#39;s id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet: async (id: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet', 'id', id)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/branch-restrictions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing branch restriction rule.  Fields not present in the request body are ignored.  See [`POST`](/cloud/bitbucket/rest/api-group-branch-restrictions/#api-repositories-workspace-repo-slug-branch-restrictions-post) for details.
         * @summary Update a branch restriction rule
         * @param {string} id The restriction rule\&#39;s id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Branchrestriction} body The new version of the existing rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut: async (id: string, repoSlug: string, workspace: string, body: Branchrestriction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut', 'id', id)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/branch-restrictions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new branch restriction rule for a repository.  `kind` describes what will be restricted. Allowed values include: `push`, `force`, `delete`, `restrict_merges`, `require_tasks_to_be_completed`, `require_approvals_to_merge`, `require_default_reviewer_approvals_to_merge`, `require_no_changes_requested`, `require_passing_builds_to_merge`, `require_commits_behind`, `reset_pullrequest_approvals_on_change`, `smart_reset_pullrequest_approvals`, `reset_pullrequest_changes_requested_on_change`, `require_all_dependencies_merged`, `enforce_merge_checks`, and `allow_auto_merge_when_builds_pass`.  Different kinds of branch restrictions have different requirements:  * `push` and `restrict_merges` require `users` and `groups` to be   specified. Empty lists are allowed, in which case permission is   denied for everybody.  The restriction applies to all branches that match. There are two ways to match a branch. It is configured in `branch_match_kind`:  1. `glob`: Matches a branch against the `pattern`. A `\'*\'` in    `pattern` will expand to match zero or more characters, and every    other character matches itself. For example, `\'foo*\'` will match    `\'foo\'` and `\'foobar\'`, but not `\'barfoo\'`. `\'*\'` will match all    branches. 2. `branching_model`: Matches a branch against the repository\'s    branching model. The `branch_type` controls the type of branch    to match. Allowed values include: `production`, `development`,    `bugfix`, `release`, `feature` and `hotfix`.  The combination of `kind` and match must be unique. This means that two `glob` restrictions in a repository cannot have the same `kind` and `pattern`. Additionally, two `branching_model` restrictions in a repository cannot have the same `kind` and `branch_type`.  `users` and `groups` are lists of users and groups that are except from the restriction. They can only be configured in `push` and `restrict_merges` restrictions. The `push` restriction stops a user pushing to matching branches unless that user is in `users` or is a member of a group in `groups`. The `restrict_merges` stops a user merging pull requests to matching branches unless that user is in `users` or is a member of a group in `groups`. Adding new users or groups to an existing restriction should be done via `PUT`.  Note that branch restrictions with overlapping matchers is allowed, but the resulting behavior may be surprising.
         * @summary Create a branch restriction rule
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Branchrestriction} body The new rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchRestrictionsPost: async (repoSlug: string, workspace: string, body: Branchrestriction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsPost', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchRestrictionsPost', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/branch-restrictions`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BranchRestrictionsApi - functional programming interface
 */
export const BranchRestrictionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BranchRestrictionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a paginated list of all branch restrictions on the repository.
         * @summary List branch restrictions
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [kind] Branch restrictions of this type
         * @param {string} [pattern] Branch restrictions applied to branches of this pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugBranchRestrictionsGet(repoSlug: string, workspace: string, kind?: string, pattern?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBranchrestrictions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugBranchRestrictionsGet(repoSlug, workspace, kind, pattern, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchRestrictionsApi.repositoriesWorkspaceRepoSlugBranchRestrictionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an existing branch restriction rule.
         * @summary Delete a branch restriction rule
         * @param {string} id The restriction rule\&#39;s id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete(id: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete(id, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchRestrictionsApi.repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a specific branch restriction rule.
         * @summary Get a branch restriction rule
         * @param {string} id The restriction rule\&#39;s id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet(id: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branchrestriction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet(id, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchRestrictionsApi.repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing branch restriction rule.  Fields not present in the request body are ignored.  See [`POST`](/cloud/bitbucket/rest/api-group-branch-restrictions/#api-repositories-workspace-repo-slug-branch-restrictions-post) for details.
         * @summary Update a branch restriction rule
         * @param {string} id The restriction rule\&#39;s id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Branchrestriction} body The new version of the existing rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut(id: string, repoSlug: string, workspace: string, body: Branchrestriction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branchrestriction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut(id, repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchRestrictionsApi.repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new branch restriction rule for a repository.  `kind` describes what will be restricted. Allowed values include: `push`, `force`, `delete`, `restrict_merges`, `require_tasks_to_be_completed`, `require_approvals_to_merge`, `require_default_reviewer_approvals_to_merge`, `require_no_changes_requested`, `require_passing_builds_to_merge`, `require_commits_behind`, `reset_pullrequest_approvals_on_change`, `smart_reset_pullrequest_approvals`, `reset_pullrequest_changes_requested_on_change`, `require_all_dependencies_merged`, `enforce_merge_checks`, and `allow_auto_merge_when_builds_pass`.  Different kinds of branch restrictions have different requirements:  * `push` and `restrict_merges` require `users` and `groups` to be   specified. Empty lists are allowed, in which case permission is   denied for everybody.  The restriction applies to all branches that match. There are two ways to match a branch. It is configured in `branch_match_kind`:  1. `glob`: Matches a branch against the `pattern`. A `\'*\'` in    `pattern` will expand to match zero or more characters, and every    other character matches itself. For example, `\'foo*\'` will match    `\'foo\'` and `\'foobar\'`, but not `\'barfoo\'`. `\'*\'` will match all    branches. 2. `branching_model`: Matches a branch against the repository\'s    branching model. The `branch_type` controls the type of branch    to match. Allowed values include: `production`, `development`,    `bugfix`, `release`, `feature` and `hotfix`.  The combination of `kind` and match must be unique. This means that two `glob` restrictions in a repository cannot have the same `kind` and `pattern`. Additionally, two `branching_model` restrictions in a repository cannot have the same `kind` and `branch_type`.  `users` and `groups` are lists of users and groups that are except from the restriction. They can only be configured in `push` and `restrict_merges` restrictions. The `push` restriction stops a user pushing to matching branches unless that user is in `users` or is a member of a group in `groups`. The `restrict_merges` stops a user merging pull requests to matching branches unless that user is in `users` or is a member of a group in `groups`. Adding new users or groups to an existing restriction should be done via `PUT`.  Note that branch restrictions with overlapping matchers is allowed, but the resulting behavior may be surprising.
         * @summary Create a branch restriction rule
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Branchrestriction} body The new rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugBranchRestrictionsPost(repoSlug: string, workspace: string, body: Branchrestriction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branchrestriction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugBranchRestrictionsPost(repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchRestrictionsApi.repositoriesWorkspaceRepoSlugBranchRestrictionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BranchRestrictionsApi - factory interface
 */
export const BranchRestrictionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BranchRestrictionsApiFp(configuration)
    return {
        /**
         * Returns a paginated list of all branch restrictions on the repository.
         * @summary List branch restrictions
         * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchRestrictionsGet(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedBranchrestrictions> {
            return localVarFp.repositoriesWorkspaceRepoSlugBranchRestrictionsGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.kind, requestParameters.pattern, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing branch restriction rule.
         * @summary Delete a branch restriction rule
         * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete(requestParameters.id, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific branch restriction rule.
         * @summary Get a branch restriction rule
         * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Branchrestriction> {
            return localVarFp.repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet(requestParameters.id, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing branch restriction rule.  Fields not present in the request body are ignored.  See [`POST`](/cloud/bitbucket/rest/api-group-branch-restrictions/#api-repositories-workspace-repo-slug-branch-restrictions-post) for details.
         * @summary Update a branch restriction rule
         * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Branchrestriction> {
            return localVarFp.repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut(requestParameters.id, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new branch restriction rule for a repository.  `kind` describes what will be restricted. Allowed values include: `push`, `force`, `delete`, `restrict_merges`, `require_tasks_to_be_completed`, `require_approvals_to_merge`, `require_default_reviewer_approvals_to_merge`, `require_no_changes_requested`, `require_passing_builds_to_merge`, `require_commits_behind`, `reset_pullrequest_approvals_on_change`, `smart_reset_pullrequest_approvals`, `reset_pullrequest_changes_requested_on_change`, `require_all_dependencies_merged`, `enforce_merge_checks`, and `allow_auto_merge_when_builds_pass`.  Different kinds of branch restrictions have different requirements:  * `push` and `restrict_merges` require `users` and `groups` to be   specified. Empty lists are allowed, in which case permission is   denied for everybody.  The restriction applies to all branches that match. There are two ways to match a branch. It is configured in `branch_match_kind`:  1. `glob`: Matches a branch against the `pattern`. A `\'*\'` in    `pattern` will expand to match zero or more characters, and every    other character matches itself. For example, `\'foo*\'` will match    `\'foo\'` and `\'foobar\'`, but not `\'barfoo\'`. `\'*\'` will match all    branches. 2. `branching_model`: Matches a branch against the repository\'s    branching model. The `branch_type` controls the type of branch    to match. Allowed values include: `production`, `development`,    `bugfix`, `release`, `feature` and `hotfix`.  The combination of `kind` and match must be unique. This means that two `glob` restrictions in a repository cannot have the same `kind` and `pattern`. Additionally, two `branching_model` restrictions in a repository cannot have the same `kind` and `branch_type`.  `users` and `groups` are lists of users and groups that are except from the restriction. They can only be configured in `push` and `restrict_merges` restrictions. The `push` restriction stops a user pushing to matching branches unless that user is in `users` or is a member of a group in `groups`. The `restrict_merges` stops a user merging pull requests to matching branches unless that user is in `users` or is a member of a group in `groups`. Adding new users or groups to an existing restriction should be done via `PUT`.  Note that branch restrictions with overlapping matchers is allowed, but the resulting behavior may be surprising.
         * @summary Create a branch restriction rule
         * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchRestrictionsPost(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Branchrestriction> {
            return localVarFp.repositoriesWorkspaceRepoSlugBranchRestrictionsPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BranchRestrictionsApi - interface
 */
export interface BranchRestrictionsApiInterface {
    /**
     * Returns a paginated list of all branch restrictions on the repository.
     * @summary List branch restrictions
     * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugBranchRestrictionsGet(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedBranchrestrictions>;

    /**
     * Deletes an existing branch restriction rule.
     * @summary Delete a branch restriction rule
     * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a specific branch restriction rule.
     * @summary Get a branch restriction rule
     * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Branchrestriction>;

    /**
     * Updates an existing branch restriction rule.  Fields not present in the request body are ignored.  See [`POST`](/cloud/bitbucket/rest/api-group-branch-restrictions/#api-repositories-workspace-repo-slug-branch-restrictions-post) for details.
     * @summary Update a branch restriction rule
     * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Branchrestriction>;

    /**
     * Creates a new branch restriction rule for a repository.  `kind` describes what will be restricted. Allowed values include: `push`, `force`, `delete`, `restrict_merges`, `require_tasks_to_be_completed`, `require_approvals_to_merge`, `require_default_reviewer_approvals_to_merge`, `require_no_changes_requested`, `require_passing_builds_to_merge`, `require_commits_behind`, `reset_pullrequest_approvals_on_change`, `smart_reset_pullrequest_approvals`, `reset_pullrequest_changes_requested_on_change`, `require_all_dependencies_merged`, `enforce_merge_checks`, and `allow_auto_merge_when_builds_pass`.  Different kinds of branch restrictions have different requirements:  * `push` and `restrict_merges` require `users` and `groups` to be   specified. Empty lists are allowed, in which case permission is   denied for everybody.  The restriction applies to all branches that match. There are two ways to match a branch. It is configured in `branch_match_kind`:  1. `glob`: Matches a branch against the `pattern`. A `\'*\'` in    `pattern` will expand to match zero or more characters, and every    other character matches itself. For example, `\'foo*\'` will match    `\'foo\'` and `\'foobar\'`, but not `\'barfoo\'`. `\'*\'` will match all    branches. 2. `branching_model`: Matches a branch against the repository\'s    branching model. The `branch_type` controls the type of branch    to match. Allowed values include: `production`, `development`,    `bugfix`, `release`, `feature` and `hotfix`.  The combination of `kind` and match must be unique. This means that two `glob` restrictions in a repository cannot have the same `kind` and `pattern`. Additionally, two `branching_model` restrictions in a repository cannot have the same `kind` and `branch_type`.  `users` and `groups` are lists of users and groups that are except from the restriction. They can only be configured in `push` and `restrict_merges` restrictions. The `push` restriction stops a user pushing to matching branches unless that user is in `users` or is a member of a group in `groups`. The `restrict_merges` stops a user merging pull requests to matching branches unless that user is in `users` or is a member of a group in `groups`. Adding new users or groups to an existing restriction should be done via `PUT`.  Note that branch restrictions with overlapping matchers is allowed, but the resulting behavior may be surprising.
     * @summary Create a branch restriction rule
     * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugBranchRestrictionsPost(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Branchrestriction>;

}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugBranchRestrictionsGet operation in BranchRestrictionsApi.
 */
export interface BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * Branch restrictions of this type
     */
    readonly kind?: string

    /**
     * Branch restrictions applied to branches of this pattern
     */
    readonly pattern?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete operation in BranchRestrictionsApi.
 */
export interface BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdDeleteRequest {
    /**
     * The restriction rule\&#39;s id
     */
    readonly id: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet operation in BranchRestrictionsApi.
 */
export interface BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdGetRequest {
    /**
     * The restriction rule\&#39;s id
     */
    readonly id: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut operation in BranchRestrictionsApi.
 */
export interface BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdPutRequest {
    /**
     * The restriction rule\&#39;s id
     */
    readonly id: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The new version of the existing rule
     */
    readonly body: Branchrestriction
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugBranchRestrictionsPost operation in BranchRestrictionsApi.
 */
export interface BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The new rule
     */
    readonly body: Branchrestriction
}

/**
 * BranchRestrictionsApi - object-oriented interface
 */
export class BranchRestrictionsApi extends BaseAPI implements BranchRestrictionsApiInterface {
    /**
     * Returns a paginated list of all branch restrictions on the repository.
     * @summary List branch restrictions
     * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugBranchRestrictionsGet(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsGetRequest, options?: RawAxiosRequestConfig) {
        return BranchRestrictionsApiFp(this.configuration).repositoriesWorkspaceRepoSlugBranchRestrictionsGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.kind, requestParameters.pattern, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing branch restriction rule.
     * @summary Delete a branch restriction rule
     * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return BranchRestrictionsApiFp(this.configuration).repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete(requestParameters.id, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific branch restriction rule.
     * @summary Get a branch restriction rule
     * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdGetRequest, options?: RawAxiosRequestConfig) {
        return BranchRestrictionsApiFp(this.configuration).repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet(requestParameters.id, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing branch restriction rule.  Fields not present in the request body are ignored.  See [`POST`](/cloud/bitbucket/rest/api-group-branch-restrictions/#api-repositories-workspace-repo-slug-branch-restrictions-post) for details.
     * @summary Update a branch restriction rule
     * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsIdPutRequest, options?: RawAxiosRequestConfig) {
        return BranchRestrictionsApiFp(this.configuration).repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut(requestParameters.id, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new branch restriction rule for a repository.  `kind` describes what will be restricted. Allowed values include: `push`, `force`, `delete`, `restrict_merges`, `require_tasks_to_be_completed`, `require_approvals_to_merge`, `require_default_reviewer_approvals_to_merge`, `require_no_changes_requested`, `require_passing_builds_to_merge`, `require_commits_behind`, `reset_pullrequest_approvals_on_change`, `smart_reset_pullrequest_approvals`, `reset_pullrequest_changes_requested_on_change`, `require_all_dependencies_merged`, `enforce_merge_checks`, and `allow_auto_merge_when_builds_pass`.  Different kinds of branch restrictions have different requirements:  * `push` and `restrict_merges` require `users` and `groups` to be   specified. Empty lists are allowed, in which case permission is   denied for everybody.  The restriction applies to all branches that match. There are two ways to match a branch. It is configured in `branch_match_kind`:  1. `glob`: Matches a branch against the `pattern`. A `\'*\'` in    `pattern` will expand to match zero or more characters, and every    other character matches itself. For example, `\'foo*\'` will match    `\'foo\'` and `\'foobar\'`, but not `\'barfoo\'`. `\'*\'` will match all    branches. 2. `branching_model`: Matches a branch against the repository\'s    branching model. The `branch_type` controls the type of branch    to match. Allowed values include: `production`, `development`,    `bugfix`, `release`, `feature` and `hotfix`.  The combination of `kind` and match must be unique. This means that two `glob` restrictions in a repository cannot have the same `kind` and `pattern`. Additionally, two `branching_model` restrictions in a repository cannot have the same `kind` and `branch_type`.  `users` and `groups` are lists of users and groups that are except from the restriction. They can only be configured in `push` and `restrict_merges` restrictions. The `push` restriction stops a user pushing to matching branches unless that user is in `users` or is a member of a group in `groups`. The `restrict_merges` stops a user merging pull requests to matching branches unless that user is in `users` or is a member of a group in `groups`. Adding new users or groups to an existing restriction should be done via `PUT`.  Note that branch restrictions with overlapping matchers is allowed, but the resulting behavior may be surprising.
     * @summary Create a branch restriction rule
     * @param {BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugBranchRestrictionsPost(requestParameters: BranchRestrictionsApiRepositoriesWorkspaceRepoSlugBranchRestrictionsPostRequest, options?: RawAxiosRequestConfig) {
        return BranchRestrictionsApiFp(this.configuration).repositoriesWorkspaceRepoSlugBranchRestrictionsPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BranchingModelApi - axios parameter creator
 */
export const BranchingModelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the branching model as applied to the repository. This view is read-only. The branching model settings can be changed using the [settings](#api-repositories-workspace-repo-slug-branching-model-settings-get) API.  The returned object:  1. Always has a `development` property. `development.branch` contains    the actual repository branch object that is considered to be the    `development` branch. `development.branch` will not be present    if it does not exist. 2. Might have a `production` property. `production` will not    be present when `production` is disabled.    `production.branch` contains the actual branch object that is    considered to be the `production` branch. `production.branch` will    not be present if it does not exist. 3. Always has a `branch_types` array which contains all enabled branch    types.
         * @summary Get the branching model for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchingModelGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchingModelGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchingModelGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/branching-model`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the branching model configuration for a repository. The returned object:  1. Always has a `development` property for the development branch. 2. Always a `production` property for the production branch. The    production branch can be disabled. 3. The `branch_types` contains all the branch types. 4. `default_branch_deletion` indicates whether branches will be     deleted by default on merge.  This is the raw configuration for the branching model. A client wishing to see the branching model with its actual current branches may find the [active model API](/cloud/bitbucket/rest/api-group-branching-model/#api-repositories-workspace-repo-slug-branching-model-get) more useful.
         * @summary Get the branching model config for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchingModelSettingsGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchingModelSettingsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchingModelSettingsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/branching-model/settings`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the branching model configuration for a repository.  The `development` branch can be configured to a specific branch or to track the main branch. When set to a specific branch it must currently exist. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `development` property will leave the development branch unchanged.  It is possible for the `development` branch to be invalid. This happens when it points at a specific branch that has been deleted. This is indicated in the `is_valid` field for the branch. It is not possible to update the settings for `development` if that would leave the branch in an invalid state. Such a request will be rejected.  The `production` branch can be a specific branch, the main branch or disabled. When set to a specific branch it must currently exist. The `enabled` property can be used to enable (`true`) or disable (`false`) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `production` property will leave the production branch unchanged.  It is possible for the `production` branch to be invalid. This happens when it points at a specific branch that has been deleted. This is indicated in the `is_valid` field for the branch. A request that would leave `production` enabled and invalid will be rejected. It is possible to update `production` and make it invalid if it would also be left disabled.  The `branch_types` property contains the branch types to be updated. Only the branch types passed will be updated. All updates will be rejected if it would leave the branching model in an invalid state. For branch types this means that:  1. The prefixes for all enabled branch types are valid. For example,    it is not possible to use \'*\' inside a Git prefix. 2. A prefix of an enabled branch type must not be a prefix of another    enabled branch type. This is to ensure that a branch can be easily    classified by its prefix unambiguously.  It is possible to store an invalid prefix if that branch type would be left disabled. Only the passed properties will be updated. The properties not passed will be left unchanged. Each branch type must have a `kind` property to identify it.  The `default_branch_deletion` property is a string. The value of `true` indicates to delete branches by default. The value of `false` indicates that branches will not be deleted by default. A request without a `default_branch_deletion` property will leave it unchanged. Other values would be ignored.  There is currently a side effect when using this API endpoint. If the repository is inheriting branching model settings from its project, updating the branching model for this repository will disable the project setting inheritance.   We have deprecated this side effect and will remove it on 1 August 2022.
         * @summary Update the branching model config for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchingModelSettingsPut: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchingModelSettingsPut', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugBranchingModelSettingsPut', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/branching-model/settings`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the effective, or currently applied, branching model for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugEffectiveBranchingModelGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugEffectiveBranchingModelGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugEffectiveBranchingModelGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/effective-branching-model`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the branching model set at the project level. This view is read-only. The branching model settings can be changed using the [settings](#api-workspaces-workspace-projects-project-key-branching-model-settings-get) API.  The returned object:  1. Always has a `development` property. `development.name` is    the user-specified branch that can be inherited by an individual repository\'s    branching model. 2. Might have a `production` property. `production` will not    be present when `production` is disabled.    `production.name` is the user-specified branch that can be    inherited by an individual repository\'s branching model. 3. Always has a `branch_types` array which contains all enabled branch    types.
         * @summary Get the branching model for a project
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyBranchingModelGet: async (projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyBranchingModelGet', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyBranchingModelGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/branching-model`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the branching model configuration for a project. The returned object:  1. Always has a `development` property for the development branch. 2. Always a `production` property for the production branch. The    production branch can be disabled. 3. The `branch_types` contains all the branch types. 4. `default_branch_deletion` indicates whether branches will be     deleted by default on merge.   This is the raw configuration for the branching model. A client wishing to see the branching model with its actual current branches may find the [active model API](#api-workspaces-workspace-projects-project-key-branching-model-get) more useful.
         * @summary Get the branching model config for a project
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGet: async (projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGet', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/branching-model/settings`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the branching model configuration for a project.  The `development` branch can be configured to a specific branch or to track the main branch. Any branch name can be supplied, but will only successfully be applied to a repository via inheritance if that branch exists for that repository. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `development` property will leave the development branch unchanged.  The `production` branch can be a specific branch, the main branch or disabled. Any branch name can be supplied, but will only successfully be applied to a repository via inheritance if that branch exists for that repository. The `enabled` property can be used to enable (`true`) or disable (`false`) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `production` property will leave the production branch unchanged.  The `branch_types` property contains the branch types to be updated. Only the branch types passed will be updated. All updates will be rejected if it would leave the branching model in an invalid state. For branch types this means that:  1. The prefixes for all enabled branch types are valid. For example,    it is not possible to use \'*\' inside a Git prefix. 2. A prefix of an enabled branch type must not be a prefix of another    enabled branch type. This is to ensure that a branch can be easily    classified by its prefix unambiguously.  It is possible to store an invalid prefix if that branch type would be left disabled. Only the passed properties will be updated. The properties not passed will be left unchanged. Each branch type must have a `kind` property to identify it.  The `default_branch_deletion` property is a string. The value of `true` indicates to delete branches by default. The value of `false` indicates that branches will not be deleted by default. A request without a `default_branch_deletion` property will leave it unchanged. Other values would be ignored.
         * @summary Update the branching model config for a project
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPut: async (projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPut', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPut', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/branching-model/settings`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BranchingModelApi - functional programming interface
 */
export const BranchingModelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BranchingModelApiAxiosParamCreator(configuration)
    return {
        /**
         * Return the branching model as applied to the repository. This view is read-only. The branching model settings can be changed using the [settings](#api-repositories-workspace-repo-slug-branching-model-settings-get) API.  The returned object:  1. Always has a `development` property. `development.branch` contains    the actual repository branch object that is considered to be the    `development` branch. `development.branch` will not be present    if it does not exist. 2. Might have a `production` property. `production` will not    be present when `production` is disabled.    `production.branch` contains the actual branch object that is    considered to be the `production` branch. `production.branch` will    not be present if it does not exist. 3. Always has a `branch_types` array which contains all enabled branch    types.
         * @summary Get the branching model for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugBranchingModelGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchingModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugBranchingModelGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchingModelApi.repositoriesWorkspaceRepoSlugBranchingModelGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the branching model configuration for a repository. The returned object:  1. Always has a `development` property for the development branch. 2. Always a `production` property for the production branch. The    production branch can be disabled. 3. The `branch_types` contains all the branch types. 4. `default_branch_deletion` indicates whether branches will be     deleted by default on merge.  This is the raw configuration for the branching model. A client wishing to see the branching model with its actual current branches may find the [active model API](/cloud/bitbucket/rest/api-group-branching-model/#api-repositories-workspace-repo-slug-branching-model-get) more useful.
         * @summary Get the branching model config for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugBranchingModelSettingsGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchingModelSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugBranchingModelSettingsGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchingModelApi.repositoriesWorkspaceRepoSlugBranchingModelSettingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the branching model configuration for a repository.  The `development` branch can be configured to a specific branch or to track the main branch. When set to a specific branch it must currently exist. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `development` property will leave the development branch unchanged.  It is possible for the `development` branch to be invalid. This happens when it points at a specific branch that has been deleted. This is indicated in the `is_valid` field for the branch. It is not possible to update the settings for `development` if that would leave the branch in an invalid state. Such a request will be rejected.  The `production` branch can be a specific branch, the main branch or disabled. When set to a specific branch it must currently exist. The `enabled` property can be used to enable (`true`) or disable (`false`) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `production` property will leave the production branch unchanged.  It is possible for the `production` branch to be invalid. This happens when it points at a specific branch that has been deleted. This is indicated in the `is_valid` field for the branch. A request that would leave `production` enabled and invalid will be rejected. It is possible to update `production` and make it invalid if it would also be left disabled.  The `branch_types` property contains the branch types to be updated. Only the branch types passed will be updated. All updates will be rejected if it would leave the branching model in an invalid state. For branch types this means that:  1. The prefixes for all enabled branch types are valid. For example,    it is not possible to use \'*\' inside a Git prefix. 2. A prefix of an enabled branch type must not be a prefix of another    enabled branch type. This is to ensure that a branch can be easily    classified by its prefix unambiguously.  It is possible to store an invalid prefix if that branch type would be left disabled. Only the passed properties will be updated. The properties not passed will be left unchanged. Each branch type must have a `kind` property to identify it.  The `default_branch_deletion` property is a string. The value of `true` indicates to delete branches by default. The value of `false` indicates that branches will not be deleted by default. A request without a `default_branch_deletion` property will leave it unchanged. Other values would be ignored.  There is currently a side effect when using this API endpoint. If the repository is inheriting branching model settings from its project, updating the branching model for this repository will disable the project setting inheritance.   We have deprecated this side effect and will remove it on 1 August 2022.
         * @summary Update the branching model config for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugBranchingModelSettingsPut(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchingModelSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugBranchingModelSettingsPut(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchingModelApi.repositoriesWorkspaceRepoSlugBranchingModelSettingsPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the effective, or currently applied, branching model for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugEffectiveBranchingModelGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EffectiveRepoBranchingModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugEffectiveBranchingModelGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchingModelApi.repositoriesWorkspaceRepoSlugEffectiveBranchingModelGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the branching model set at the project level. This view is read-only. The branching model settings can be changed using the [settings](#api-workspaces-workspace-projects-project-key-branching-model-settings-get) API.  The returned object:  1. Always has a `development` property. `development.name` is    the user-specified branch that can be inherited by an individual repository\'s    branching model. 2. Might have a `production` property. `production` will not    be present when `production` is disabled.    `production.name` is the user-specified branch that can be    inherited by an individual repository\'s branching model. 3. Always has a `branch_types` array which contains all enabled branch    types.
         * @summary Get the branching model for a project
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyBranchingModelGet(projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectBranchingModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyBranchingModelGet(projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchingModelApi.workspacesWorkspaceProjectsProjectKeyBranchingModelGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the branching model configuration for a project. The returned object:  1. Always has a `development` property for the development branch. 2. Always a `production` property for the production branch. The    production branch can be disabled. 3. The `branch_types` contains all the branch types. 4. `default_branch_deletion` indicates whether branches will be     deleted by default on merge.   This is the raw configuration for the branching model. A client wishing to see the branching model with its actual current branches may find the [active model API](#api-workspaces-workspace-projects-project-key-branching-model-get) more useful.
         * @summary Get the branching model config for a project
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGet(projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchingModelSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGet(projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchingModelApi.workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the branching model configuration for a project.  The `development` branch can be configured to a specific branch or to track the main branch. Any branch name can be supplied, but will only successfully be applied to a repository via inheritance if that branch exists for that repository. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `development` property will leave the development branch unchanged.  The `production` branch can be a specific branch, the main branch or disabled. Any branch name can be supplied, but will only successfully be applied to a repository via inheritance if that branch exists for that repository. The `enabled` property can be used to enable (`true`) or disable (`false`) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `production` property will leave the production branch unchanged.  The `branch_types` property contains the branch types to be updated. Only the branch types passed will be updated. All updates will be rejected if it would leave the branching model in an invalid state. For branch types this means that:  1. The prefixes for all enabled branch types are valid. For example,    it is not possible to use \'*\' inside a Git prefix. 2. A prefix of an enabled branch type must not be a prefix of another    enabled branch type. This is to ensure that a branch can be easily    classified by its prefix unambiguously.  It is possible to store an invalid prefix if that branch type would be left disabled. Only the passed properties will be updated. The properties not passed will be left unchanged. Each branch type must have a `kind` property to identify it.  The `default_branch_deletion` property is a string. The value of `true` indicates to delete branches by default. The value of `false` indicates that branches will not be deleted by default. A request without a `default_branch_deletion` property will leave it unchanged. Other values would be ignored.
         * @summary Update the branching model config for a project
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPut(projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchingModelSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPut(projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchingModelApi.workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BranchingModelApi - factory interface
 */
export const BranchingModelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BranchingModelApiFp(configuration)
    return {
        /**
         * Return the branching model as applied to the repository. This view is read-only. The branching model settings can be changed using the [settings](#api-repositories-workspace-repo-slug-branching-model-settings-get) API.  The returned object:  1. Always has a `development` property. `development.branch` contains    the actual repository branch object that is considered to be the    `development` branch. `development.branch` will not be present    if it does not exist. 2. Might have a `production` property. `production` will not    be present when `production` is disabled.    `production.branch` contains the actual branch object that is    considered to be the `production` branch. `production.branch` will    not be present if it does not exist. 3. Always has a `branch_types` array which contains all enabled branch    types.
         * @summary Get the branching model for a repository
         * @param {BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchingModelGet(requestParameters: BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<BranchingModel> {
            return localVarFp.repositoriesWorkspaceRepoSlugBranchingModelGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the branching model configuration for a repository. The returned object:  1. Always has a `development` property for the development branch. 2. Always a `production` property for the production branch. The    production branch can be disabled. 3. The `branch_types` contains all the branch types. 4. `default_branch_deletion` indicates whether branches will be     deleted by default on merge.  This is the raw configuration for the branching model. A client wishing to see the branching model with its actual current branches may find the [active model API](/cloud/bitbucket/rest/api-group-branching-model/#api-repositories-workspace-repo-slug-branching-model-get) more useful.
         * @summary Get the branching model config for a repository
         * @param {BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelSettingsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchingModelSettingsGet(requestParameters: BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelSettingsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<BranchingModelSettings> {
            return localVarFp.repositoriesWorkspaceRepoSlugBranchingModelSettingsGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the branching model configuration for a repository.  The `development` branch can be configured to a specific branch or to track the main branch. When set to a specific branch it must currently exist. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `development` property will leave the development branch unchanged.  It is possible for the `development` branch to be invalid. This happens when it points at a specific branch that has been deleted. This is indicated in the `is_valid` field for the branch. It is not possible to update the settings for `development` if that would leave the branch in an invalid state. Such a request will be rejected.  The `production` branch can be a specific branch, the main branch or disabled. When set to a specific branch it must currently exist. The `enabled` property can be used to enable (`true`) or disable (`false`) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `production` property will leave the production branch unchanged.  It is possible for the `production` branch to be invalid. This happens when it points at a specific branch that has been deleted. This is indicated in the `is_valid` field for the branch. A request that would leave `production` enabled and invalid will be rejected. It is possible to update `production` and make it invalid if it would also be left disabled.  The `branch_types` property contains the branch types to be updated. Only the branch types passed will be updated. All updates will be rejected if it would leave the branching model in an invalid state. For branch types this means that:  1. The prefixes for all enabled branch types are valid. For example,    it is not possible to use \'*\' inside a Git prefix. 2. A prefix of an enabled branch type must not be a prefix of another    enabled branch type. This is to ensure that a branch can be easily    classified by its prefix unambiguously.  It is possible to store an invalid prefix if that branch type would be left disabled. Only the passed properties will be updated. The properties not passed will be left unchanged. Each branch type must have a `kind` property to identify it.  The `default_branch_deletion` property is a string. The value of `true` indicates to delete branches by default. The value of `false` indicates that branches will not be deleted by default. A request without a `default_branch_deletion` property will leave it unchanged. Other values would be ignored.  There is currently a side effect when using this API endpoint. If the repository is inheriting branching model settings from its project, updating the branching model for this repository will disable the project setting inheritance.   We have deprecated this side effect and will remove it on 1 August 2022.
         * @summary Update the branching model config for a repository
         * @param {BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelSettingsPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugBranchingModelSettingsPut(requestParameters: BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelSettingsPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<BranchingModelSettings> {
            return localVarFp.repositoriesWorkspaceRepoSlugBranchingModelSettingsPut(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the effective, or currently applied, branching model for a repository
         * @param {BranchingModelApiRepositoriesWorkspaceRepoSlugEffectiveBranchingModelGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugEffectiveBranchingModelGet(requestParameters: BranchingModelApiRepositoriesWorkspaceRepoSlugEffectiveBranchingModelGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<EffectiveRepoBranchingModel> {
            return localVarFp.repositoriesWorkspaceRepoSlugEffectiveBranchingModelGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the branching model set at the project level. This view is read-only. The branching model settings can be changed using the [settings](#api-workspaces-workspace-projects-project-key-branching-model-settings-get) API.  The returned object:  1. Always has a `development` property. `development.name` is    the user-specified branch that can be inherited by an individual repository\'s    branching model. 2. Might have a `production` property. `production` will not    be present when `production` is disabled.    `production.name` is the user-specified branch that can be    inherited by an individual repository\'s branching model. 3. Always has a `branch_types` array which contains all enabled branch    types.
         * @summary Get the branching model for a project
         * @param {BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyBranchingModelGet(requestParameters: BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectBranchingModel> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyBranchingModelGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the branching model configuration for a project. The returned object:  1. Always has a `development` property for the development branch. 2. Always a `production` property for the production branch. The    production branch can be disabled. 3. The `branch_types` contains all the branch types. 4. `default_branch_deletion` indicates whether branches will be     deleted by default on merge.   This is the raw configuration for the branching model. A client wishing to see the branching model with its actual current branches may find the [active model API](#api-workspaces-workspace-projects-project-key-branching-model-get) more useful.
         * @summary Get the branching model config for a project
         * @param {BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGet(requestParameters: BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<BranchingModelSettings> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the branching model configuration for a project.  The `development` branch can be configured to a specific branch or to track the main branch. Any branch name can be supplied, but will only successfully be applied to a repository via inheritance if that branch exists for that repository. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `development` property will leave the development branch unchanged.  The `production` branch can be a specific branch, the main branch or disabled. Any branch name can be supplied, but will only successfully be applied to a repository via inheritance if that branch exists for that repository. The `enabled` property can be used to enable (`true`) or disable (`false`) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `production` property will leave the production branch unchanged.  The `branch_types` property contains the branch types to be updated. Only the branch types passed will be updated. All updates will be rejected if it would leave the branching model in an invalid state. For branch types this means that:  1. The prefixes for all enabled branch types are valid. For example,    it is not possible to use \'*\' inside a Git prefix. 2. A prefix of an enabled branch type must not be a prefix of another    enabled branch type. This is to ensure that a branch can be easily    classified by its prefix unambiguously.  It is possible to store an invalid prefix if that branch type would be left disabled. Only the passed properties will be updated. The properties not passed will be left unchanged. Each branch type must have a `kind` property to identify it.  The `default_branch_deletion` property is a string. The value of `true` indicates to delete branches by default. The value of `false` indicates that branches will not be deleted by default. A request without a `default_branch_deletion` property will leave it unchanged. Other values would be ignored.
         * @summary Update the branching model config for a project
         * @param {BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPut(requestParameters: BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<BranchingModelSettings> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPut(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BranchingModelApi - interface
 */
export interface BranchingModelApiInterface {
    /**
     * Return the branching model as applied to the repository. This view is read-only. The branching model settings can be changed using the [settings](#api-repositories-workspace-repo-slug-branching-model-settings-get) API.  The returned object:  1. Always has a `development` property. `development.branch` contains    the actual repository branch object that is considered to be the    `development` branch. `development.branch` will not be present    if it does not exist. 2. Might have a `production` property. `production` will not    be present when `production` is disabled.    `production.branch` contains the actual branch object that is    considered to be the `production` branch. `production.branch` will    not be present if it does not exist. 3. Always has a `branch_types` array which contains all enabled branch    types.
     * @summary Get the branching model for a repository
     * @param {BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugBranchingModelGet(requestParameters: BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<BranchingModel>;

    /**
     * Return the branching model configuration for a repository. The returned object:  1. Always has a `development` property for the development branch. 2. Always a `production` property for the production branch. The    production branch can be disabled. 3. The `branch_types` contains all the branch types. 4. `default_branch_deletion` indicates whether branches will be     deleted by default on merge.  This is the raw configuration for the branching model. A client wishing to see the branching model with its actual current branches may find the [active model API](/cloud/bitbucket/rest/api-group-branching-model/#api-repositories-workspace-repo-slug-branching-model-get) more useful.
     * @summary Get the branching model config for a repository
     * @param {BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelSettingsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugBranchingModelSettingsGet(requestParameters: BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelSettingsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<BranchingModelSettings>;

    /**
     * Update the branching model configuration for a repository.  The `development` branch can be configured to a specific branch or to track the main branch. When set to a specific branch it must currently exist. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `development` property will leave the development branch unchanged.  It is possible for the `development` branch to be invalid. This happens when it points at a specific branch that has been deleted. This is indicated in the `is_valid` field for the branch. It is not possible to update the settings for `development` if that would leave the branch in an invalid state. Such a request will be rejected.  The `production` branch can be a specific branch, the main branch or disabled. When set to a specific branch it must currently exist. The `enabled` property can be used to enable (`true`) or disable (`false`) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `production` property will leave the production branch unchanged.  It is possible for the `production` branch to be invalid. This happens when it points at a specific branch that has been deleted. This is indicated in the `is_valid` field for the branch. A request that would leave `production` enabled and invalid will be rejected. It is possible to update `production` and make it invalid if it would also be left disabled.  The `branch_types` property contains the branch types to be updated. Only the branch types passed will be updated. All updates will be rejected if it would leave the branching model in an invalid state. For branch types this means that:  1. The prefixes for all enabled branch types are valid. For example,    it is not possible to use \'*\' inside a Git prefix. 2. A prefix of an enabled branch type must not be a prefix of another    enabled branch type. This is to ensure that a branch can be easily    classified by its prefix unambiguously.  It is possible to store an invalid prefix if that branch type would be left disabled. Only the passed properties will be updated. The properties not passed will be left unchanged. Each branch type must have a `kind` property to identify it.  The `default_branch_deletion` property is a string. The value of `true` indicates to delete branches by default. The value of `false` indicates that branches will not be deleted by default. A request without a `default_branch_deletion` property will leave it unchanged. Other values would be ignored.  There is currently a side effect when using this API endpoint. If the repository is inheriting branching model settings from its project, updating the branching model for this repository will disable the project setting inheritance.   We have deprecated this side effect and will remove it on 1 August 2022.
     * @summary Update the branching model config for a repository
     * @param {BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelSettingsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugBranchingModelSettingsPut(requestParameters: BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelSettingsPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<BranchingModelSettings>;

    /**
     * 
     * @summary Get the effective, or currently applied, branching model for a repository
     * @param {BranchingModelApiRepositoriesWorkspaceRepoSlugEffectiveBranchingModelGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugEffectiveBranchingModelGet(requestParameters: BranchingModelApiRepositoriesWorkspaceRepoSlugEffectiveBranchingModelGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<EffectiveRepoBranchingModel>;

    /**
     * Return the branching model set at the project level. This view is read-only. The branching model settings can be changed using the [settings](#api-workspaces-workspace-projects-project-key-branching-model-settings-get) API.  The returned object:  1. Always has a `development` property. `development.name` is    the user-specified branch that can be inherited by an individual repository\'s    branching model. 2. Might have a `production` property. `production` will not    be present when `production` is disabled.    `production.name` is the user-specified branch that can be    inherited by an individual repository\'s branching model. 3. Always has a `branch_types` array which contains all enabled branch    types.
     * @summary Get the branching model for a project
     * @param {BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyBranchingModelGet(requestParameters: BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectBranchingModel>;

    /**
     * Return the branching model configuration for a project. The returned object:  1. Always has a `development` property for the development branch. 2. Always a `production` property for the production branch. The    production branch can be disabled. 3. The `branch_types` contains all the branch types. 4. `default_branch_deletion` indicates whether branches will be     deleted by default on merge.   This is the raw configuration for the branching model. A client wishing to see the branching model with its actual current branches may find the [active model API](#api-workspaces-workspace-projects-project-key-branching-model-get) more useful.
     * @summary Get the branching model config for a project
     * @param {BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGet(requestParameters: BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<BranchingModelSettings>;

    /**
     * Update the branching model configuration for a project.  The `development` branch can be configured to a specific branch or to track the main branch. Any branch name can be supplied, but will only successfully be applied to a repository via inheritance if that branch exists for that repository. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `development` property will leave the development branch unchanged.  The `production` branch can be a specific branch, the main branch or disabled. Any branch name can be supplied, but will only successfully be applied to a repository via inheritance if that branch exists for that repository. The `enabled` property can be used to enable (`true`) or disable (`false`) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `production` property will leave the production branch unchanged.  The `branch_types` property contains the branch types to be updated. Only the branch types passed will be updated. All updates will be rejected if it would leave the branching model in an invalid state. For branch types this means that:  1. The prefixes for all enabled branch types are valid. For example,    it is not possible to use \'*\' inside a Git prefix. 2. A prefix of an enabled branch type must not be a prefix of another    enabled branch type. This is to ensure that a branch can be easily    classified by its prefix unambiguously.  It is possible to store an invalid prefix if that branch type would be left disabled. Only the passed properties will be updated. The properties not passed will be left unchanged. Each branch type must have a `kind` property to identify it.  The `default_branch_deletion` property is a string. The value of `true` indicates to delete branches by default. The value of `false` indicates that branches will not be deleted by default. A request without a `default_branch_deletion` property will leave it unchanged. Other values would be ignored.
     * @summary Update the branching model config for a project
     * @param {BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPut(requestParameters: BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<BranchingModelSettings>;

}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugBranchingModelGet operation in BranchingModelApi.
 */
export interface BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugBranchingModelSettingsGet operation in BranchingModelApi.
 */
export interface BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelSettingsGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugBranchingModelSettingsPut operation in BranchingModelApi.
 */
export interface BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelSettingsPutRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugEffectiveBranchingModelGet operation in BranchingModelApi.
 */
export interface BranchingModelApiRepositoriesWorkspaceRepoSlugEffectiveBranchingModelGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyBranchingModelGet operation in BranchingModelApi.
 */
export interface BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelGetRequest {
    /**
     * The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGet operation in BranchingModelApi.
 */
export interface BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGetRequest {
    /**
     * The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPut operation in BranchingModelApi.
 */
export interface BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPutRequest {
    /**
     * The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * BranchingModelApi - object-oriented interface
 */
export class BranchingModelApi extends BaseAPI implements BranchingModelApiInterface {
    /**
     * Return the branching model as applied to the repository. This view is read-only. The branching model settings can be changed using the [settings](#api-repositories-workspace-repo-slug-branching-model-settings-get) API.  The returned object:  1. Always has a `development` property. `development.branch` contains    the actual repository branch object that is considered to be the    `development` branch. `development.branch` will not be present    if it does not exist. 2. Might have a `production` property. `production` will not    be present when `production` is disabled.    `production.branch` contains the actual branch object that is    considered to be the `production` branch. `production.branch` will    not be present if it does not exist. 3. Always has a `branch_types` array which contains all enabled branch    types.
     * @summary Get the branching model for a repository
     * @param {BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugBranchingModelGet(requestParameters: BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelGetRequest, options?: RawAxiosRequestConfig) {
        return BranchingModelApiFp(this.configuration).repositoriesWorkspaceRepoSlugBranchingModelGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the branching model configuration for a repository. The returned object:  1. Always has a `development` property for the development branch. 2. Always a `production` property for the production branch. The    production branch can be disabled. 3. The `branch_types` contains all the branch types. 4. `default_branch_deletion` indicates whether branches will be     deleted by default on merge.  This is the raw configuration for the branching model. A client wishing to see the branching model with its actual current branches may find the [active model API](/cloud/bitbucket/rest/api-group-branching-model/#api-repositories-workspace-repo-slug-branching-model-get) more useful.
     * @summary Get the branching model config for a repository
     * @param {BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelSettingsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugBranchingModelSettingsGet(requestParameters: BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelSettingsGetRequest, options?: RawAxiosRequestConfig) {
        return BranchingModelApiFp(this.configuration).repositoriesWorkspaceRepoSlugBranchingModelSettingsGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the branching model configuration for a repository.  The `development` branch can be configured to a specific branch or to track the main branch. When set to a specific branch it must currently exist. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `development` property will leave the development branch unchanged.  It is possible for the `development` branch to be invalid. This happens when it points at a specific branch that has been deleted. This is indicated in the `is_valid` field for the branch. It is not possible to update the settings for `development` if that would leave the branch in an invalid state. Such a request will be rejected.  The `production` branch can be a specific branch, the main branch or disabled. When set to a specific branch it must currently exist. The `enabled` property can be used to enable (`true`) or disable (`false`) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `production` property will leave the production branch unchanged.  It is possible for the `production` branch to be invalid. This happens when it points at a specific branch that has been deleted. This is indicated in the `is_valid` field for the branch. A request that would leave `production` enabled and invalid will be rejected. It is possible to update `production` and make it invalid if it would also be left disabled.  The `branch_types` property contains the branch types to be updated. Only the branch types passed will be updated. All updates will be rejected if it would leave the branching model in an invalid state. For branch types this means that:  1. The prefixes for all enabled branch types are valid. For example,    it is not possible to use \'*\' inside a Git prefix. 2. A prefix of an enabled branch type must not be a prefix of another    enabled branch type. This is to ensure that a branch can be easily    classified by its prefix unambiguously.  It is possible to store an invalid prefix if that branch type would be left disabled. Only the passed properties will be updated. The properties not passed will be left unchanged. Each branch type must have a `kind` property to identify it.  The `default_branch_deletion` property is a string. The value of `true` indicates to delete branches by default. The value of `false` indicates that branches will not be deleted by default. A request without a `default_branch_deletion` property will leave it unchanged. Other values would be ignored.  There is currently a side effect when using this API endpoint. If the repository is inheriting branching model settings from its project, updating the branching model for this repository will disable the project setting inheritance.   We have deprecated this side effect and will remove it on 1 August 2022.
     * @summary Update the branching model config for a repository
     * @param {BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelSettingsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugBranchingModelSettingsPut(requestParameters: BranchingModelApiRepositoriesWorkspaceRepoSlugBranchingModelSettingsPutRequest, options?: RawAxiosRequestConfig) {
        return BranchingModelApiFp(this.configuration).repositoriesWorkspaceRepoSlugBranchingModelSettingsPut(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the effective, or currently applied, branching model for a repository
     * @param {BranchingModelApiRepositoriesWorkspaceRepoSlugEffectiveBranchingModelGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugEffectiveBranchingModelGet(requestParameters: BranchingModelApiRepositoriesWorkspaceRepoSlugEffectiveBranchingModelGetRequest, options?: RawAxiosRequestConfig) {
        return BranchingModelApiFp(this.configuration).repositoriesWorkspaceRepoSlugEffectiveBranchingModelGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the branching model set at the project level. This view is read-only. The branching model settings can be changed using the [settings](#api-workspaces-workspace-projects-project-key-branching-model-settings-get) API.  The returned object:  1. Always has a `development` property. `development.name` is    the user-specified branch that can be inherited by an individual repository\'s    branching model. 2. Might have a `production` property. `production` will not    be present when `production` is disabled.    `production.name` is the user-specified branch that can be    inherited by an individual repository\'s branching model. 3. Always has a `branch_types` array which contains all enabled branch    types.
     * @summary Get the branching model for a project
     * @param {BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyBranchingModelGet(requestParameters: BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelGetRequest, options?: RawAxiosRequestConfig) {
        return BranchingModelApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyBranchingModelGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the branching model configuration for a project. The returned object:  1. Always has a `development` property for the development branch. 2. Always a `production` property for the production branch. The    production branch can be disabled. 3. The `branch_types` contains all the branch types. 4. `default_branch_deletion` indicates whether branches will be     deleted by default on merge.   This is the raw configuration for the branching model. A client wishing to see the branching model with its actual current branches may find the [active model API](#api-workspaces-workspace-projects-project-key-branching-model-get) more useful.
     * @summary Get the branching model config for a project
     * @param {BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGet(requestParameters: BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGetRequest, options?: RawAxiosRequestConfig) {
        return BranchingModelApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the branching model configuration for a project.  The `development` branch can be configured to a specific branch or to track the main branch. Any branch name can be supplied, but will only successfully be applied to a repository via inheritance if that branch exists for that repository. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `development` property will leave the development branch unchanged.  The `production` branch can be a specific branch, the main branch or disabled. Any branch name can be supplied, but will only successfully be applied to a repository via inheritance if that branch exists for that repository. The `enabled` property can be used to enable (`true`) or disable (`false`) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a `production` property will leave the production branch unchanged.  The `branch_types` property contains the branch types to be updated. Only the branch types passed will be updated. All updates will be rejected if it would leave the branching model in an invalid state. For branch types this means that:  1. The prefixes for all enabled branch types are valid. For example,    it is not possible to use \'*\' inside a Git prefix. 2. A prefix of an enabled branch type must not be a prefix of another    enabled branch type. This is to ensure that a branch can be easily    classified by its prefix unambiguously.  It is possible to store an invalid prefix if that branch type would be left disabled. Only the passed properties will be updated. The properties not passed will be left unchanged. Each branch type must have a `kind` property to identify it.  The `default_branch_deletion` property is a string. The value of `true` indicates to delete branches by default. The value of `false` indicates that branches will not be deleted by default. A request without a `default_branch_deletion` property will leave it unchanged. Other values would be ignored.
     * @summary Update the branching model config for a project
     * @param {BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPut(requestParameters: BranchingModelApiWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPutRequest, options?: RawAxiosRequestConfig) {
        return BranchingModelApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyBranchingModelSettingsPut(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommitStatusesApi - axios parameter creator
 */
export const CommitStatusesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the specified build status for a commit.
         * @summary Get a build status for a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} key The build status\&#39; unique key
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGet: async (commit: string, key: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGet', 'commit', commit)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGet', 'key', key)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/statuses/build/{key}`
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to update the current status of a build status object on the specific commit.  This operation can also be used to change other properties of the build status:  * `state` * `name` * `description` * `url` * `refname`  The `key` cannot be changed.
         * @summary Update a build status for a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} key The build status\&#39; unique key
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Commitstatus} [body] The updated build status object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPut: async (commit: string, key: string, repoSlug: string, workspace: string, body?: Commitstatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPut', 'commit', commit)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPut', 'key', key)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPut', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPut', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/statuses/build/{key}`
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new build status against the specified commit.  If the specified key already exists, the existing status object will be overwritten.  Example:  ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo/commit/e10dae226959c2194f2b07b077c07762d93821cf/statuses/build/           -X POST -u jdoe -H \'Content-Type: application/json\'           -d \'{     \"key\": \"MY-BUILD\",     \"state\": \"SUCCESSFUL\",     \"description\": \"42 tests passed\",     \"url\": \"https://www.example.org/my-build-result\"   }\' ```  When creating a new commit status, you can use a URI template for the URL. Templates are URLs that contain variable names that Bitbucket will evaluate at runtime whenever the URL is displayed anywhere similar to parameter substitution in [Bitbucket Connect](https://developer.atlassian.com/bitbucket/concepts/context-parameters.html). For example, one could use `https://foo.com/builds/{repository.full_name}` which Bitbucket will turn into `https://foo.com/builds/foo/bar` at render time. The context variables available are `repository` and `commit`.  To associate a commit status to a pull request, the refname field must be set to the source branch of the pull request.  Example: ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo/commit/e10dae226959c2194f2b07b077c07762d93821cf/statuses/build/           -X POST -u jdoe -H \'Content-Type: application/json\'           -d \'{     \"key\": \"MY-BUILD\",     \"state\": \"SUCCESSFUL\",     \"description\": \"42 tests passed\",     \"url\": \"https://www.example.org/my-build-result\",     \"refname\": \"my-pr-branch\"   }\' ```
         * @summary Create a build status for a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Commitstatus} [body] The new commit status object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPost: async (commit: string, repoSlug: string, workspace: string, body?: Commitstatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPost', 'commit', commit)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/statuses/build`
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all statuses (e.g. build results) for a specific commit.
         * @summary List commit statuses for a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [refname] If specified, only return commit status objects that were either created without a refname, or were created with the specified refname 
         * @param {string} [q] Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {string} [sort] Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). Defaults to &#x60;created_on&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitStatusesGet: async (commit: string, repoSlug: string, workspace: string, refname?: string, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitStatusesGet', 'commit', commit)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitStatusesGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitStatusesGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/statuses`
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (refname !== undefined) {
                localVarQueryParameter['refname'] = refname;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all statuses (e.g. build results) for the given pull request.
         * @summary List commit statuses for a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q] Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {string} [sort] Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). Defaults to &#x60;created_on&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet: async (pullRequestId: number, repoSlug: string, workspace: string, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/statuses`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommitStatusesApi - functional programming interface
 */
export const CommitStatusesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommitStatusesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the specified build status for a commit.
         * @summary Get a build status for a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} key The build status\&#39; unique key
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGet(commit: string, key: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Commitstatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGet(commit, key, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitStatusesApi.repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to update the current status of a build status object on the specific commit.  This operation can also be used to change other properties of the build status:  * `state` * `name` * `description` * `url` * `refname`  The `key` cannot be changed.
         * @summary Update a build status for a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} key The build status\&#39; unique key
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Commitstatus} [body] The updated build status object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPut(commit: string, key: string, repoSlug: string, workspace: string, body?: Commitstatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Commitstatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPut(commit, key, repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitStatusesApi.repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new build status against the specified commit.  If the specified key already exists, the existing status object will be overwritten.  Example:  ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo/commit/e10dae226959c2194f2b07b077c07762d93821cf/statuses/build/           -X POST -u jdoe -H \'Content-Type: application/json\'           -d \'{     \"key\": \"MY-BUILD\",     \"state\": \"SUCCESSFUL\",     \"description\": \"42 tests passed\",     \"url\": \"https://www.example.org/my-build-result\"   }\' ```  When creating a new commit status, you can use a URI template for the URL. Templates are URLs that contain variable names that Bitbucket will evaluate at runtime whenever the URL is displayed anywhere similar to parameter substitution in [Bitbucket Connect](https://developer.atlassian.com/bitbucket/concepts/context-parameters.html). For example, one could use `https://foo.com/builds/{repository.full_name}` which Bitbucket will turn into `https://foo.com/builds/foo/bar` at render time. The context variables available are `repository` and `commit`.  To associate a commit status to a pull request, the refname field must be set to the source branch of the pull request.  Example: ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo/commit/e10dae226959c2194f2b07b077c07762d93821cf/statuses/build/           -X POST -u jdoe -H \'Content-Type: application/json\'           -d \'{     \"key\": \"MY-BUILD\",     \"state\": \"SUCCESSFUL\",     \"description\": \"42 tests passed\",     \"url\": \"https://www.example.org/my-build-result\",     \"refname\": \"my-pr-branch\"   }\' ```
         * @summary Create a build status for a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Commitstatus} [body] The new commit status object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPost(commit: string, repoSlug: string, workspace: string, body?: Commitstatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Commitstatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPost(commit, repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitStatusesApi.repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all statuses (e.g. build results) for a specific commit.
         * @summary List commit statuses for a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [refname] If specified, only return commit status objects that were either created without a refname, or were created with the specified refname 
         * @param {string} [q] Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {string} [sort] Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). Defaults to &#x60;created_on&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitCommitStatusesGet(commit: string, repoSlug: string, workspace: string, refname?: string, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCommitstatuses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitCommitStatusesGet(commit, repoSlug, workspace, refname, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitStatusesApi.repositoriesWorkspaceRepoSlugCommitCommitStatusesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all statuses (e.g. build results) for the given pull request.
         * @summary List commit statuses for a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q] Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {string} [sort] Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). Defaults to &#x60;created_on&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(pullRequestId: number, repoSlug: string, workspace: string, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCommitstatuses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(pullRequestId, repoSlug, workspace, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitStatusesApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommitStatusesApi - factory interface
 */
export const CommitStatusesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommitStatusesApiFp(configuration)
    return {
        /**
         * Returns the specified build status for a commit.
         * @summary Get a build status for a commit
         * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGet(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Commitstatus> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGet(requestParameters.commit, requestParameters.key, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to update the current status of a build status object on the specific commit.  This operation can also be used to change other properties of the build status:  * `state` * `name` * `description` * `url` * `refname`  The `key` cannot be changed.
         * @summary Update a build status for a commit
         * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPut(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Commitstatus> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPut(requestParameters.commit, requestParameters.key, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new build status against the specified commit.  If the specified key already exists, the existing status object will be overwritten.  Example:  ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo/commit/e10dae226959c2194f2b07b077c07762d93821cf/statuses/build/           -X POST -u jdoe -H \'Content-Type: application/json\'           -d \'{     \"key\": \"MY-BUILD\",     \"state\": \"SUCCESSFUL\",     \"description\": \"42 tests passed\",     \"url\": \"https://www.example.org/my-build-result\"   }\' ```  When creating a new commit status, you can use a URI template for the URL. Templates are URLs that contain variable names that Bitbucket will evaluate at runtime whenever the URL is displayed anywhere similar to parameter substitution in [Bitbucket Connect](https://developer.atlassian.com/bitbucket/concepts/context-parameters.html). For example, one could use `https://foo.com/builds/{repository.full_name}` which Bitbucket will turn into `https://foo.com/builds/foo/bar` at render time. The context variables available are `repository` and `commit`.  To associate a commit status to a pull request, the refname field must be set to the source branch of the pull request.  Example: ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo/commit/e10dae226959c2194f2b07b077c07762d93821cf/statuses/build/           -X POST -u jdoe -H \'Content-Type: application/json\'           -d \'{     \"key\": \"MY-BUILD\",     \"state\": \"SUCCESSFUL\",     \"description\": \"42 tests passed\",     \"url\": \"https://www.example.org/my-build-result\",     \"refname\": \"my-pr-branch\"   }\' ```
         * @summary Create a build status for a commit
         * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPost(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Commitstatus> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPost(requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all statuses (e.g. build results) for a specific commit.
         * @summary List commit statuses for a commit
         * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitStatusesGet(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedCommitstatuses> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitCommitStatusesGet(requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, requestParameters.refname, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all statuses (e.g. build results) for the given pull request.
         * @summary List commit statuses for a pull request
         * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedCommitstatuses> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommitStatusesApi - interface
 */
export interface CommitStatusesApiInterface {
    /**
     * Returns the specified build status for a commit.
     * @summary Get a build status for a commit
     * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGet(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Commitstatus>;

    /**
     * Used to update the current status of a build status object on the specific commit.  This operation can also be used to change other properties of the build status:  * `state` * `name` * `description` * `url` * `refname`  The `key` cannot be changed.
     * @summary Update a build status for a commit
     * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPut(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Commitstatus>;

    /**
     * Creates a new build status against the specified commit.  If the specified key already exists, the existing status object will be overwritten.  Example:  ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo/commit/e10dae226959c2194f2b07b077c07762d93821cf/statuses/build/           -X POST -u jdoe -H \'Content-Type: application/json\'           -d \'{     \"key\": \"MY-BUILD\",     \"state\": \"SUCCESSFUL\",     \"description\": \"42 tests passed\",     \"url\": \"https://www.example.org/my-build-result\"   }\' ```  When creating a new commit status, you can use a URI template for the URL. Templates are URLs that contain variable names that Bitbucket will evaluate at runtime whenever the URL is displayed anywhere similar to parameter substitution in [Bitbucket Connect](https://developer.atlassian.com/bitbucket/concepts/context-parameters.html). For example, one could use `https://foo.com/builds/{repository.full_name}` which Bitbucket will turn into `https://foo.com/builds/foo/bar` at render time. The context variables available are `repository` and `commit`.  To associate a commit status to a pull request, the refname field must be set to the source branch of the pull request.  Example: ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo/commit/e10dae226959c2194f2b07b077c07762d93821cf/statuses/build/           -X POST -u jdoe -H \'Content-Type: application/json\'           -d \'{     \"key\": \"MY-BUILD\",     \"state\": \"SUCCESSFUL\",     \"description\": \"42 tests passed\",     \"url\": \"https://www.example.org/my-build-result\",     \"refname\": \"my-pr-branch\"   }\' ```
     * @summary Create a build status for a commit
     * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPost(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Commitstatus>;

    /**
     * Returns all statuses (e.g. build results) for a specific commit.
     * @summary List commit statuses for a commit
     * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitCommitStatusesGet(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedCommitstatuses>;

    /**
     * Returns all statuses (e.g. build results) for the given pull request.
     * @summary List commit statuses for a pull request
     * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedCommitstatuses>;

}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGet operation in CommitStatusesApi.
 */
export interface CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGetRequest {
    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * The build status\&#39; unique key
     */
    readonly key: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPut operation in CommitStatusesApi.
 */
export interface CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPutRequest {
    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * The build status\&#39; unique key
     */
    readonly key: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The updated build status object
     */
    readonly body?: Commitstatus
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPost operation in CommitStatusesApi.
 */
export interface CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPostRequest {
    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The new commit status object.
     */
    readonly body?: Commitstatus
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitCommitStatusesGet operation in CommitStatusesApi.
 */
export interface CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesGetRequest {
    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * If specified, only return commit status objects that were either created without a refname, or were created with the specified refname 
     */
    readonly refname?: string

    /**
     * Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
     */
    readonly q?: string

    /**
     * Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). Defaults to &#x60;created_on&#x60;. 
     */
    readonly sort?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet operation in CommitStatusesApi.
 */
export interface CommitStatusesApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
     */
    readonly q?: string

    /**
     * Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). Defaults to &#x60;created_on&#x60;. 
     */
    readonly sort?: string
}

/**
 * CommitStatusesApi - object-oriented interface
 */
export class CommitStatusesApi extends BaseAPI implements CommitStatusesApiInterface {
    /**
     * Returns the specified build status for a commit.
     * @summary Get a build status for a commit
     * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGet(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGetRequest, options?: RawAxiosRequestConfig) {
        return CommitStatusesApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyGet(requestParameters.commit, requestParameters.key, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to update the current status of a build status object on the specific commit.  This operation can also be used to change other properties of the build status:  * `state` * `name` * `description` * `url` * `refname`  The `key` cannot be changed.
     * @summary Update a build status for a commit
     * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPut(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPutRequest, options?: RawAxiosRequestConfig) {
        return CommitStatusesApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyPut(requestParameters.commit, requestParameters.key, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new build status against the specified commit.  If the specified key already exists, the existing status object will be overwritten.  Example:  ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo/commit/e10dae226959c2194f2b07b077c07762d93821cf/statuses/build/           -X POST -u jdoe -H \'Content-Type: application/json\'           -d \'{     \"key\": \"MY-BUILD\",     \"state\": \"SUCCESSFUL\",     \"description\": \"42 tests passed\",     \"url\": \"https://www.example.org/my-build-result\"   }\' ```  When creating a new commit status, you can use a URI template for the URL. Templates are URLs that contain variable names that Bitbucket will evaluate at runtime whenever the URL is displayed anywhere similar to parameter substitution in [Bitbucket Connect](https://developer.atlassian.com/bitbucket/concepts/context-parameters.html). For example, one could use `https://foo.com/builds/{repository.full_name}` which Bitbucket will turn into `https://foo.com/builds/foo/bar` at render time. The context variables available are `repository` and `commit`.  To associate a commit status to a pull request, the refname field must be set to the source branch of the pull request.  Example: ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo/commit/e10dae226959c2194f2b07b077c07762d93821cf/statuses/build/           -X POST -u jdoe -H \'Content-Type: application/json\'           -d \'{     \"key\": \"MY-BUILD\",     \"state\": \"SUCCESSFUL\",     \"description\": \"42 tests passed\",     \"url\": \"https://www.example.org/my-build-result\",     \"refname\": \"my-pr-branch\"   }\' ```
     * @summary Create a build status for a commit
     * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPost(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPostRequest, options?: RawAxiosRequestConfig) {
        return CommitStatusesApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitCommitStatusesBuildPost(requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all statuses (e.g. build results) for a specific commit.
     * @summary List commit statuses for a commit
     * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitCommitStatusesGet(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugCommitCommitStatusesGetRequest, options?: RawAxiosRequestConfig) {
        return CommitStatusesApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitCommitStatusesGet(requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, requestParameters.refname, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all statuses (e.g. build results) for the given pull request.
     * @summary List commit statuses for a pull request
     * @param {CommitStatusesApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(requestParameters: CommitStatusesApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest, options?: RawAxiosRequestConfig) {
        return CommitStatusesApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommitsApi - axios parameter creator
 */
export const CommitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: ``` curl --location \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001/annotations\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'[   {         \"external_id\": \"mysystem-annotation001\",         \"title\": \"Security scan report\",         \"annotation_type\": \"VULNERABILITY\",         \"summary\": \"This line represents a security threat.\",         \"severity\": \"HIGH\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",         \"line\": 42   },   {         \"external_id\": \"mySystem-annotation002\",         \"title\": \"Bug report\",         \"annotation_type\": \"BUG\",         \"result\": \"FAILED\",         \"summary\": \"This line might introduce a bug.\",         \"severity\": \"MEDIUM\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\",         \"line\": 13   } ]\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Bulk create or update annotations
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit for which to retrieve reports.
         * @param {string} reportId Uuid or external-if of the report for which to get annotations for.
         * @param {Array<ReportAnnotation>} body The annotations to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateOrUpdateAnnotations: async (workspace: string, repoSlug: string, commit: string, reportId: string, body: Array<ReportAnnotation>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('bulkCreateOrUpdateAnnotations', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('bulkCreateOrUpdateAnnotations', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('bulkCreateOrUpdateAnnotations', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('bulkCreateOrUpdateAnnotations', 'reportId', reportId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('bulkCreateOrUpdateAnnotations', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mySystem-001/annotations/mysystem-annotation001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"annotation_type\": \"VULNERABILITY\",     \"summary\": \"This line represents a security thread.\",     \"severity\": \"HIGH\",     \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",     \"line\": 42 }\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Create or update an annotation
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {string} annotationId Either the uuid or external-id of the annotation.
         * @param {ReportAnnotation} body The annotation to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateAnnotation: async (workspace: string, repoSlug: string, commit: string, reportId: string, annotationId: string, body: ReportAnnotation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createOrUpdateAnnotation', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('createOrUpdateAnnotation', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('createOrUpdateAnnotation', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('createOrUpdateAnnotation', 'reportId', reportId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('createOrUpdateAnnotation', 'annotationId', annotationId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateAnnotation', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)))
                .replace(`{${"annotationId"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"details\": \"This pull request introduces 10 new dependency vulnerabilities.\",     \"report_type\": \"SECURITY\",     \"reporter\": \"mySystem\",     \"link\": \"http://www.mysystem.com/reports/001\",     \"result\": \"FAILED\",     \"data\": [         {             \"title\": \"Duration (seconds)\",             \"type\": \"DURATION\",             \"value\": 14         },         {             \"title\": \"Safe to merge?\",             \"type\": \"BOOLEAN\",             \"value\": false         }     ] }\' ```  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as \'Yes\' or \'No\'. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: `{\"text\": \"Link text here\", \"href\": \"https://link.to.annotation/in/external/tool\"}` | The value will be read as a JSON object containing the fields \"text\" and \"href\" and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Create or update a report
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {Report} body The report to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateReport: async (workspace: string, repoSlug: string, commit: string, reportId: string, body: Report, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createOrUpdateReport', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('createOrUpdateReport', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('createOrUpdateReport', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('createOrUpdateReport', 'reportId', reportId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateReport', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single Annotation matching the provided ID.
         * @summary Delete an annotation
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the annotation belongs to.
         * @param {string} reportId Either the uuid or external-id of the annotation.
         * @param {string} annotationId Either the uuid or external-id of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnotation: async (workspace: string, repoSlug: string, commit: string, reportId: string, annotationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteAnnotation', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deleteAnnotation', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('deleteAnnotation', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('deleteAnnotation', 'reportId', reportId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('deleteAnnotation', 'annotationId', annotationId)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)))
                .replace(`{${"annotationId"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single Report matching the provided ID.
         * @summary Delete a report
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport: async (workspace: string, repoSlug: string, commit: string, reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteReport', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deleteReport', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('deleteReport', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('deleteReport', 'reportId', reportId)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Annotation matching the provided ID.
         * @summary Get an annotation
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {string} annotationId Either the uuid or external-id of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotation: async (workspace: string, repoSlug: string, commit: string, reportId: string, annotationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getAnnotation', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getAnnotation', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('getAnnotation', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getAnnotation', 'reportId', reportId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('getAnnotation', 'annotationId', annotationId)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)))
                .replace(`{${"annotationId"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of Annotations for a specified report.
         * @summary List annotations
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit for which to retrieve reports.
         * @param {string} reportId Uuid or external-if of the report for which to get annotations for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotationsForReport: async (workspace: string, repoSlug: string, commit: string, reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getAnnotationsForReport', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getAnnotationsForReport', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('getAnnotationsForReport', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getAnnotationsForReport', 'reportId', reportId)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Report matching the provided ID.
         * @summary Get a report
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport: async (workspace: string, repoSlug: string, commit: string, reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getReport', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getReport', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('getReport', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getReport', 'reportId', reportId)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of Reports linked to this commit.
         * @summary List reports
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit for which to retrieve reports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsForCommit: async (workspace: string, repoSlug: string, commit: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getReportsForCommit', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getReportsForCommit', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('getReportsForCommit', 'commit', commit)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redact the authenticated user\'s approval of the specified commit.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
         * @summary Unapprove a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitApproveDelete: async (commit: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitApproveDelete', 'commit', commit)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitApproveDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitApproveDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/approve`
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Approve the specified commit as the authenticated user.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
         * @summary Approve a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitApprovePost: async (commit: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitApprovePost', 'commit', commit)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitApprovePost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitApprovePost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/approve`
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified commit comment.  Note that deleting comments that have visible replies that point to them will not really delete the resource. This is to retain the integrity of the original comment tree. Instead, the `deleted` element is set to `true` and the content is blanked out. The comment will continue to be returned by the collections and self endpoints.
         * @summary Delete a commit comment
         * @param {number} commentId The id of the comment.
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete: async (commentId: number, commit: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete', 'commentId', commentId)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete', 'commit', commit)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified commit comment.
         * @summary Get a commit comment
         * @param {number} commentId The id of the comment.
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet: async (commentId: number, commit: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet', 'commentId', commentId)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet', 'commit', commit)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to update the contents of a comment. Only the content of the comment can be updated.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/7f71b5/comments/5728901 \\   -X PUT -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"One more thing!\"}\' ```
         * @summary Update a commit comment
         * @param {number} commentId The id of the comment.
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {CommitComment} body The updated comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut: async (commentId: number, commit: string, repoSlug: string, workspace: string, body: CommitComment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut', 'commentId', commentId)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut', 'commit', commit)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the commit\'s comments.  This includes both global and inline comments.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.
         * @summary List a commit\'s comments
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q] Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {string} [sort] Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitCommentsGet: async (commit: string, repoSlug: string, workspace: string, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsGet', 'commit', commit)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/comments`
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new comment on the specified commit.  To post a reply to an existing comment, include the `parent.id` field:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \\   -X POST -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"One more thing!\"},        \"parent\": {\"id\": 5728901}}\' ```
         * @summary Create comment for a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {CommitComment} body The specified comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitCommentsPost: async (commit: string, repoSlug: string, workspace: string, body: CommitComment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsPost', 'commit', commit)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsPost', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitCommentsPost', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/comments`
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified commit.
         * @summary Get a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitGet: async (commit: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitGet', 'commit', commit)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitCommitGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}`
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * These are the repository\'s commits. They are paginated and returned in reverse chronological order, similar to the output of `git log`. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to `git log --all`).  #### GET /repositories/{workspace}/{repo_slug}/commits/?exclude=master  Returns all commits in the repo that are not on master (similar to `git log --all ^master`).  #### GET /repositories/{workspace}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar  Returns all commits that are on refs `foo` or `bar`, but not on `fu` or `fubar` (similar to `git log foo bar ^fu ^fubar`).  An optional `path` parameter can be specified that will limit the results to commits that affect that path. `path` can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by `path`. It is important to note that if the `path` parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the \'next\' link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a `x-www-form-urlencoded` POST instead.
         * @summary List commits
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitsGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commits`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Identical to `GET /repositories/{workspace}/{repo_slug}/commits`, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
         * @summary List commits with include/exclude
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitsPost: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitsPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitsPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commits`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * These are the repository\'s commits. They are paginated and returned in reverse chronological order, similar to the output of `git log`. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/master  Returns all commits on ref `master` (similar to `git log master`).  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?include=foo&exclude=master  Returns all commits on ref `dev` or `foo`, except those that are reachable on `master` (similar to `git log dev foo ^master`).  An optional `path` parameter can be specified that will limit the results to commits that affect that path. `path` can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by `path`. It is important to note that if the `path` parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path=README.md&include=foo&include=bar&exclude=master  Returns all commits that are on refs `dev` or `foo` or `bar`, but not on `master` that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path=src/&include=foo&exclude=master  Returns all commits that are on refs `dev` or `foo`, but not on `master` that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the \'next\' link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a `x-www-form-urlencoded` POST instead.
         * @summary List commits for revision
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} revision A commit SHA1 or ref name.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitsRevisionGet: async (repoSlug: string, revision: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitsRevisionGet', 'repoSlug', repoSlug)
            // verify required parameter 'revision' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitsRevisionGet', 'revision', revision)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitsRevisionGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commits/{revision}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"revision"}}`, encodeURIComponent(String(revision)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Identical to `GET /repositories/{workspace}/{repo_slug}/commits/{revision}`, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
         * @summary List commits for revision using include/exclude
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} revision A commit SHA1 or ref name.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitsRevisionPost: async (repoSlug: string, revision: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitsRevisionPost', 'repoSlug', repoSlug)
            // verify required parameter 'revision' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitsRevisionPost', 'revision', revision)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugCommitsRevisionPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commits/{revision}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"revision"}}`, encodeURIComponent(String(revision)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Produces a raw git-style diff.  #### Single commit spec  If the `spec` argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by `..` may be provided as the `spec`, e.g., `3a8b42..9ff173`. When two commits are provided and the `topic` query parameter is true, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the `topic` query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in `git diff`.  #### Comparison to patches  While similar to patches, diffs:  * Don\'t have a commit header (username, commit message, etc) * Support the optional `path=foo/bar.py` query param to filter   the diff to just that one file diff  #### Response  The raw diff is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is `text/plain`.
         * @summary Compare two commits
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;). 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {number} [context] Generate diffs with &lt;n&gt; lines of context instead of the usual three.
         * @param {string} [path] Limit the diff to a particular file (this parameter can be repeated for multiple paths).
         * @param {boolean} [ignoreWhitespace] Generate diffs that ignore whitespace.
         * @param {boolean} [binary] Generate diffs that include binary files, true if omitted.
         * @param {boolean} [renames] Whether to perform rename detection, true if omitted.
         * @param {boolean} [merge] This parameter is deprecated. The \&#39;topic\&#39; parameter should be used instead. The \&#39;merge\&#39; and \&#39;topic\&#39; parameters cannot be both used at the same time.  If true, the source commit is merged into the destination commit, and then a diff from the destination to the merge result is returned. If false, a simple \&#39;two dot\&#39; diff between the source and destination is returned. True if omitted.
         * @param {boolean} [topic] If true, returns 2-way \&#39;three-dot\&#39; diff. This is a diff between the source commit and the merge base of the source commit and the destination commit. If false, a simple \&#39;two dot\&#39; diff between the source and destination is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDiffSpecGet: async (repoSlug: string, spec: string, workspace: string, context?: number, path?: string, ignoreWhitespace?: boolean, binary?: boolean, renames?: boolean, merge?: boolean, topic?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDiffSpecGet', 'repoSlug', repoSlug)
            // verify required parameter 'spec' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDiffSpecGet', 'spec', spec)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDiffSpecGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/diff/{spec}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"spec"}}`, encodeURIComponent(String(spec)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (ignoreWhitespace !== undefined) {
                localVarQueryParameter['ignore_whitespace'] = ignoreWhitespace;
            }

            if (binary !== undefined) {
                localVarQueryParameter['binary'] = binary;
            }

            if (renames !== undefined) {
                localVarQueryParameter['renames'] = renames;
            }

            if (merge !== undefined) {
                localVarQueryParameter['merge'] = merge;
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Produces a response in JSON format with a record for every path modified, including information on the type of the change and the number of lines added and removed.  #### Single commit spec  If the `spec` argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by `..` may be provided as the `spec`, e.g., `3a8b42..9ff173`. When two commits are provided and the `topic` query parameter is true, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the `topic` query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in `git diff`.
         * @summary Compare two commit diff stats
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;). 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {boolean} [ignoreWhitespace] Generate diffs that ignore whitespace
         * @param {boolean} [merge] This parameter is deprecated. The \&#39;topic\&#39; parameter should be used instead. The \&#39;merge\&#39; and \&#39;topic\&#39; parameters cannot be both used at the same time.  If true, the source commit is merged into the destination commit, and then a diffstat from the destination to the merge result is returned. If false, a simple \&#39;two dot\&#39; diffstat between the source and destination is returned. True if omitted.
         * @param {string} [path] Limit the diffstat to a particular file (this parameter can be repeated for multiple paths).
         * @param {boolean} [renames] Whether to perform rename detection, true if omitted.
         * @param {boolean} [topic] If true, returns 2-way \&#39;three-dot\&#39; diff. This is a diff between the source commit and the merge base of the source commit and the destination commit. If false, a simple \&#39;two dot\&#39; diff between the source and destination is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDiffstatSpecGet: async (repoSlug: string, spec: string, workspace: string, ignoreWhitespace?: boolean, merge?: boolean, path?: string, renames?: boolean, topic?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDiffstatSpecGet', 'repoSlug', repoSlug)
            // verify required parameter 'spec' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDiffstatSpecGet', 'spec', spec)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDiffstatSpecGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/diffstat/{spec}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"spec"}}`, encodeURIComponent(String(spec)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ignoreWhitespace !== undefined) {
                localVarQueryParameter['ignore_whitespace'] = ignoreWhitespace;
            }

            if (merge !== undefined) {
                localVarQueryParameter['merge'] = merge;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (renames !== undefined) {
                localVarQueryParameter['renames'] = renames;
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the best common ancestor between two commits, specified in a revspec of 2 commits (e.g. 3a8b42..9ff173).  If more than one best common ancestor exists, only one will be returned. It is unspecified which will be returned.
         * @summary Get the common ancestor between two commits
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} revspec A commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;). 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugMergeBaseRevspecGet: async (repoSlug: string, revspec: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugMergeBaseRevspecGet', 'repoSlug', repoSlug)
            // verify required parameter 'revspec' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugMergeBaseRevspecGet', 'revspec', revspec)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugMergeBaseRevspecGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/merge-base/{revspec}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"revspec"}}`, encodeURIComponent(String(revspec)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Produces a raw patch for a single commit (diffed against its first parent), or a patch-series for a revspec of 2 commits (e.g. `3a8b42..9ff173` where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a patch series is returned for the commits on the source branch (`3a8b42` and its ancestors in our example).  While similar to diffs, patches:  * Have a commit header (username, commit message, etc) * Do not support the `path=foo/bar.py` query parameter  The raw patch is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is `text/plain`.
         * @summary Get a patch for two commits
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;). 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPatchSpecGet: async (repoSlug: string, spec: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPatchSpecGet', 'repoSlug', repoSlug)
            // verify required parameter 'spec' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPatchSpecGet', 'spec', spec)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPatchSpecGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/patch/{spec}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"spec"}}`, encodeURIComponent(String(spec)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommitsApi - functional programming interface
 */
export const CommitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommitsApiAxiosParamCreator(configuration)
    return {
        /**
         * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: ``` curl --location \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001/annotations\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'[   {         \"external_id\": \"mysystem-annotation001\",         \"title\": \"Security scan report\",         \"annotation_type\": \"VULNERABILITY\",         \"summary\": \"This line represents a security threat.\",         \"severity\": \"HIGH\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",         \"line\": 42   },   {         \"external_id\": \"mySystem-annotation002\",         \"title\": \"Bug report\",         \"annotation_type\": \"BUG\",         \"result\": \"FAILED\",         \"summary\": \"This line might introduce a bug.\",         \"severity\": \"MEDIUM\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\",         \"line\": 13   } ]\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Bulk create or update annotations
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit for which to retrieve reports.
         * @param {string} reportId Uuid or external-if of the report for which to get annotations for.
         * @param {Array<ReportAnnotation>} body The annotations to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkCreateOrUpdateAnnotations(workspace: string, repoSlug: string, commit: string, reportId: string, body: Array<ReportAnnotation>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReportAnnotation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreateOrUpdateAnnotations(workspace, repoSlug, commit, reportId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.bulkCreateOrUpdateAnnotations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mySystem-001/annotations/mysystem-annotation001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"annotation_type\": \"VULNERABILITY\",     \"summary\": \"This line represents a security thread.\",     \"severity\": \"HIGH\",     \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",     \"line\": 42 }\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Create or update an annotation
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {string} annotationId Either the uuid or external-id of the annotation.
         * @param {ReportAnnotation} body The annotation to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateAnnotation(workspace: string, repoSlug: string, commit: string, reportId: string, annotationId: string, body: ReportAnnotation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportAnnotation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateAnnotation(workspace, repoSlug, commit, reportId, annotationId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.createOrUpdateAnnotation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"details\": \"This pull request introduces 10 new dependency vulnerabilities.\",     \"report_type\": \"SECURITY\",     \"reporter\": \"mySystem\",     \"link\": \"http://www.mysystem.com/reports/001\",     \"result\": \"FAILED\",     \"data\": [         {             \"title\": \"Duration (seconds)\",             \"type\": \"DURATION\",             \"value\": 14         },         {             \"title\": \"Safe to merge?\",             \"type\": \"BOOLEAN\",             \"value\": false         }     ] }\' ```  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as \'Yes\' or \'No\'. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: `{\"text\": \"Link text here\", \"href\": \"https://link.to.annotation/in/external/tool\"}` | The value will be read as a JSON object containing the fields \"text\" and \"href\" and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Create or update a report
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {Report} body The report to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateReport(workspace: string, repoSlug: string, commit: string, reportId: string, body: Report, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateReport(workspace, repoSlug, commit, reportId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.createOrUpdateReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a single Annotation matching the provided ID.
         * @summary Delete an annotation
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the annotation belongs to.
         * @param {string} reportId Either the uuid or external-id of the annotation.
         * @param {string} annotationId Either the uuid or external-id of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnnotation(workspace: string, repoSlug: string, commit: string, reportId: string, annotationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAnnotation(workspace, repoSlug, commit, reportId, annotationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.deleteAnnotation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a single Report matching the provided ID.
         * @summary Delete a report
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReport(workspace: string, repoSlug: string, commit: string, reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReport(workspace, repoSlug, commit, reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.deleteReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single Annotation matching the provided ID.
         * @summary Get an annotation
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {string} annotationId Either the uuid or external-id of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnotation(workspace: string, repoSlug: string, commit: string, reportId: string, annotationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportAnnotation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnotation(workspace, repoSlug, commit, reportId, annotationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.getAnnotation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of Annotations for a specified report.
         * @summary List annotations
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit for which to retrieve reports.
         * @param {string} reportId Uuid or external-if of the report for which to get annotations for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnotationsForReport(workspace: string, repoSlug: string, commit: string, reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAnnotations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnotationsForReport(workspace, repoSlug, commit, reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.getAnnotationsForReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single Report matching the provided ID.
         * @summary Get a report
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReport(workspace: string, repoSlug: string, commit: string, reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReport(workspace, repoSlug, commit, reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.getReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of Reports linked to this commit.
         * @summary List reports
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit for which to retrieve reports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReportsForCommit(workspace: string, repoSlug: string, commit: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedReports>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReportsForCommit(workspace, repoSlug, commit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.getReportsForCommit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Redact the authenticated user\'s approval of the specified commit.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
         * @summary Unapprove a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitCommitApproveDelete(commit: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitCommitApproveDelete(commit, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugCommitCommitApproveDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Approve the specified commit as the authenticated user.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
         * @summary Approve a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitCommitApprovePost(commit: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Participant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitCommitApprovePost(commit, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugCommitCommitApprovePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified commit comment.  Note that deleting comments that have visible replies that point to them will not really delete the resource. This is to retain the integrity of the original comment tree. Instead, the `deleted` element is set to `true` and the content is blanked out. The comment will continue to be returned by the collections and self endpoints.
         * @summary Delete a commit comment
         * @param {number} commentId The id of the comment.
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete(commentId: number, commit: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete(commentId, commit, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specified commit comment.
         * @summary Get a commit comment
         * @param {number} commentId The id of the comment.
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet(commentId: number, commit: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet(commentId, commit, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to update the contents of a comment. Only the content of the comment can be updated.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/7f71b5/comments/5728901 \\   -X PUT -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"One more thing!\"}\' ```
         * @summary Update a commit comment
         * @param {number} commentId The id of the comment.
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {CommitComment} body The updated comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut(commentId: number, commit: string, repoSlug: string, workspace: string, body: CommitComment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut(commentId, commit, repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the commit\'s comments.  This includes both global and inline comments.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.
         * @summary List a commit\'s comments
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q] Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {string} [sort] Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitCommitCommentsGet(commit: string, repoSlug: string, workspace: string, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCommitComments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitCommitCommentsGet(commit, repoSlug, workspace, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugCommitCommitCommentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates new comment on the specified commit.  To post a reply to an existing comment, include the `parent.id` field:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \\   -X POST -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"One more thing!\"},        \"parent\": {\"id\": 5728901}}\' ```
         * @summary Create comment for a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {CommitComment} body The specified comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitCommitCommentsPost(commit: string, repoSlug: string, workspace: string, body: CommitComment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitCommitCommentsPost(commit, repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugCommitCommitCommentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specified commit.
         * @summary Get a commit
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitCommitGet(commit: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Commit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitCommitGet(commit, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugCommitCommitGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * These are the repository\'s commits. They are paginated and returned in reverse chronological order, similar to the output of `git log`. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to `git log --all`).  #### GET /repositories/{workspace}/{repo_slug}/commits/?exclude=master  Returns all commits in the repo that are not on master (similar to `git log --all ^master`).  #### GET /repositories/{workspace}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar  Returns all commits that are on refs `foo` or `bar`, but not on `fu` or `fubar` (similar to `git log foo bar ^fu ^fubar`).  An optional `path` parameter can be specified that will limit the results to commits that affect that path. `path` can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by `path`. It is important to note that if the `path` parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the \'next\' link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a `x-www-form-urlencoded` POST instead.
         * @summary List commits
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitsGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedChangeset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitsGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugCommitsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Identical to `GET /repositories/{workspace}/{repo_slug}/commits`, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
         * @summary List commits with include/exclude
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitsPost(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedChangeset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitsPost(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugCommitsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * These are the repository\'s commits. They are paginated and returned in reverse chronological order, similar to the output of `git log`. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/master  Returns all commits on ref `master` (similar to `git log master`).  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?include=foo&exclude=master  Returns all commits on ref `dev` or `foo`, except those that are reachable on `master` (similar to `git log dev foo ^master`).  An optional `path` parameter can be specified that will limit the results to commits that affect that path. `path` can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by `path`. It is important to note that if the `path` parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path=README.md&include=foo&include=bar&exclude=master  Returns all commits that are on refs `dev` or `foo` or `bar`, but not on `master` that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path=src/&include=foo&exclude=master  Returns all commits that are on refs `dev` or `foo`, but not on `master` that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the \'next\' link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a `x-www-form-urlencoded` POST instead.
         * @summary List commits for revision
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} revision A commit SHA1 or ref name.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitsRevisionGet(repoSlug: string, revision: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedChangeset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitsRevisionGet(repoSlug, revision, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugCommitsRevisionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Identical to `GET /repositories/{workspace}/{repo_slug}/commits/{revision}`, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
         * @summary List commits for revision using include/exclude
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} revision A commit SHA1 or ref name.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugCommitsRevisionPost(repoSlug: string, revision: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedChangeset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugCommitsRevisionPost(repoSlug, revision, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugCommitsRevisionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Produces a raw git-style diff.  #### Single commit spec  If the `spec` argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by `..` may be provided as the `spec`, e.g., `3a8b42..9ff173`. When two commits are provided and the `topic` query parameter is true, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the `topic` query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in `git diff`.  #### Comparison to patches  While similar to patches, diffs:  * Don\'t have a commit header (username, commit message, etc) * Support the optional `path=foo/bar.py` query param to filter   the diff to just that one file diff  #### Response  The raw diff is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is `text/plain`.
         * @summary Compare two commits
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;). 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {number} [context] Generate diffs with &lt;n&gt; lines of context instead of the usual three.
         * @param {string} [path] Limit the diff to a particular file (this parameter can be repeated for multiple paths).
         * @param {boolean} [ignoreWhitespace] Generate diffs that ignore whitespace.
         * @param {boolean} [binary] Generate diffs that include binary files, true if omitted.
         * @param {boolean} [renames] Whether to perform rename detection, true if omitted.
         * @param {boolean} [merge] This parameter is deprecated. The \&#39;topic\&#39; parameter should be used instead. The \&#39;merge\&#39; and \&#39;topic\&#39; parameters cannot be both used at the same time.  If true, the source commit is merged into the destination commit, and then a diff from the destination to the merge result is returned. If false, a simple \&#39;two dot\&#39; diff between the source and destination is returned. True if omitted.
         * @param {boolean} [topic] If true, returns 2-way \&#39;three-dot\&#39; diff. This is a diff between the source commit and the merge base of the source commit and the destination commit. If false, a simple \&#39;two dot\&#39; diff between the source and destination is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDiffSpecGet(repoSlug: string, spec: string, workspace: string, context?: number, path?: string, ignoreWhitespace?: boolean, binary?: boolean, renames?: boolean, merge?: boolean, topic?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDiffSpecGet(repoSlug, spec, workspace, context, path, ignoreWhitespace, binary, renames, merge, topic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugDiffSpecGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Produces a response in JSON format with a record for every path modified, including information on the type of the change and the number of lines added and removed.  #### Single commit spec  If the `spec` argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by `..` may be provided as the `spec`, e.g., `3a8b42..9ff173`. When two commits are provided and the `topic` query parameter is true, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the `topic` query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in `git diff`.
         * @summary Compare two commit diff stats
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;). 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {boolean} [ignoreWhitespace] Generate diffs that ignore whitespace
         * @param {boolean} [merge] This parameter is deprecated. The \&#39;topic\&#39; parameter should be used instead. The \&#39;merge\&#39; and \&#39;topic\&#39; parameters cannot be both used at the same time.  If true, the source commit is merged into the destination commit, and then a diffstat from the destination to the merge result is returned. If false, a simple \&#39;two dot\&#39; diffstat between the source and destination is returned. True if omitted.
         * @param {string} [path] Limit the diffstat to a particular file (this parameter can be repeated for multiple paths).
         * @param {boolean} [renames] Whether to perform rename detection, true if omitted.
         * @param {boolean} [topic] If true, returns 2-way \&#39;three-dot\&#39; diff. This is a diff between the source commit and the merge base of the source commit and the destination commit. If false, a simple \&#39;two dot\&#39; diff between the source and destination is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDiffstatSpecGet(repoSlug: string, spec: string, workspace: string, ignoreWhitespace?: boolean, merge?: boolean, path?: string, renames?: boolean, topic?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDiffstats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDiffstatSpecGet(repoSlug, spec, workspace, ignoreWhitespace, merge, path, renames, topic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugDiffstatSpecGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the best common ancestor between two commits, specified in a revspec of 2 commits (e.g. 3a8b42..9ff173).  If more than one best common ancestor exists, only one will be returned. It is unspecified which will be returned.
         * @summary Get the common ancestor between two commits
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} revspec A commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;). 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugMergeBaseRevspecGet(repoSlug: string, revspec: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Commit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugMergeBaseRevspecGet(repoSlug, revspec, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugMergeBaseRevspecGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Produces a raw patch for a single commit (diffed against its first parent), or a patch-series for a revspec of 2 commits (e.g. `3a8b42..9ff173` where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a patch series is returned for the commits on the source branch (`3a8b42` and its ancestors in our example).  While similar to diffs, patches:  * Have a commit header (username, commit message, etc) * Do not support the `path=foo/bar.py` query parameter  The raw patch is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is `text/plain`.
         * @summary Get a patch for two commits
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;). 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPatchSpecGet(repoSlug: string, spec: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPatchSpecGet(repoSlug, spec, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommitsApi.repositoriesWorkspaceRepoSlugPatchSpecGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommitsApi - factory interface
 */
export const CommitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommitsApiFp(configuration)
    return {
        /**
         * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: ``` curl --location \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001/annotations\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'[   {         \"external_id\": \"mysystem-annotation001\",         \"title\": \"Security scan report\",         \"annotation_type\": \"VULNERABILITY\",         \"summary\": \"This line represents a security threat.\",         \"severity\": \"HIGH\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",         \"line\": 42   },   {         \"external_id\": \"mySystem-annotation002\",         \"title\": \"Bug report\",         \"annotation_type\": \"BUG\",         \"result\": \"FAILED\",         \"summary\": \"This line might introduce a bug.\",         \"severity\": \"MEDIUM\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\",         \"line\": 13   } ]\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Bulk create or update annotations
         * @param {CommitsApiBulkCreateOrUpdateAnnotationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateOrUpdateAnnotations(requestParameters: CommitsApiBulkCreateOrUpdateAnnotationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ReportAnnotation>> {
            return localVarFp.bulkCreateOrUpdateAnnotations(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mySystem-001/annotations/mysystem-annotation001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"annotation_type\": \"VULNERABILITY\",     \"summary\": \"This line represents a security thread.\",     \"severity\": \"HIGH\",     \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",     \"line\": 42 }\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Create or update an annotation
         * @param {CommitsApiCreateOrUpdateAnnotationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateAnnotation(requestParameters: CommitsApiCreateOrUpdateAnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReportAnnotation> {
            return localVarFp.createOrUpdateAnnotation(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.annotationId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"details\": \"This pull request introduces 10 new dependency vulnerabilities.\",     \"report_type\": \"SECURITY\",     \"reporter\": \"mySystem\",     \"link\": \"http://www.mysystem.com/reports/001\",     \"result\": \"FAILED\",     \"data\": [         {             \"title\": \"Duration (seconds)\",             \"type\": \"DURATION\",             \"value\": 14         },         {             \"title\": \"Safe to merge?\",             \"type\": \"BOOLEAN\",             \"value\": false         }     ] }\' ```  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as \'Yes\' or \'No\'. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: `{\"text\": \"Link text here\", \"href\": \"https://link.to.annotation/in/external/tool\"}` | The value will be read as a JSON object containing the fields \"text\" and \"href\" and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Create or update a report
         * @param {CommitsApiCreateOrUpdateReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateReport(requestParameters: CommitsApiCreateOrUpdateReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<Report> {
            return localVarFp.createOrUpdateReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single Annotation matching the provided ID.
         * @summary Delete an annotation
         * @param {CommitsApiDeleteAnnotationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnotation(requestParameters: CommitsApiDeleteAnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAnnotation(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.annotationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single Report matching the provided ID.
         * @summary Delete a report
         * @param {CommitsApiDeleteReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport(requestParameters: CommitsApiDeleteReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single Annotation matching the provided ID.
         * @summary Get an annotation
         * @param {CommitsApiGetAnnotationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotation(requestParameters: CommitsApiGetAnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReportAnnotation> {
            return localVarFp.getAnnotation(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.annotationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of Annotations for a specified report.
         * @summary List annotations
         * @param {CommitsApiGetAnnotationsForReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotationsForReport(requestParameters: CommitsApiGetAnnotationsForReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAnnotations> {
            return localVarFp.getAnnotationsForReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single Report matching the provided ID.
         * @summary Get a report
         * @param {CommitsApiGetReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport(requestParameters: CommitsApiGetReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<Report> {
            return localVarFp.getReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of Reports linked to this commit.
         * @summary List reports
         * @param {CommitsApiGetReportsForCommitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsForCommit(requestParameters: CommitsApiGetReportsForCommitRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedReports> {
            return localVarFp.getReportsForCommit(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, options).then((request) => request(axios, basePath));
        },
        /**
         * Redact the authenticated user\'s approval of the specified commit.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
         * @summary Unapprove a commit
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitApproveDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitApproveDelete(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitApproveDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitCommitApproveDelete(requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Approve the specified commit as the authenticated user.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
         * @summary Approve a commit
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitApprovePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitApprovePost(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitApprovePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Participant> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitCommitApprovePost(requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified commit comment.  Note that deleting comments that have visible replies that point to them will not really delete the resource. This is to retain the integrity of the original comment tree. Instead, the `deleted` element is set to `true` and the content is blanked out. The comment will continue to be returned by the collections and self endpoints.
         * @summary Delete a commit comment
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete(requestParameters.commentId, requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified commit comment.
         * @summary Get a commit comment
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommitComment> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet(requestParameters.commentId, requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to update the contents of a comment. Only the content of the comment can be updated.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/7f71b5/comments/5728901 \\   -X PUT -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"One more thing!\"}\' ```
         * @summary Update a commit comment
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut(requestParameters.commentId, requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the commit\'s comments.  This includes both global and inline comments.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.
         * @summary List a commit\'s comments
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitCommentsGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedCommitComments> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitCommitCommentsGet(requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new comment on the specified commit.  To post a reply to an existing comment, include the `parent.id` field:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \\   -X POST -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"One more thing!\"},        \"parent\": {\"id\": 5728901}}\' ```
         * @summary Create comment for a commit
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitCommentsPost(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitCommitCommentsPost(requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified commit.
         * @summary Get a commit
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitCommitGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Commit> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitCommitGet(requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * These are the repository\'s commits. They are paginated and returned in reverse chronological order, similar to the output of `git log`. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to `git log --all`).  #### GET /repositories/{workspace}/{repo_slug}/commits/?exclude=master  Returns all commits in the repo that are not on master (similar to `git log --all ^master`).  #### GET /repositories/{workspace}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar  Returns all commits that are on refs `foo` or `bar`, but not on `fu` or `fubar` (similar to `git log foo bar ^fu ^fubar`).  An optional `path` parameter can be specified that will limit the results to commits that affect that path. `path` can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by `path`. It is important to note that if the `path` parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the \'next\' link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a `x-www-form-urlencoded` POST instead.
         * @summary List commits
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitsGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedChangeset> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitsGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Identical to `GET /repositories/{workspace}/{repo_slug}/commits`, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
         * @summary List commits with include/exclude
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitsPost(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedChangeset> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitsPost(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * These are the repository\'s commits. They are paginated and returned in reverse chronological order, similar to the output of `git log`. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/master  Returns all commits on ref `master` (similar to `git log master`).  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?include=foo&exclude=master  Returns all commits on ref `dev` or `foo`, except those that are reachable on `master` (similar to `git log dev foo ^master`).  An optional `path` parameter can be specified that will limit the results to commits that affect that path. `path` can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by `path`. It is important to note that if the `path` parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path=README.md&include=foo&include=bar&exclude=master  Returns all commits that are on refs `dev` or `foo` or `bar`, but not on `master` that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path=src/&include=foo&exclude=master  Returns all commits that are on refs `dev` or `foo`, but not on `master` that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the \'next\' link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a `x-www-form-urlencoded` POST instead.
         * @summary List commits for revision
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitsRevisionGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitsRevisionGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitsRevisionGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedChangeset> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitsRevisionGet(requestParameters.repoSlug, requestParameters.revision, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Identical to `GET /repositories/{workspace}/{repo_slug}/commits/{revision}`, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
         * @summary List commits for revision using include/exclude
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitsRevisionPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugCommitsRevisionPost(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitsRevisionPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedChangeset> {
            return localVarFp.repositoriesWorkspaceRepoSlugCommitsRevisionPost(requestParameters.repoSlug, requestParameters.revision, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Produces a raw git-style diff.  #### Single commit spec  If the `spec` argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by `..` may be provided as the `spec`, e.g., `3a8b42..9ff173`. When two commits are provided and the `topic` query parameter is true, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the `topic` query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in `git diff`.  #### Comparison to patches  While similar to patches, diffs:  * Don\'t have a commit header (username, commit message, etc) * Support the optional `path=foo/bar.py` query param to filter   the diff to just that one file diff  #### Response  The raw diff is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is `text/plain`.
         * @summary Compare two commits
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugDiffSpecGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDiffSpecGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugDiffSpecGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugDiffSpecGet(requestParameters.repoSlug, requestParameters.spec, requestParameters.workspace, requestParameters.context, requestParameters.path, requestParameters.ignoreWhitespace, requestParameters.binary, requestParameters.renames, requestParameters.merge, requestParameters.topic, options).then((request) => request(axios, basePath));
        },
        /**
         * Produces a response in JSON format with a record for every path modified, including information on the type of the change and the number of lines added and removed.  #### Single commit spec  If the `spec` argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by `..` may be provided as the `spec`, e.g., `3a8b42..9ff173`. When two commits are provided and the `topic` query parameter is true, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the `topic` query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in `git diff`.
         * @summary Compare two commit diff stats
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugDiffstatSpecGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDiffstatSpecGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugDiffstatSpecGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDiffstats> {
            return localVarFp.repositoriesWorkspaceRepoSlugDiffstatSpecGet(requestParameters.repoSlug, requestParameters.spec, requestParameters.workspace, requestParameters.ignoreWhitespace, requestParameters.merge, requestParameters.path, requestParameters.renames, requestParameters.topic, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the best common ancestor between two commits, specified in a revspec of 2 commits (e.g. 3a8b42..9ff173).  If more than one best common ancestor exists, only one will be returned. It is unspecified which will be returned.
         * @summary Get the common ancestor between two commits
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugMergeBaseRevspecGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugMergeBaseRevspecGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugMergeBaseRevspecGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Commit> {
            return localVarFp.repositoriesWorkspaceRepoSlugMergeBaseRevspecGet(requestParameters.repoSlug, requestParameters.revspec, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Produces a raw patch for a single commit (diffed against its first parent), or a patch-series for a revspec of 2 commits (e.g. `3a8b42..9ff173` where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a patch series is returned for the commits on the source branch (`3a8b42` and its ancestors in our example).  While similar to diffs, patches:  * Have a commit header (username, commit message, etc) * Do not support the `path=foo/bar.py` query parameter  The raw patch is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is `text/plain`.
         * @summary Get a patch for two commits
         * @param {CommitsApiRepositoriesWorkspaceRepoSlugPatchSpecGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPatchSpecGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugPatchSpecGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPatchSpecGet(requestParameters.repoSlug, requestParameters.spec, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommitsApi - interface
 */
export interface CommitsApiInterface {
    /**
     * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: ``` curl --location \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001/annotations\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'[   {         \"external_id\": \"mysystem-annotation001\",         \"title\": \"Security scan report\",         \"annotation_type\": \"VULNERABILITY\",         \"summary\": \"This line represents a security threat.\",         \"severity\": \"HIGH\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",         \"line\": 42   },   {         \"external_id\": \"mySystem-annotation002\",         \"title\": \"Bug report\",         \"annotation_type\": \"BUG\",         \"result\": \"FAILED\",         \"summary\": \"This line might introduce a bug.\",         \"severity\": \"MEDIUM\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\",         \"line\": 13   } ]\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @summary Bulk create or update annotations
     * @param {CommitsApiBulkCreateOrUpdateAnnotationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateOrUpdateAnnotations(requestParameters: CommitsApiBulkCreateOrUpdateAnnotationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ReportAnnotation>>;

    /**
     * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mySystem-001/annotations/mysystem-annotation001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"annotation_type\": \"VULNERABILITY\",     \"summary\": \"This line represents a security thread.\",     \"severity\": \"HIGH\",     \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",     \"line\": 42 }\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @summary Create or update an annotation
     * @param {CommitsApiCreateOrUpdateAnnotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateAnnotation(requestParameters: CommitsApiCreateOrUpdateAnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReportAnnotation>;

    /**
     * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"details\": \"This pull request introduces 10 new dependency vulnerabilities.\",     \"report_type\": \"SECURITY\",     \"reporter\": \"mySystem\",     \"link\": \"http://www.mysystem.com/reports/001\",     \"result\": \"FAILED\",     \"data\": [         {             \"title\": \"Duration (seconds)\",             \"type\": \"DURATION\",             \"value\": 14         },         {             \"title\": \"Safe to merge?\",             \"type\": \"BOOLEAN\",             \"value\": false         }     ] }\' ```  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as \'Yes\' or \'No\'. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: `{\"text\": \"Link text here\", \"href\": \"https://link.to.annotation/in/external/tool\"}` | The value will be read as a JSON object containing the fields \"text\" and \"href\" and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @summary Create or update a report
     * @param {CommitsApiCreateOrUpdateReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateReport(requestParameters: CommitsApiCreateOrUpdateReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<Report>;

    /**
     * Deletes a single Annotation matching the provided ID.
     * @summary Delete an annotation
     * @param {CommitsApiDeleteAnnotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAnnotation(requestParameters: CommitsApiDeleteAnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Deletes a single Report matching the provided ID.
     * @summary Delete a report
     * @param {CommitsApiDeleteReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteReport(requestParameters: CommitsApiDeleteReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a single Annotation matching the provided ID.
     * @summary Get an annotation
     * @param {CommitsApiGetAnnotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnnotation(requestParameters: CommitsApiGetAnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReportAnnotation>;

    /**
     * Returns a paginated list of Annotations for a specified report.
     * @summary List annotations
     * @param {CommitsApiGetAnnotationsForReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnnotationsForReport(requestParameters: CommitsApiGetAnnotationsForReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAnnotations>;

    /**
     * Returns a single Report matching the provided ID.
     * @summary Get a report
     * @param {CommitsApiGetReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReport(requestParameters: CommitsApiGetReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<Report>;

    /**
     * Returns a paginated list of Reports linked to this commit.
     * @summary List reports
     * @param {CommitsApiGetReportsForCommitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportsForCommit(requestParameters: CommitsApiGetReportsForCommitRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedReports>;

    /**
     * Redact the authenticated user\'s approval of the specified commit.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
     * @summary Unapprove a commit
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitApproveDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitCommitApproveDelete(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitApproveDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Approve the specified commit as the authenticated user.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
     * @summary Approve a commit
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitApprovePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitCommitApprovePost(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitApprovePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Participant>;

    /**
     * Deletes the specified commit comment.  Note that deleting comments that have visible replies that point to them will not really delete the resource. This is to retain the integrity of the original comment tree. Instead, the `deleted` element is set to `true` and the content is blanked out. The comment will continue to be returned by the collections and self endpoints.
     * @summary Delete a commit comment
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the specified commit comment.
     * @summary Get a commit comment
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommitComment>;

    /**
     * Used to update the contents of a comment. Only the content of the comment can be updated.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/7f71b5/comments/5728901 \\   -X PUT -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"One more thing!\"}\' ```
     * @summary Update a commit comment
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the commit\'s comments.  This includes both global and inline comments.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.
     * @summary List a commit\'s comments
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitCommitCommentsGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedCommitComments>;

    /**
     * Creates new comment on the specified commit.  To post a reply to an existing comment, include the `parent.id` field:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \\   -X POST -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"One more thing!\"},        \"parent\": {\"id\": 5728901}}\' ```
     * @summary Create comment for a commit
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitCommitCommentsPost(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the specified commit.
     * @summary Get a commit
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitCommitGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Commit>;

    /**
     * These are the repository\'s commits. They are paginated and returned in reverse chronological order, similar to the output of `git log`. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to `git log --all`).  #### GET /repositories/{workspace}/{repo_slug}/commits/?exclude=master  Returns all commits in the repo that are not on master (similar to `git log --all ^master`).  #### GET /repositories/{workspace}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar  Returns all commits that are on refs `foo` or `bar`, but not on `fu` or `fubar` (similar to `git log foo bar ^fu ^fubar`).  An optional `path` parameter can be specified that will limit the results to commits that affect that path. `path` can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by `path`. It is important to note that if the `path` parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the \'next\' link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a `x-www-form-urlencoded` POST instead.
     * @summary List commits
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitsGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedChangeset>;

    /**
     * Identical to `GET /repositories/{workspace}/{repo_slug}/commits`, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
     * @summary List commits with include/exclude
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitsPost(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedChangeset>;

    /**
     * These are the repository\'s commits. They are paginated and returned in reverse chronological order, similar to the output of `git log`. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/master  Returns all commits on ref `master` (similar to `git log master`).  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?include=foo&exclude=master  Returns all commits on ref `dev` or `foo`, except those that are reachable on `master` (similar to `git log dev foo ^master`).  An optional `path` parameter can be specified that will limit the results to commits that affect that path. `path` can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by `path`. It is important to note that if the `path` parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path=README.md&include=foo&include=bar&exclude=master  Returns all commits that are on refs `dev` or `foo` or `bar`, but not on `master` that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path=src/&include=foo&exclude=master  Returns all commits that are on refs `dev` or `foo`, but not on `master` that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the \'next\' link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a `x-www-form-urlencoded` POST instead.
     * @summary List commits for revision
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitsRevisionGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitsRevisionGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitsRevisionGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedChangeset>;

    /**
     * Identical to `GET /repositories/{workspace}/{repo_slug}/commits/{revision}`, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
     * @summary List commits for revision using include/exclude
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitsRevisionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugCommitsRevisionPost(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitsRevisionPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedChangeset>;

    /**
     * Produces a raw git-style diff.  #### Single commit spec  If the `spec` argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by `..` may be provided as the `spec`, e.g., `3a8b42..9ff173`. When two commits are provided and the `topic` query parameter is true, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the `topic` query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in `git diff`.  #### Comparison to patches  While similar to patches, diffs:  * Don\'t have a commit header (username, commit message, etc) * Support the optional `path=foo/bar.py` query param to filter   the diff to just that one file diff  #### Response  The raw diff is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is `text/plain`.
     * @summary Compare two commits
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugDiffSpecGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDiffSpecGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugDiffSpecGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Produces a response in JSON format with a record for every path modified, including information on the type of the change and the number of lines added and removed.  #### Single commit spec  If the `spec` argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by `..` may be provided as the `spec`, e.g., `3a8b42..9ff173`. When two commits are provided and the `topic` query parameter is true, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the `topic` query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in `git diff`.
     * @summary Compare two commit diff stats
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugDiffstatSpecGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDiffstatSpecGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugDiffstatSpecGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDiffstats>;

    /**
     * Returns the best common ancestor between two commits, specified in a revspec of 2 commits (e.g. 3a8b42..9ff173).  If more than one best common ancestor exists, only one will be returned. It is unspecified which will be returned.
     * @summary Get the common ancestor between two commits
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugMergeBaseRevspecGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugMergeBaseRevspecGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugMergeBaseRevspecGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Commit>;

    /**
     * Produces a raw patch for a single commit (diffed against its first parent), or a patch-series for a revspec of 2 commits (e.g. `3a8b42..9ff173` where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a patch series is returned for the commits on the source branch (`3a8b42` and its ancestors in our example).  While similar to diffs, patches:  * Have a commit header (username, commit message, etc) * Do not support the `path=foo/bar.py` query parameter  The raw patch is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is `text/plain`.
     * @summary Get a patch for two commits
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugPatchSpecGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPatchSpecGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugPatchSpecGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for bulkCreateOrUpdateAnnotations operation in CommitsApi.
 */
export interface CommitsApiBulkCreateOrUpdateAnnotationsRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit for which to retrieve reports.
     */
    readonly commit: string

    /**
     * Uuid or external-if of the report for which to get annotations for.
     */
    readonly reportId: string

    /**
     * The annotations to create or update
     */
    readonly body: Array<ReportAnnotation>
}

/**
 * Request parameters for createOrUpdateAnnotation operation in CommitsApi.
 */
export interface CommitsApiCreateOrUpdateAnnotationRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit the report belongs to.
     */
    readonly commit: string

    /**
     * Either the uuid or external-id of the report.
     */
    readonly reportId: string

    /**
     * Either the uuid or external-id of the annotation.
     */
    readonly annotationId: string

    /**
     * The annotation to create or update
     */
    readonly body: ReportAnnotation
}

/**
 * Request parameters for createOrUpdateReport operation in CommitsApi.
 */
export interface CommitsApiCreateOrUpdateReportRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit the report belongs to.
     */
    readonly commit: string

    /**
     * Either the uuid or external-id of the report.
     */
    readonly reportId: string

    /**
     * The report to create or update
     */
    readonly body: Report
}

/**
 * Request parameters for deleteAnnotation operation in CommitsApi.
 */
export interface CommitsApiDeleteAnnotationRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit the annotation belongs to.
     */
    readonly commit: string

    /**
     * Either the uuid or external-id of the annotation.
     */
    readonly reportId: string

    /**
     * Either the uuid or external-id of the annotation.
     */
    readonly annotationId: string
}

/**
 * Request parameters for deleteReport operation in CommitsApi.
 */
export interface CommitsApiDeleteReportRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit the report belongs to.
     */
    readonly commit: string

    /**
     * Either the uuid or external-id of the report.
     */
    readonly reportId: string
}

/**
 * Request parameters for getAnnotation operation in CommitsApi.
 */
export interface CommitsApiGetAnnotationRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit the report belongs to.
     */
    readonly commit: string

    /**
     * Either the uuid or external-id of the report.
     */
    readonly reportId: string

    /**
     * Either the uuid or external-id of the annotation.
     */
    readonly annotationId: string
}

/**
 * Request parameters for getAnnotationsForReport operation in CommitsApi.
 */
export interface CommitsApiGetAnnotationsForReportRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit for which to retrieve reports.
     */
    readonly commit: string

    /**
     * Uuid or external-if of the report for which to get annotations for.
     */
    readonly reportId: string
}

/**
 * Request parameters for getReport operation in CommitsApi.
 */
export interface CommitsApiGetReportRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit the report belongs to.
     */
    readonly commit: string

    /**
     * Either the uuid or external-id of the report.
     */
    readonly reportId: string
}

/**
 * Request parameters for getReportsForCommit operation in CommitsApi.
 */
export interface CommitsApiGetReportsForCommitRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit for which to retrieve reports.
     */
    readonly commit: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitCommitApproveDelete operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitApproveDeleteRequest {
    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitCommitApprovePost operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitApprovePostRequest {
    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteRequest {
    /**
     * The id of the comment.
     */
    readonly commentId: number

    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetRequest {
    /**
     * The id of the comment.
     */
    readonly commentId: number

    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutRequest {
    /**
     * The id of the comment.
     */
    readonly commentId: number

    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The updated comment.
     */
    readonly body: CommitComment
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitCommitCommentsGet operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsGetRequest {
    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
     */
    readonly q?: string

    /**
     * Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
     */
    readonly sort?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitCommitCommentsPost operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsPostRequest {
    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The specified comment.
     */
    readonly body: CommitComment
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitCommitGet operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitGetRequest {
    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitsGet operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugCommitsGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitsPost operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugCommitsPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitsRevisionGet operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugCommitsRevisionGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * A commit SHA1 or ref name.
     */
    readonly revision: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugCommitsRevisionPost operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugCommitsRevisionPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * A commit SHA1 or ref name.
     */
    readonly revision: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDiffSpecGet operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugDiffSpecGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;). 
     */
    readonly spec: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * Generate diffs with &lt;n&gt; lines of context instead of the usual three.
     */
    readonly context?: number

    /**
     * Limit the diff to a particular file (this parameter can be repeated for multiple paths).
     */
    readonly path?: string

    /**
     * Generate diffs that ignore whitespace.
     */
    readonly ignoreWhitespace?: boolean

    /**
     * Generate diffs that include binary files, true if omitted.
     */
    readonly binary?: boolean

    /**
     * Whether to perform rename detection, true if omitted.
     */
    readonly renames?: boolean

    /**
     * This parameter is deprecated. The \&#39;topic\&#39; parameter should be used instead. The \&#39;merge\&#39; and \&#39;topic\&#39; parameters cannot be both used at the same time.  If true, the source commit is merged into the destination commit, and then a diff from the destination to the merge result is returned. If false, a simple \&#39;two dot\&#39; diff between the source and destination is returned. True if omitted.
     */
    readonly merge?: boolean

    /**
     * If true, returns 2-way \&#39;three-dot\&#39; diff. This is a diff between the source commit and the merge base of the source commit and the destination commit. If false, a simple \&#39;two dot\&#39; diff between the source and destination is returned.
     */
    readonly topic?: boolean
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDiffstatSpecGet operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugDiffstatSpecGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;). 
     */
    readonly spec: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * Generate diffs that ignore whitespace
     */
    readonly ignoreWhitespace?: boolean

    /**
     * This parameter is deprecated. The \&#39;topic\&#39; parameter should be used instead. The \&#39;merge\&#39; and \&#39;topic\&#39; parameters cannot be both used at the same time.  If true, the source commit is merged into the destination commit, and then a diffstat from the destination to the merge result is returned. If false, a simple \&#39;two dot\&#39; diffstat between the source and destination is returned. True if omitted.
     */
    readonly merge?: boolean

    /**
     * Limit the diffstat to a particular file (this parameter can be repeated for multiple paths).
     */
    readonly path?: string

    /**
     * Whether to perform rename detection, true if omitted.
     */
    readonly renames?: boolean

    /**
     * If true, returns 2-way \&#39;three-dot\&#39; diff. This is a diff between the source commit and the merge base of the source commit and the destination commit. If false, a simple \&#39;two dot\&#39; diff between the source and destination is returned.
     */
    readonly topic?: boolean
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugMergeBaseRevspecGet operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugMergeBaseRevspecGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * A commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;). 
     */
    readonly revspec: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPatchSpecGet operation in CommitsApi.
 */
export interface CommitsApiRepositoriesWorkspaceRepoSlugPatchSpecGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;). 
     */
    readonly spec: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * CommitsApi - object-oriented interface
 */
export class CommitsApi extends BaseAPI implements CommitsApiInterface {
    /**
     * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: ``` curl --location \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001/annotations\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'[   {         \"external_id\": \"mysystem-annotation001\",         \"title\": \"Security scan report\",         \"annotation_type\": \"VULNERABILITY\",         \"summary\": \"This line represents a security threat.\",         \"severity\": \"HIGH\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",         \"line\": 42   },   {         \"external_id\": \"mySystem-annotation002\",         \"title\": \"Bug report\",         \"annotation_type\": \"BUG\",         \"result\": \"FAILED\",         \"summary\": \"This line might introduce a bug.\",         \"severity\": \"MEDIUM\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\",         \"line\": 13   } ]\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @summary Bulk create or update annotations
     * @param {CommitsApiBulkCreateOrUpdateAnnotationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public bulkCreateOrUpdateAnnotations(requestParameters: CommitsApiBulkCreateOrUpdateAnnotationsRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).bulkCreateOrUpdateAnnotations(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mySystem-001/annotations/mysystem-annotation001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"annotation_type\": \"VULNERABILITY\",     \"summary\": \"This line represents a security thread.\",     \"severity\": \"HIGH\",     \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",     \"line\": 42 }\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @summary Create or update an annotation
     * @param {CommitsApiCreateOrUpdateAnnotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createOrUpdateAnnotation(requestParameters: CommitsApiCreateOrUpdateAnnotationRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).createOrUpdateAnnotation(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.annotationId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"details\": \"This pull request introduces 10 new dependency vulnerabilities.\",     \"report_type\": \"SECURITY\",     \"reporter\": \"mySystem\",     \"link\": \"http://www.mysystem.com/reports/001\",     \"result\": \"FAILED\",     \"data\": [         {             \"title\": \"Duration (seconds)\",             \"type\": \"DURATION\",             \"value\": 14         },         {             \"title\": \"Safe to merge?\",             \"type\": \"BOOLEAN\",             \"value\": false         }     ] }\' ```  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as \'Yes\' or \'No\'. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: `{\"text\": \"Link text here\", \"href\": \"https://link.to.annotation/in/external/tool\"}` | The value will be read as a JSON object containing the fields \"text\" and \"href\" and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @summary Create or update a report
     * @param {CommitsApiCreateOrUpdateReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createOrUpdateReport(requestParameters: CommitsApiCreateOrUpdateReportRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).createOrUpdateReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single Annotation matching the provided ID.
     * @summary Delete an annotation
     * @param {CommitsApiDeleteAnnotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAnnotation(requestParameters: CommitsApiDeleteAnnotationRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).deleteAnnotation(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.annotationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single Report matching the provided ID.
     * @summary Delete a report
     * @param {CommitsApiDeleteReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteReport(requestParameters: CommitsApiDeleteReportRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).deleteReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single Annotation matching the provided ID.
     * @summary Get an annotation
     * @param {CommitsApiGetAnnotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAnnotation(requestParameters: CommitsApiGetAnnotationRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).getAnnotation(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.annotationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of Annotations for a specified report.
     * @summary List annotations
     * @param {CommitsApiGetAnnotationsForReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAnnotationsForReport(requestParameters: CommitsApiGetAnnotationsForReportRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).getAnnotationsForReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single Report matching the provided ID.
     * @summary Get a report
     * @param {CommitsApiGetReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getReport(requestParameters: CommitsApiGetReportRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).getReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of Reports linked to this commit.
     * @summary List reports
     * @param {CommitsApiGetReportsForCommitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getReportsForCommit(requestParameters: CommitsApiGetReportsForCommitRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).getReportsForCommit(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redact the authenticated user\'s approval of the specified commit.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
     * @summary Unapprove a commit
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitApproveDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitCommitApproveDelete(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitApproveDeleteRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitCommitApproveDelete(requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Approve the specified commit as the authenticated user.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
     * @summary Approve a commit
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitApprovePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitCommitApprovePost(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitApprovePostRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitCommitApprovePost(requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified commit comment.  Note that deleting comments that have visible replies that point to them will not really delete the resource. This is to retain the integrity of the original comment tree. Instead, the `deleted` element is set to `true` and the content is blanked out. The comment will continue to be returned by the collections and self endpoints.
     * @summary Delete a commit comment
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete(requestParameters.commentId, requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified commit comment.
     * @summary Get a commit comment
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet(requestParameters.commentId, requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to update the contents of a comment. Only the content of the comment can be updated.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/7f71b5/comments/5728901 \\   -X PUT -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"One more thing!\"}\' ```
     * @summary Update a commit comment
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut(requestParameters.commentId, requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the commit\'s comments.  This includes both global and inline comments.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.
     * @summary List a commit\'s comments
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitCommitCommentsGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsGetRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitCommitCommentsGet(requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates new comment on the specified commit.  To post a reply to an existing comment, include the `parent.id` field:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \\   -X POST -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"One more thing!\"},        \"parent\": {\"id\": 5728901}}\' ```
     * @summary Create comment for a commit
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitCommitCommentsPost(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitCommentsPostRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitCommitCommentsPost(requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified commit.
     * @summary Get a commit
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitCommitGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitCommitGetRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitCommitGet(requestParameters.commit, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * These are the repository\'s commits. They are paginated and returned in reverse chronological order, similar to the output of `git log`. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to `git log --all`).  #### GET /repositories/{workspace}/{repo_slug}/commits/?exclude=master  Returns all commits in the repo that are not on master (similar to `git log --all ^master`).  #### GET /repositories/{workspace}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar  Returns all commits that are on refs `foo` or `bar`, but not on `fu` or `fubar` (similar to `git log foo bar ^fu ^fubar`).  An optional `path` parameter can be specified that will limit the results to commits that affect that path. `path` can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by `path`. It is important to note that if the `path` parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the \'next\' link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a `x-www-form-urlencoded` POST instead.
     * @summary List commits
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitsGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitsGetRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitsGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Identical to `GET /repositories/{workspace}/{repo_slug}/commits`, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
     * @summary List commits with include/exclude
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitsPost(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitsPostRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitsPost(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * These are the repository\'s commits. They are paginated and returned in reverse chronological order, similar to the output of `git log`. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/master  Returns all commits on ref `master` (similar to `git log master`).  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?include=foo&exclude=master  Returns all commits on ref `dev` or `foo`, except those that are reachable on `master` (similar to `git log dev foo ^master`).  An optional `path` parameter can be specified that will limit the results to commits that affect that path. `path` can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by `path`. It is important to note that if the `path` parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path=README.md&include=foo&include=bar&exclude=master  Returns all commits that are on refs `dev` or `foo` or `bar`, but not on `master` that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path=src/&include=foo&exclude=master  Returns all commits that are on refs `dev` or `foo`, but not on `master` that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the \'next\' link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a `x-www-form-urlencoded` POST instead.
     * @summary List commits for revision
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitsRevisionGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitsRevisionGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitsRevisionGetRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitsRevisionGet(requestParameters.repoSlug, requestParameters.revision, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Identical to `GET /repositories/{workspace}/{repo_slug}/commits/{revision}`, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
     * @summary List commits for revision using include/exclude
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugCommitsRevisionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugCommitsRevisionPost(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugCommitsRevisionPostRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugCommitsRevisionPost(requestParameters.repoSlug, requestParameters.revision, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Produces a raw git-style diff.  #### Single commit spec  If the `spec` argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by `..` may be provided as the `spec`, e.g., `3a8b42..9ff173`. When two commits are provided and the `topic` query parameter is true, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the `topic` query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in `git diff`.  #### Comparison to patches  While similar to patches, diffs:  * Don\'t have a commit header (username, commit message, etc) * Support the optional `path=foo/bar.py` query param to filter   the diff to just that one file diff  #### Response  The raw diff is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is `text/plain`.
     * @summary Compare two commits
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugDiffSpecGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDiffSpecGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugDiffSpecGetRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDiffSpecGet(requestParameters.repoSlug, requestParameters.spec, requestParameters.workspace, requestParameters.context, requestParameters.path, requestParameters.ignoreWhitespace, requestParameters.binary, requestParameters.renames, requestParameters.merge, requestParameters.topic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Produces a response in JSON format with a record for every path modified, including information on the type of the change and the number of lines added and removed.  #### Single commit spec  If the `spec` argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by `..` may be provided as the `spec`, e.g., `3a8b42..9ff173`. When two commits are provided and the `topic` query parameter is true, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the `topic` query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in `git diff`.
     * @summary Compare two commit diff stats
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugDiffstatSpecGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDiffstatSpecGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugDiffstatSpecGetRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDiffstatSpecGet(requestParameters.repoSlug, requestParameters.spec, requestParameters.workspace, requestParameters.ignoreWhitespace, requestParameters.merge, requestParameters.path, requestParameters.renames, requestParameters.topic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the best common ancestor between two commits, specified in a revspec of 2 commits (e.g. 3a8b42..9ff173).  If more than one best common ancestor exists, only one will be returned. It is unspecified which will be returned.
     * @summary Get the common ancestor between two commits
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugMergeBaseRevspecGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugMergeBaseRevspecGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugMergeBaseRevspecGetRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugMergeBaseRevspecGet(requestParameters.repoSlug, requestParameters.revspec, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Produces a raw patch for a single commit (diffed against its first parent), or a patch-series for a revspec of 2 commits (e.g. `3a8b42..9ff173` where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a patch series is returned for the commits on the source branch (`3a8b42` and its ancestors in our example).  While similar to diffs, patches:  * Have a commit header (username, commit message, etc) * Do not support the `path=foo/bar.py` query parameter  The raw patch is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is `text/plain`.
     * @summary Get a patch for two commits
     * @param {CommitsApiRepositoriesWorkspaceRepoSlugPatchSpecGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPatchSpecGet(requestParameters: CommitsApiRepositoriesWorkspaceRepoSlugPatchSpecGetRequest, options?: RawAxiosRequestConfig) {
        return CommitsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPatchSpecGet(requestParameters.repoSlug, requestParameters.spec, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeploymentsApi - axios parameter creator
 */
export const DeploymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an environment.
         * @summary Create an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {DeploymentEnvironment} body The environment to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment: async (workspace: string, repoSlug: string, body: DeploymentEnvironment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createEnvironment', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('createEnvironment', 'repoSlug', repoSlug)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createEnvironment', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/environments`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an environment
         * @summary Delete an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} environmentUuid The environment UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentForRepository: async (workspace: string, repoSlug: string, environmentUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteEnvironmentForRepository', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deleteEnvironmentForRepository', 'repoSlug', repoSlug)
            // verify required parameter 'environmentUuid' is not null or undefined
            assertParamExists('deleteEnvironmentForRepository', 'environmentUuid', environmentUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/environments/{environment_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"environment_uuid"}}`, encodeURIComponent(String(environmentUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a deployment
         * @summary Get a deployment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} deploymentUuid The deployment UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentForRepository: async (workspace: string, repoSlug: string, deploymentUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getDeploymentForRepository', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getDeploymentForRepository', 'repoSlug', repoSlug)
            // verify required parameter 'deploymentUuid' is not null or undefined
            assertParamExists('getDeploymentForRepository', 'deploymentUuid', deploymentUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/deployments/{deployment_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"deployment_uuid"}}`, encodeURIComponent(String(deploymentUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find deployments
         * @summary List deployments
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentsForRepository: async (workspace: string, repoSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getDeploymentsForRepository', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getDeploymentsForRepository', 'repoSlug', repoSlug)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/deployments`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an environment
         * @summary Get an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} environmentUuid The environment UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentForRepository: async (workspace: string, repoSlug: string, environmentUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getEnvironmentForRepository', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getEnvironmentForRepository', 'repoSlug', repoSlug)
            // verify required parameter 'environmentUuid' is not null or undefined
            assertParamExists('getEnvironmentForRepository', 'environmentUuid', environmentUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/environments/{environment_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"environment_uuid"}}`, encodeURIComponent(String(environmentUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find environments
         * @summary List environments
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentsForRepository: async (workspace: string, repoSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getEnvironmentsForRepository', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getEnvironmentsForRepository', 'repoSlug', repoSlug)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/environments`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all deploy-keys belonging to a repository.
         * @summary List repository deploy keys
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDeployKeysGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDeployKeysGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDeployKeysGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/deploy-keys`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository", "repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This deletes a deploy key from a repository.
         * @summary Delete a repository deploy key
         * @param {string} keyId The key ID matching the deploy key.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete: async (keyId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete', 'keyId', keyId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/deploy-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository", "repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the deploy key belonging to a specific key.
         * @summary Get a repository deploy key
         * @param {string} keyId The key ID matching the deploy key.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet: async (keyId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet', 'keyId', keyId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/deploy-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository", "repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new deploy key in a repository.  The same key needs to be passed in but the comment and label can change.  Example: ``` $ curl -X PUT \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234 -d \\ \'{     \"label\": \"newlabel\",     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 newcomment\", }\' ```
         * @summary Update a repository deploy key
         * @param {string} keyId The key ID matching the deploy key.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut: async (keyId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut', 'keyId', keyId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/deploy-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository", "repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new deploy key in a repository. Note: If authenticating a deploy key with an OAuth consumer, any changes to the OAuth consumer will subsequently invalidate the deploy key.   Example: ``` $ curl -X POST \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys -d \\ \'{     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8\",     \"label\": \"mydeploykey\" }\' ```
         * @summary Add a repository deploy key
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDeployKeysPost: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDeployKeysPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDeployKeysPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/deploy-keys`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository", "repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an environment
         * @summary Update an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} environmentUuid The environment UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironmentForRepository: async (workspace: string, repoSlug: string, environmentUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateEnvironmentForRepository', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('updateEnvironmentForRepository', 'repoSlug', repoSlug)
            // verify required parameter 'environmentUuid' is not null or undefined
            assertParamExists('updateEnvironmentForRepository', 'environmentUuid', environmentUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/environments/{environment_uuid}/changes`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"environment_uuid"}}`, encodeURIComponent(String(environmentUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all deploy keys belonging to a project.
         * @summary List project deploy keys
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDeployKeysGet: async (projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDeployKeysGet', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDeployKeysGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/deploy-keys`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project", "project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This deletes a deploy key from a project.
         * @summary Delete a deploy key from a project
         * @param {string} keyId The key ID matching the project deploy key.
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDelete: async (keyId: string, projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDelete', 'keyId', keyId)
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDelete', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDelete', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/deploy-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)))
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project", "project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the deploy key belonging to a specific key ID.
         * @summary Get a project deploy key
         * @param {string} keyId The key ID matching the project deploy key.
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGet: async (keyId: string, projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGet', 'keyId', keyId)
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGet', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/deploy-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)))
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project", "project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new deploy key in a project.  Example: ``` $ curl -X POST \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/workspaces/standard/projects/TEST_PROJECT/deploy-keys/ -d \\ \'{     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8\",     \"label\": \"mydeploykey\" }\' ```
         * @summary Create a project deploy key
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDeployKeysPost: async (projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDeployKeysPost', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDeployKeysPost', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/deploy-keys`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project", "project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentsApi - functional programming interface
 */
export const DeploymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an environment.
         * @summary Create an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {DeploymentEnvironment} body The environment to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironment(workspace: string, repoSlug: string, body: DeploymentEnvironment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentEnvironment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(workspace, repoSlug, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.createEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an environment
         * @summary Delete an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} environmentUuid The environment UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironmentForRepository(workspace: string, repoSlug: string, environmentUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironmentForRepository(workspace, repoSlug, environmentUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deleteEnvironmentForRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a deployment
         * @summary Get a deployment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} deploymentUuid The deployment UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentForRepository(workspace: string, repoSlug: string, deploymentUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deployment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentForRepository(workspace, repoSlug, deploymentUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.getDeploymentForRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find deployments
         * @summary List deployments
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentsForRepository(workspace: string, repoSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDeployments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentsForRepository(workspace, repoSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.getDeploymentsForRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an environment
         * @summary Get an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} environmentUuid The environment UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentForRepository(workspace: string, repoSlug: string, environmentUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentEnvironment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentForRepository(workspace, repoSlug, environmentUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.getEnvironmentForRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find environments
         * @summary List environments
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentsForRepository(workspace: string, repoSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedEnvironments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentsForRepository(workspace, repoSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.getEnvironmentsForRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all deploy-keys belonging to a repository.
         * @summary List repository deploy keys
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDeployKeysGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDeployKeys>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDeployKeysGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.repositoriesWorkspaceRepoSlugDeployKeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This deletes a deploy key from a repository.
         * @summary Delete a repository deploy key
         * @param {string} keyId The key ID matching the deploy key.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete(keyId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete(keyId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the deploy key belonging to a specific key.
         * @summary Get a repository deploy key
         * @param {string} keyId The key ID matching the deploy key.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet(keyId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet(keyId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new deploy key in a repository.  The same key needs to be passed in but the comment and label can change.  Example: ``` $ curl -X PUT \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234 -d \\ \'{     \"label\": \"newlabel\",     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 newcomment\", }\' ```
         * @summary Update a repository deploy key
         * @param {string} keyId The key ID matching the deploy key.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut(keyId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut(keyId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new deploy key in a repository. Note: If authenticating a deploy key with an OAuth consumer, any changes to the OAuth consumer will subsequently invalidate the deploy key.   Example: ``` $ curl -X POST \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys -d \\ \'{     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8\",     \"label\": \"mydeploykey\" }\' ```
         * @summary Add a repository deploy key
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDeployKeysPost(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDeployKeysPost(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.repositoriesWorkspaceRepoSlugDeployKeysPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an environment
         * @summary Update an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} environmentUuid The environment UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnvironmentForRepository(workspace: string, repoSlug: string, environmentUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnvironmentForRepository(workspace, repoSlug, environmentUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.updateEnvironmentForRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all deploy keys belonging to a project.
         * @summary List project deploy keys
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyDeployKeysGet(projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProjectDeployKeys>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyDeployKeysGet(projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.workspacesWorkspaceProjectsProjectKeyDeployKeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This deletes a deploy key from a project.
         * @summary Delete a deploy key from a project
         * @param {string} keyId The key ID matching the project deploy key.
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDelete(keyId: string, projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDelete(keyId, projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the deploy key belonging to a specific key ID.
         * @summary Get a project deploy key
         * @param {string} keyId The key ID matching the project deploy key.
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGet(keyId: string, projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeployKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGet(keyId, projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new deploy key in a project.  Example: ``` $ curl -X POST \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/workspaces/standard/projects/TEST_PROJECT/deploy-keys/ -d \\ \'{     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8\",     \"label\": \"mydeploykey\" }\' ```
         * @summary Create a project deploy key
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyDeployKeysPost(projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeployKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyDeployKeysPost(projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.workspacesWorkspaceProjectsProjectKeyDeployKeysPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeploymentsApi - factory interface
 */
export const DeploymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentsApiFp(configuration)
    return {
        /**
         * Create an environment.
         * @summary Create an environment
         * @param {DeploymentsApiCreateEnvironmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment(requestParameters: DeploymentsApiCreateEnvironmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentEnvironment> {
            return localVarFp.createEnvironment(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an environment
         * @summary Delete an environment
         * @param {DeploymentsApiDeleteEnvironmentForRepositoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentForRepository(requestParameters: DeploymentsApiDeleteEnvironmentForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEnvironmentForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.environmentUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a deployment
         * @summary Get a deployment
         * @param {DeploymentsApiGetDeploymentForRepositoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentForRepository(requestParameters: DeploymentsApiGetDeploymentForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Deployment> {
            return localVarFp.getDeploymentForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.deploymentUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Find deployments
         * @summary List deployments
         * @param {DeploymentsApiGetDeploymentsForRepositoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentsForRepository(requestParameters: DeploymentsApiGetDeploymentsForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDeployments> {
            return localVarFp.getDeploymentsForRepository(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an environment
         * @summary Get an environment
         * @param {DeploymentsApiGetEnvironmentForRepositoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentForRepository(requestParameters: DeploymentsApiGetEnvironmentForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentEnvironment> {
            return localVarFp.getEnvironmentForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.environmentUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Find environments
         * @summary List environments
         * @param {DeploymentsApiGetEnvironmentsForRepositoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentsForRepository(requestParameters: DeploymentsApiGetEnvironmentsForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedEnvironments> {
            return localVarFp.getEnvironmentsForRepository(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all deploy-keys belonging to a repository.
         * @summary List repository deploy keys
         * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDeployKeysGet(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDeployKeys> {
            return localVarFp.repositoriesWorkspaceRepoSlugDeployKeysGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * This deletes a deploy key from a repository.
         * @summary Delete a repository deploy key
         * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete(requestParameters.keyId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the deploy key belonging to a specific key.
         * @summary Get a repository deploy key
         * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeployKey> {
            return localVarFp.repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet(requestParameters.keyId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new deploy key in a repository.  The same key needs to be passed in but the comment and label can change.  Example: ``` $ curl -X PUT \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234 -d \\ \'{     \"label\": \"newlabel\",     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 newcomment\", }\' ```
         * @summary Update a repository deploy key
         * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeployKey> {
            return localVarFp.repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut(requestParameters.keyId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new deploy key in a repository. Note: If authenticating a deploy key with an OAuth consumer, any changes to the OAuth consumer will subsequently invalidate the deploy key.   Example: ``` $ curl -X POST \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys -d \\ \'{     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8\",     \"label\": \"mydeploykey\" }\' ```
         * @summary Add a repository deploy key
         * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDeployKeysPost(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeployKey> {
            return localVarFp.repositoriesWorkspaceRepoSlugDeployKeysPost(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an environment
         * @summary Update an environment
         * @param {DeploymentsApiUpdateEnvironmentForRepositoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironmentForRepository(requestParameters: DeploymentsApiUpdateEnvironmentForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateEnvironmentForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.environmentUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all deploy keys belonging to a project.
         * @summary List project deploy keys
         * @param {DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDeployKeysGet(requestParameters: DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProjectDeployKeys> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyDeployKeysGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * This deletes a deploy key from a project.
         * @summary Delete a deploy key from a project
         * @param {DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDelete(requestParameters: DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDelete(requestParameters.keyId, requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the deploy key belonging to a specific key ID.
         * @summary Get a project deploy key
         * @param {DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGet(requestParameters: DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectDeployKey> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGet(requestParameters.keyId, requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new deploy key in a project.  Example: ``` $ curl -X POST \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/workspaces/standard/projects/TEST_PROJECT/deploy-keys/ -d \\ \'{     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8\",     \"label\": \"mydeploykey\" }\' ```
         * @summary Create a project deploy key
         * @param {DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDeployKeysPost(requestParameters: DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectDeployKey> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyDeployKeysPost(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentsApi - interface
 */
export interface DeploymentsApiInterface {
    /**
     * Create an environment.
     * @summary Create an environment
     * @param {DeploymentsApiCreateEnvironmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEnvironment(requestParameters: DeploymentsApiCreateEnvironmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentEnvironment>;

    /**
     * Delete an environment
     * @summary Delete an environment
     * @param {DeploymentsApiDeleteEnvironmentForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEnvironmentForRepository(requestParameters: DeploymentsApiDeleteEnvironmentForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve a deployment
     * @summary Get a deployment
     * @param {DeploymentsApiGetDeploymentForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeploymentForRepository(requestParameters: DeploymentsApiGetDeploymentForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Deployment>;

    /**
     * Find deployments
     * @summary List deployments
     * @param {DeploymentsApiGetDeploymentsForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeploymentsForRepository(requestParameters: DeploymentsApiGetDeploymentsForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDeployments>;

    /**
     * Retrieve an environment
     * @summary Get an environment
     * @param {DeploymentsApiGetEnvironmentForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironmentForRepository(requestParameters: DeploymentsApiGetEnvironmentForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentEnvironment>;

    /**
     * Find environments
     * @summary List environments
     * @param {DeploymentsApiGetEnvironmentsForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironmentsForRepository(requestParameters: DeploymentsApiGetEnvironmentsForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedEnvironments>;

    /**
     * Returns all deploy-keys belonging to a repository.
     * @summary List repository deploy keys
     * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDeployKeysGet(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDeployKeys>;

    /**
     * This deletes a deploy key from a repository.
     * @summary Delete a repository deploy key
     * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the deploy key belonging to a specific key.
     * @summary Get a repository deploy key
     * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeployKey>;

    /**
     * Create a new deploy key in a repository.  The same key needs to be passed in but the comment and label can change.  Example: ``` $ curl -X PUT \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234 -d \\ \'{     \"label\": \"newlabel\",     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 newcomment\", }\' ```
     * @summary Update a repository deploy key
     * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeployKey>;

    /**
     * Create a new deploy key in a repository. Note: If authenticating a deploy key with an OAuth consumer, any changes to the OAuth consumer will subsequently invalidate the deploy key.   Example: ``` $ curl -X POST \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys -d \\ \'{     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8\",     \"label\": \"mydeploykey\" }\' ```
     * @summary Add a repository deploy key
     * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDeployKeysPost(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeployKey>;

    /**
     * Update an environment
     * @summary Update an environment
     * @param {DeploymentsApiUpdateEnvironmentForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEnvironmentForRepository(requestParameters: DeploymentsApiUpdateEnvironmentForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns all deploy keys belonging to a project.
     * @summary List project deploy keys
     * @param {DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyDeployKeysGet(requestParameters: DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProjectDeployKeys>;

    /**
     * This deletes a deploy key from a project.
     * @summary Delete a deploy key from a project
     * @param {DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDelete(requestParameters: DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the deploy key belonging to a specific key ID.
     * @summary Get a project deploy key
     * @param {DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGet(requestParameters: DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectDeployKey>;

    /**
     * Create a new deploy key in a project.  Example: ``` $ curl -X POST \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/workspaces/standard/projects/TEST_PROJECT/deploy-keys/ -d \\ \'{     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8\",     \"label\": \"mydeploykey\" }\' ```
     * @summary Create a project deploy key
     * @param {DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyDeployKeysPost(requestParameters: DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectDeployKey>;

}

/**
 * Request parameters for createEnvironment operation in DeploymentsApi.
 */
export interface DeploymentsApiCreateEnvironmentRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The environment to create.
     */
    readonly body: DeploymentEnvironment
}

/**
 * Request parameters for deleteEnvironmentForRepository operation in DeploymentsApi.
 */
export interface DeploymentsApiDeleteEnvironmentForRepositoryRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The environment UUID.
     */
    readonly environmentUuid: string
}

/**
 * Request parameters for getDeploymentForRepository operation in DeploymentsApi.
 */
export interface DeploymentsApiGetDeploymentForRepositoryRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The deployment UUID.
     */
    readonly deploymentUuid: string
}

/**
 * Request parameters for getDeploymentsForRepository operation in DeploymentsApi.
 */
export interface DeploymentsApiGetDeploymentsForRepositoryRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string
}

/**
 * Request parameters for getEnvironmentForRepository operation in DeploymentsApi.
 */
export interface DeploymentsApiGetEnvironmentForRepositoryRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The environment UUID.
     */
    readonly environmentUuid: string
}

/**
 * Request parameters for getEnvironmentsForRepository operation in DeploymentsApi.
 */
export interface DeploymentsApiGetEnvironmentsForRepositoryRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDeployKeysGet operation in DeploymentsApi.
 */
export interface DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete operation in DeploymentsApi.
 */
export interface DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdDeleteRequest {
    /**
     * The key ID matching the deploy key.
     */
    readonly keyId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet operation in DeploymentsApi.
 */
export interface DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdGetRequest {
    /**
     * The key ID matching the deploy key.
     */
    readonly keyId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut operation in DeploymentsApi.
 */
export interface DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdPutRequest {
    /**
     * The key ID matching the deploy key.
     */
    readonly keyId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDeployKeysPost operation in DeploymentsApi.
 */
export interface DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for updateEnvironmentForRepository operation in DeploymentsApi.
 */
export interface DeploymentsApiUpdateEnvironmentForRepositoryRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The environment UUID.
     */
    readonly environmentUuid: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyDeployKeysGet operation in DeploymentsApi.
 */
export interface DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysGetRequest {
    /**
     * The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDelete operation in DeploymentsApi.
 */
export interface DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDeleteRequest {
    /**
     * The key ID matching the project deploy key.
     */
    readonly keyId: string

    /**
     * The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGet operation in DeploymentsApi.
 */
export interface DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGetRequest {
    /**
     * The key ID matching the project deploy key.
     */
    readonly keyId: string

    /**
     * The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyDeployKeysPost operation in DeploymentsApi.
 */
export interface DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysPostRequest {
    /**
     * The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * DeploymentsApi - object-oriented interface
 */
export class DeploymentsApi extends BaseAPI implements DeploymentsApiInterface {
    /**
     * Create an environment.
     * @summary Create an environment
     * @param {DeploymentsApiCreateEnvironmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createEnvironment(requestParameters: DeploymentsApiCreateEnvironmentRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).createEnvironment(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an environment
     * @summary Delete an environment
     * @param {DeploymentsApiDeleteEnvironmentForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteEnvironmentForRepository(requestParameters: DeploymentsApiDeleteEnvironmentForRepositoryRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deleteEnvironmentForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.environmentUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a deployment
     * @summary Get a deployment
     * @param {DeploymentsApiGetDeploymentForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDeploymentForRepository(requestParameters: DeploymentsApiGetDeploymentForRepositoryRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).getDeploymentForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.deploymentUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find deployments
     * @summary List deployments
     * @param {DeploymentsApiGetDeploymentsForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDeploymentsForRepository(requestParameters: DeploymentsApiGetDeploymentsForRepositoryRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).getDeploymentsForRepository(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an environment
     * @summary Get an environment
     * @param {DeploymentsApiGetEnvironmentForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getEnvironmentForRepository(requestParameters: DeploymentsApiGetEnvironmentForRepositoryRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).getEnvironmentForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.environmentUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find environments
     * @summary List environments
     * @param {DeploymentsApiGetEnvironmentsForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getEnvironmentsForRepository(requestParameters: DeploymentsApiGetEnvironmentsForRepositoryRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).getEnvironmentsForRepository(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all deploy-keys belonging to a repository.
     * @summary List repository deploy keys
     * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDeployKeysGet(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysGetRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDeployKeysGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes a deploy key from a repository.
     * @summary Delete a repository deploy key
     * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete(requestParameters.keyId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the deploy key belonging to a specific key.
     * @summary Get a repository deploy key
     * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdGetRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet(requestParameters.keyId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new deploy key in a repository.  The same key needs to be passed in but the comment and label can change.  Example: ``` $ curl -X PUT \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234 -d \\ \'{     \"label\": \"newlabel\",     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 newcomment\", }\' ```
     * @summary Update a repository deploy key
     * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysKeyIdPutRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut(requestParameters.keyId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new deploy key in a repository. Note: If authenticating a deploy key with an OAuth consumer, any changes to the OAuth consumer will subsequently invalidate the deploy key.   Example: ``` $ curl -X POST \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys -d \\ \'{     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8\",     \"label\": \"mydeploykey\" }\' ```
     * @summary Add a repository deploy key
     * @param {DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDeployKeysPost(requestParameters: DeploymentsApiRepositoriesWorkspaceRepoSlugDeployKeysPostRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDeployKeysPost(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an environment
     * @summary Update an environment
     * @param {DeploymentsApiUpdateEnvironmentForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateEnvironmentForRepository(requestParameters: DeploymentsApiUpdateEnvironmentForRepositoryRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).updateEnvironmentForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.environmentUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all deploy keys belonging to a project.
     * @summary List project deploy keys
     * @param {DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyDeployKeysGet(requestParameters: DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysGetRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyDeployKeysGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes a deploy key from a project.
     * @summary Delete a deploy key from a project
     * @param {DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDelete(requestParameters: DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdDelete(requestParameters.keyId, requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the deploy key belonging to a specific key ID.
     * @summary Get a project deploy key
     * @param {DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGet(requestParameters: DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGetRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyDeployKeysKeyIdGet(requestParameters.keyId, requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new deploy key in a project.  Example: ``` $ curl -X POST \\ -H \"Authorization <auth header>\" \\ -H \"Content-type: application/json\" \\ https://api.bitbucket.org/2.0/workspaces/standard/projects/TEST_PROJECT/deploy-keys/ -d \\ \'{     \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8\",     \"label\": \"mydeploykey\" }\' ```
     * @summary Create a project deploy key
     * @param {DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyDeployKeysPost(requestParameters: DeploymentsApiWorkspacesWorkspaceProjectsProjectKeyDeployKeysPostRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyDeployKeysPost(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DownloadsApi - axios parameter creator
 */
export const DownloadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the specified download artifact from the repository.
         * @summary Delete a download artifact
         * @param {string} filename Name of the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDownloadsFilenameDelete: async (filename: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDownloadsFilenameDelete', 'filename', filename)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDownloadsFilenameDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDownloadsFilenameDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/downloads/{filename}`
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a redirect to the contents of a download artifact.  This endpoint returns the actual file contents and not the artifact\'s metadata.      $ curl -s -L https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads/hello.txt     Hello World
         * @summary Get a download artifact link
         * @param {string} filename Name of the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDownloadsFilenameGet: async (filename: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDownloadsFilenameGet', 'filename', filename)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDownloadsFilenameGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDownloadsFilenameGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/downloads/{filename}`
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of download links associated with the repository.
         * @summary List download artifacts
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDownloadsGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDownloadsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDownloadsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/downloads`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload new download artifacts.  To upload files, perform a `multipart/form-data` POST containing one or more `files` fields:      $ echo Hello World > hello.txt     $ curl -s -u evzijst -X POST https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads -F files=@hello.txt  When a file is uploaded with the same name as an existing artifact, then the existing file will be replaced.
         * @summary Upload a download artifact
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDownloadsPost: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDownloadsPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDownloadsPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/downloads`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DownloadsApi - functional programming interface
 */
export const DownloadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DownloadsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the specified download artifact from the repository.
         * @summary Delete a download artifact
         * @param {string} filename Name of the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDownloadsFilenameDelete(filename: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDownloadsFilenameDelete(filename, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DownloadsApi.repositoriesWorkspaceRepoSlugDownloadsFilenameDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a redirect to the contents of a download artifact.  This endpoint returns the actual file contents and not the artifact\'s metadata.      $ curl -s -L https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads/hello.txt     Hello World
         * @summary Get a download artifact link
         * @param {string} filename Name of the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDownloadsFilenameGet(filename: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDownloadsFilenameGet(filename, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DownloadsApi.repositoriesWorkspaceRepoSlugDownloadsFilenameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of download links associated with the repository.
         * @summary List download artifacts
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDownloadsGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDownloadsGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DownloadsApi.repositoriesWorkspaceRepoSlugDownloadsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload new download artifacts.  To upload files, perform a `multipart/form-data` POST containing one or more `files` fields:      $ echo Hello World > hello.txt     $ curl -s -u evzijst -X POST https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads -F files=@hello.txt  When a file is uploaded with the same name as an existing artifact, then the existing file will be replaced.
         * @summary Upload a download artifact
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDownloadsPost(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDownloadsPost(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DownloadsApi.repositoriesWorkspaceRepoSlugDownloadsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DownloadsApi - factory interface
 */
export const DownloadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DownloadsApiFp(configuration)
    return {
        /**
         * Deletes the specified download artifact from the repository.
         * @summary Delete a download artifact
         * @param {DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsFilenameDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDownloadsFilenameDelete(requestParameters: DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsFilenameDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugDownloadsFilenameDelete(requestParameters.filename, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a redirect to the contents of a download artifact.  This endpoint returns the actual file contents and not the artifact\'s metadata.      $ curl -s -L https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads/hello.txt     Hello World
         * @summary Get a download artifact link
         * @param {DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsFilenameGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDownloadsFilenameGet(requestParameters: DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsFilenameGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugDownloadsFilenameGet(requestParameters.filename, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of download links associated with the repository.
         * @summary List download artifacts
         * @param {DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDownloadsGet(requestParameters: DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugDownloadsGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload new download artifacts.  To upload files, perform a `multipart/form-data` POST containing one or more `files` fields:      $ echo Hello World > hello.txt     $ curl -s -u evzijst -X POST https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads -F files=@hello.txt  When a file is uploaded with the same name as an existing artifact, then the existing file will be replaced.
         * @summary Upload a download artifact
         * @param {DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDownloadsPost(requestParameters: DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugDownloadsPost(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DownloadsApi - interface
 */
export interface DownloadsApiInterface {
    /**
     * Deletes the specified download artifact from the repository.
     * @summary Delete a download artifact
     * @param {DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsFilenameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDownloadsFilenameDelete(requestParameters: DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsFilenameDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Return a redirect to the contents of a download artifact.  This endpoint returns the actual file contents and not the artifact\'s metadata.      $ curl -s -L https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads/hello.txt     Hello World
     * @summary Get a download artifact link
     * @param {DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsFilenameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDownloadsFilenameGet(requestParameters: DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsFilenameGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a list of download links associated with the repository.
     * @summary List download artifacts
     * @param {DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDownloadsGet(requestParameters: DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Upload new download artifacts.  To upload files, perform a `multipart/form-data` POST containing one or more `files` fields:      $ echo Hello World > hello.txt     $ curl -s -u evzijst -X POST https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads -F files=@hello.txt  When a file is uploaded with the same name as an existing artifact, then the existing file will be replaced.
     * @summary Upload a download artifact
     * @param {DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDownloadsPost(requestParameters: DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDownloadsFilenameDelete operation in DownloadsApi.
 */
export interface DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsFilenameDeleteRequest {
    /**
     * Name of the file.
     */
    readonly filename: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDownloadsFilenameGet operation in DownloadsApi.
 */
export interface DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsFilenameGetRequest {
    /**
     * Name of the file.
     */
    readonly filename: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDownloadsGet operation in DownloadsApi.
 */
export interface DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDownloadsPost operation in DownloadsApi.
 */
export interface DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * DownloadsApi - object-oriented interface
 */
export class DownloadsApi extends BaseAPI implements DownloadsApiInterface {
    /**
     * Deletes the specified download artifact from the repository.
     * @summary Delete a download artifact
     * @param {DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsFilenameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDownloadsFilenameDelete(requestParameters: DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsFilenameDeleteRequest, options?: RawAxiosRequestConfig) {
        return DownloadsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDownloadsFilenameDelete(requestParameters.filename, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a redirect to the contents of a download artifact.  This endpoint returns the actual file contents and not the artifact\'s metadata.      $ curl -s -L https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads/hello.txt     Hello World
     * @summary Get a download artifact link
     * @param {DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsFilenameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDownloadsFilenameGet(requestParameters: DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsFilenameGetRequest, options?: RawAxiosRequestConfig) {
        return DownloadsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDownloadsFilenameGet(requestParameters.filename, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of download links associated with the repository.
     * @summary List download artifacts
     * @param {DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDownloadsGet(requestParameters: DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsGetRequest, options?: RawAxiosRequestConfig) {
        return DownloadsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDownloadsGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload new download artifacts.  To upload files, perform a `multipart/form-data` POST containing one or more `files` fields:      $ echo Hello World > hello.txt     $ curl -s -u evzijst -X POST https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads -F files=@hello.txt  When a file is uploaded with the same name as an existing artifact, then the existing file will be replaced.
     * @summary Upload a download artifact
     * @param {DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDownloadsPost(requestParameters: DownloadsApiRepositoriesWorkspaceRepoSlugDownloadsPostRequest, options?: RawAxiosRequestConfig) {
        return DownloadsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDownloadsPost(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GPGApi - axios parameter creator
 */
export const GPGApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a specific GPG public key from a user\'s account.
         * @summary Delete a GPG key
         * @param {string} fingerprint A GPG key fingerprint. 
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserGpgKeysFingerprintDelete: async (fingerprint: string, selectedUser: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('usersSelectedUserGpgKeysFingerprintDelete', 'fingerprint', fingerprint)
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('usersSelectedUserGpgKeysFingerprintDelete', 'selectedUser', selectedUser)
            const localVarPath = `/users/{selected_user}/gpg-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)))
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific GPG public key belonging to a user. The `key` and `subkeys` fields can also be requested from the endpoint. See [Partial Responses](/cloud/bitbucket/rest/intro/#partial-response) for more details.
         * @summary Get a GPG key
         * @param {string} fingerprint A GPG key fingerprint. 
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserGpgKeysFingerprintGet: async (fingerprint: string, selectedUser: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('usersSelectedUserGpgKeysFingerprintGet', 'fingerprint', fingerprint)
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('usersSelectedUserGpgKeysFingerprintGet', 'selectedUser', selectedUser)
            const localVarPath = `/users/{selected_user}/gpg-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)))
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of the user\'s GPG public keys. The `key` and `subkeys` fields can also be requested from the endpoint. See [Partial Responses](/cloud/bitbucket/rest/intro/#partial-response) for more details.
         * @summary List GPG keys
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserGpgKeysGet: async (selectedUser: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('usersSelectedUserGpgKeysGet', 'selectedUser', selectedUser)
            const localVarPath = `/users/{selected_user}/gpg-keys`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new GPG public key to the specified user account and returns the resulting key.  Example:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{\"key\": \"<insert GPG Key>\"}\' https://api.bitbucket.org/2.0/users/{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}/gpg-keys ```
         * @summary Add a new GPG key
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {GPGAccountKey} [body] The new GPG key object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserGpgKeysPost: async (selectedUser: string, body?: GPGAccountKey, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('usersSelectedUserGpgKeysPost', 'selectedUser', selectedUser)
            const localVarPath = `/users/{selected_user}/gpg-keys`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GPGApi - functional programming interface
 */
export const GPGApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GPGApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a specific GPG public key from a user\'s account.
         * @summary Delete a GPG key
         * @param {string} fingerprint A GPG key fingerprint. 
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSelectedUserGpgKeysFingerprintDelete(fingerprint: string, selectedUser: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSelectedUserGpgKeysFingerprintDelete(fingerprint, selectedUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GPGApi.usersSelectedUserGpgKeysFingerprintDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a specific GPG public key belonging to a user. The `key` and `subkeys` fields can also be requested from the endpoint. See [Partial Responses](/cloud/bitbucket/rest/intro/#partial-response) for more details.
         * @summary Get a GPG key
         * @param {string} fingerprint A GPG key fingerprint. 
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSelectedUserGpgKeysFingerprintGet(fingerprint: string, selectedUser: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GPGAccountKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSelectedUserGpgKeysFingerprintGet(fingerprint, selectedUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GPGApi.usersSelectedUserGpgKeysFingerprintGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of the user\'s GPG public keys. The `key` and `subkeys` fields can also be requested from the endpoint. See [Partial Responses](/cloud/bitbucket/rest/intro/#partial-response) for more details.
         * @summary List GPG keys
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSelectedUserGpgKeysGet(selectedUser: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGpgUserKeys>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSelectedUserGpgKeysGet(selectedUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GPGApi.usersSelectedUserGpgKeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds a new GPG public key to the specified user account and returns the resulting key.  Example:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{\"key\": \"<insert GPG Key>\"}\' https://api.bitbucket.org/2.0/users/{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}/gpg-keys ```
         * @summary Add a new GPG key
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {GPGAccountKey} [body] The new GPG key object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSelectedUserGpgKeysPost(selectedUser: string, body?: GPGAccountKey, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GPGAccountKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSelectedUserGpgKeysPost(selectedUser, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GPGApi.usersSelectedUserGpgKeysPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GPGApi - factory interface
 */
export const GPGApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GPGApiFp(configuration)
    return {
        /**
         * Deletes a specific GPG public key from a user\'s account.
         * @summary Delete a GPG key
         * @param {GPGApiUsersSelectedUserGpgKeysFingerprintDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserGpgKeysFingerprintDelete(requestParameters: GPGApiUsersSelectedUserGpgKeysFingerprintDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersSelectedUserGpgKeysFingerprintDelete(requestParameters.fingerprint, requestParameters.selectedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific GPG public key belonging to a user. The `key` and `subkeys` fields can also be requested from the endpoint. See [Partial Responses](/cloud/bitbucket/rest/intro/#partial-response) for more details.
         * @summary Get a GPG key
         * @param {GPGApiUsersSelectedUserGpgKeysFingerprintGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserGpgKeysFingerprintGet(requestParameters: GPGApiUsersSelectedUserGpgKeysFingerprintGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<GPGAccountKey> {
            return localVarFp.usersSelectedUserGpgKeysFingerprintGet(requestParameters.fingerprint, requestParameters.selectedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of the user\'s GPG public keys. The `key` and `subkeys` fields can also be requested from the endpoint. See [Partial Responses](/cloud/bitbucket/rest/intro/#partial-response) for more details.
         * @summary List GPG keys
         * @param {GPGApiUsersSelectedUserGpgKeysGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserGpgKeysGet(requestParameters: GPGApiUsersSelectedUserGpgKeysGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedGpgUserKeys> {
            return localVarFp.usersSelectedUserGpgKeysGet(requestParameters.selectedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new GPG public key to the specified user account and returns the resulting key.  Example:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{\"key\": \"<insert GPG Key>\"}\' https://api.bitbucket.org/2.0/users/{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}/gpg-keys ```
         * @summary Add a new GPG key
         * @param {GPGApiUsersSelectedUserGpgKeysPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserGpgKeysPost(requestParameters: GPGApiUsersSelectedUserGpgKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<GPGAccountKey> {
            return localVarFp.usersSelectedUserGpgKeysPost(requestParameters.selectedUser, requestParameters.body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GPGApi - interface
 */
export interface GPGApiInterface {
    /**
     * Deletes a specific GPG public key from a user\'s account.
     * @summary Delete a GPG key
     * @param {GPGApiUsersSelectedUserGpgKeysFingerprintDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersSelectedUserGpgKeysFingerprintDelete(requestParameters: GPGApiUsersSelectedUserGpgKeysFingerprintDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a specific GPG public key belonging to a user. The `key` and `subkeys` fields can also be requested from the endpoint. See [Partial Responses](/cloud/bitbucket/rest/intro/#partial-response) for more details.
     * @summary Get a GPG key
     * @param {GPGApiUsersSelectedUserGpgKeysFingerprintGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersSelectedUserGpgKeysFingerprintGet(requestParameters: GPGApiUsersSelectedUserGpgKeysFingerprintGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<GPGAccountKey>;

    /**
     * Returns a paginated list of the user\'s GPG public keys. The `key` and `subkeys` fields can also be requested from the endpoint. See [Partial Responses](/cloud/bitbucket/rest/intro/#partial-response) for more details.
     * @summary List GPG keys
     * @param {GPGApiUsersSelectedUserGpgKeysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersSelectedUserGpgKeysGet(requestParameters: GPGApiUsersSelectedUserGpgKeysGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedGpgUserKeys>;

    /**
     * Adds a new GPG public key to the specified user account and returns the resulting key.  Example:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{\"key\": \"<insert GPG Key>\"}\' https://api.bitbucket.org/2.0/users/{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}/gpg-keys ```
     * @summary Add a new GPG key
     * @param {GPGApiUsersSelectedUserGpgKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersSelectedUserGpgKeysPost(requestParameters: GPGApiUsersSelectedUserGpgKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<GPGAccountKey>;

}

/**
 * Request parameters for usersSelectedUserGpgKeysFingerprintDelete operation in GPGApi.
 */
export interface GPGApiUsersSelectedUserGpgKeysFingerprintDeleteRequest {
    /**
     * A GPG key fingerprint. 
     */
    readonly fingerprint: string

    /**
     * This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly selectedUser: string
}

/**
 * Request parameters for usersSelectedUserGpgKeysFingerprintGet operation in GPGApi.
 */
export interface GPGApiUsersSelectedUserGpgKeysFingerprintGetRequest {
    /**
     * A GPG key fingerprint. 
     */
    readonly fingerprint: string

    /**
     * This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly selectedUser: string
}

/**
 * Request parameters for usersSelectedUserGpgKeysGet operation in GPGApi.
 */
export interface GPGApiUsersSelectedUserGpgKeysGetRequest {
    /**
     * This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly selectedUser: string
}

/**
 * Request parameters for usersSelectedUserGpgKeysPost operation in GPGApi.
 */
export interface GPGApiUsersSelectedUserGpgKeysPostRequest {
    /**
     * This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly selectedUser: string

    /**
     * The new GPG key object.
     */
    readonly body?: GPGAccountKey
}

/**
 * GPGApi - object-oriented interface
 */
export class GPGApi extends BaseAPI implements GPGApiInterface {
    /**
     * Deletes a specific GPG public key from a user\'s account.
     * @summary Delete a GPG key
     * @param {GPGApiUsersSelectedUserGpgKeysFingerprintDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersSelectedUserGpgKeysFingerprintDelete(requestParameters: GPGApiUsersSelectedUserGpgKeysFingerprintDeleteRequest, options?: RawAxiosRequestConfig) {
        return GPGApiFp(this.configuration).usersSelectedUserGpgKeysFingerprintDelete(requestParameters.fingerprint, requestParameters.selectedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific GPG public key belonging to a user. The `key` and `subkeys` fields can also be requested from the endpoint. See [Partial Responses](/cloud/bitbucket/rest/intro/#partial-response) for more details.
     * @summary Get a GPG key
     * @param {GPGApiUsersSelectedUserGpgKeysFingerprintGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersSelectedUserGpgKeysFingerprintGet(requestParameters: GPGApiUsersSelectedUserGpgKeysFingerprintGetRequest, options?: RawAxiosRequestConfig) {
        return GPGApiFp(this.configuration).usersSelectedUserGpgKeysFingerprintGet(requestParameters.fingerprint, requestParameters.selectedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of the user\'s GPG public keys. The `key` and `subkeys` fields can also be requested from the endpoint. See [Partial Responses](/cloud/bitbucket/rest/intro/#partial-response) for more details.
     * @summary List GPG keys
     * @param {GPGApiUsersSelectedUserGpgKeysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersSelectedUserGpgKeysGet(requestParameters: GPGApiUsersSelectedUserGpgKeysGetRequest, options?: RawAxiosRequestConfig) {
        return GPGApiFp(this.configuration).usersSelectedUserGpgKeysGet(requestParameters.selectedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new GPG public key to the specified user account and returns the resulting key.  Example:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{\"key\": \"<insert GPG Key>\"}\' https://api.bitbucket.org/2.0/users/{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}/gpg-keys ```
     * @summary Add a new GPG key
     * @param {GPGApiUsersSelectedUserGpgKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersSelectedUserGpgKeysPost(requestParameters: GPGApiUsersSelectedUserGpgKeysPostRequest, options?: RawAxiosRequestConfig) {
        return GPGApiFp(this.configuration).usersSelectedUserGpgKeysPost(requestParameters.selectedUser, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IssueTrackerApi - axios parameter creator
 */
export const IssueTrackerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the specified issue tracker component object.
         * @summary Get a component for issues
         * @param {number} componentId The component\&#39;s id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugComponentsComponentIdGet: async (componentId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'componentId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugComponentsComponentIdGet', 'componentId', componentId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugComponentsComponentIdGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugComponentsComponentIdGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/components/{component_id}`
                .replace(`{${"component_id"}}`, encodeURIComponent(String(componentId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the components that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
         * @summary List components
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugComponentsGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugComponentsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugComponentsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/components`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A POST request to this endpoint initiates a new background celery task that archives the repo\'s issues.  When the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the \'Location\' response header. This url is the endpoint for where the user can obtain their zip files.\"
         * @summary Export issues
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {ExportOptions} [body] The options to apply to the export. Available options include &#x60;project_key&#x60; and &#x60;project_name&#x60; which, if specified, are used as the project key and name in the exported Jira json format. Option &#x60;send_email&#x60; specifies whether an email should be sent upon export result. Option &#x60;include_attachments&#x60; specifies whether attachments are included in the export.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesExportPost: async (repoSlug: string, workspace: string, body?: ExportOptions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesExportPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesExportPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/export`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue", "repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to poll for the progress of an issue export job and return the zip file after the job is complete. As long as the job is running, this will return a 202 response with in the response body a description of the current status.  After the job has been scheduled, but before it starts executing, the endpoint returns a 202 response with status `ACCEPTED`.  Once it starts running, it is a 202 response with status `STARTED` and progress filled.  After it is finished, it becomes a 200 response with status `SUCCESS` or `FAILURE`.
         * @summary Check issue export status
         * @param {string} repoName The name of the repo
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} taskId The ID of the export task
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet: async (repoName: string, repoSlug: string, taskId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoName' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet', 'repoName', repoName)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet', 'repoSlug', repoSlug)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet', 'taskId', taskId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/export/{repo_name}-issues-{task_id}.zip`
                .replace(`{${"repo_name"}}`, encodeURIComponent(String(repoName)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue", "repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the issues in the issue tracker.
         * @summary List issues
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When using GET, this endpoint reports the status of the current import task.  After the job has been scheduled, but before it starts executing, the endpoint returns a 202 response with status `ACCEPTED`.  Once it starts running, it is a 202 response with status `STARTED` and progress filled.  After it is finished, it becomes a 200 response with status `SUCCESS` or `FAILURE`.
         * @summary Check issue import status
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesImportGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesImportGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesImportGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/import`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue:write", "repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All existing issues will be deleted and replaced by the contents of the imported zip file.  Imports are done through a multipart/form-data POST. There is one valid and required form field, with the name \"archive,\" which needs to be a file field:  ``` $ curl -u <username> -X POST -F archive=@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import ```
         * @summary Import issues
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesImportPost: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesImportPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesImportPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/import`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue:write", "repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all attachments for this issue.  This returns the files\' meta data. This does not return the files\' actual contents.  The files are always ordered by their upload date.
         * @summary List attachments for an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet: async (issueId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an attachment.
         * @summary Delete an attachment for an issue
         * @param {string} issueId The issue id
         * @param {string} path Path to the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete: async (issueId: string, path: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete', 'issueId', issueId)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete', 'path', path)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the contents of the specified file attachment.  Note that this endpoint does not return a JSON response, but instead returns a redirect pointing to the actual file that in turn will return the raw contents.  The redirect URL contains a one-time token that has a limited lifetime. As a result, the link should not be persisted, stored, or shared.
         * @summary Get attachment for an issue
         * @param {string} issueId The issue id
         * @param {string} path Path to the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet: async (issueId: string, path: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet', 'issueId', issueId)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet', 'path', path)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload new issue attachments.  To upload files, perform a `multipart/form-data` POST containing one or more file fields.  When a file is uploaded with the same name as an existing attachment, then the existing file will be replaced.
         * @summary Upload an attachment to an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost: async (issueId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified issue change object.  This resource is only available on repositories that have the issue tracker enabled.
         * @summary Get issue change object
         * @param {string} changeId The issue change id
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet: async (changeId: string, issueId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet', 'changeId', changeId)
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes/{change_id}`
                .replace(`{${"change_id"}}`, encodeURIComponent(String(changeId)))
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of all changes that have been made to the specified issue. Changes are returned in chronological order with the oldest change first.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the `/issues/123/changes` endpoint. It also has a comment associated with the change.  Note that this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api) for details.  Changes support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that can be used to search for specific changes. For instance, to see when an issue transitioned to \"resolved\":  ``` $ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \\    -G --data-urlencode=\'q=changes.state.new = \"resolved\"\' ```  This resource is only available on repositories that have the issue tracker enabled.  N.B.  The `changes.assignee` and `changes.assignee_account_id` fields are not a `user` object. Instead, they contain the raw `username` and `account_id` of the user. This is to protect the integrity of the audit log even after a user account gets deleted.  The `changes.assignee` field is deprecated will disappear in the future. Use `changes.assignee_account_id` instead.
         * @summary List changes on an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details.
         * @param {string} [sort]  Name of a response property to sort results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results) for details. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet: async (issueId: string, repoSlug: string, workspace: string, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Makes a change to the specified issue.  For example, to change an issue\'s state and assignee, create a new change object that modifies these fields:  ``` curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \\   -s -u evzijst -X POST -H \"Content-Type: application/json\" \\   -d \'{     \"changes\": {       \"assignee_account_id\": {         \"new\": \"557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\"       },       \"state\": {         \"new\": \'resolved\"       }     }     \"message\": {       \"raw\": \"This is now resolved.\"     }   }\' ```  The above example also includes a custom comment to go alongside the change. This comment will also be visible on the issue page in the UI.  The fields of the `changes` object are strings, not objects. This allows for immutable change log records, even after user accounts, milestones, or other objects recorded in a change entry, get renamed or deleted.  The `assignee_account_id` field stores the account id. When POSTing a new change and changing the assignee, the client should therefore use the user\'s account_id in the `changes.assignee_account_id.new` field.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.
         * @summary Modify the state of an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {IssueChange} body The new issue state change. The only required elements are &#x60;changes.[].new&#x60;. All other elements can be omitted from the body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost: async (issueId: string, repoSlug: string, workspace: string, body: IssueChange, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified comment.
         * @summary Delete a comment on an issue
         * @param {number} commentId The id of the comment.
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete: async (commentId: number, issueId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete', 'commentId', commentId)
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified issue comment object.
         * @summary Get a comment on an issue
         * @param {number} commentId The id of the comment.
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet: async (commentId: number, issueId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet', 'commentId', commentId)
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the content of the specified issue comment. Note that only the `content.raw` field can be modified.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \\   -X PUT -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"Lorem ipsum.\"}\' ```
         * @summary Update a comment on an issue
         * @param {number} commentId The id of the comment.
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {IssueComment} body The updated comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut: async (commentId: number, issueId: string, repoSlug: string, workspace: string, body: IssueComment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut', 'commentId', commentId)
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all comments that were made on the specified issue.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List comments on an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet: async (issueId: string, repoSlug: string, workspace: string, q?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new issue comment.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \\   -X POST -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"Lorem ipsum.\"}}\' ```
         * @summary Create a comment on an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {IssueComment} body The new issue comment object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost: async (issueId: string, repoSlug: string, workspace: string, body: IssueComment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified issue. This requires write access to the repository.
         * @summary Delete an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdDelete: async (issueId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdDelete', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified issue.
         * @summary Get an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdGet: async (issueId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdGet', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies the issue.  ``` $ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \\   -u evzijst -s -X PUT -H \'Content-Type: application/json\' \\   -d \'{   \"title\": \"Updated title\",   \"assignee\": {     \"account_id\": \"5d5355e8c6b9320d9ea5b28d\"   },   \"priority\": \"minor\",   \"version\": {     \"name\": \"1.0\"   },   \"component\": null }\' ```  This example changes the `title`, `assignee`, `priority` and the `version`. It also removes the value of the `component` from the issue by setting the field to `null`. Any field not present keeps its existing value.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the `/issues/123/changes` endpoint. It also has a comment associated with the change.
         * @summary Update an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdPut: async (issueId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdPut', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdPut', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdPut', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retract your vote.
         * @summary Remove vote for an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete: async (issueId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account:write", "issue:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check whether the authenticated user has voted for this issue. A 204 status code indicates that the user has voted, while a 404 implies they haven\'t.
         * @summary Check if current user voted for an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet: async (issueId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account", "issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Vote for this issue.  To cast your vote, do an empty PUT. The 204 status code indicates that the operation was successful.
         * @summary Vote for an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut: async (issueId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account:write", "issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop watching this issue.
         * @summary Stop watching an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete: async (issueId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account:write", "issue:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Indicated whether or not the authenticated user is watching this issue.
         * @summary Check if current user is watching a issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet: async (issueId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account", "issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start watching this issue.  To start watching this issue, do an empty PUT. The 204 status code indicates that the operation was successful.
         * @summary Watch an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut: async (issueId: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut', 'issueId', issueId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account:write", "issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new issue.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.  The authenticated user is used for the issue\'s `reporter` field.
         * @summary Create an issue
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Issue} body The new issue. The only required element is &#x60;title&#x60;. All other elements can be omitted from the body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesPost: async (repoSlug: string, workspace: string, body: Issue, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesPost', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugIssuesPost', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/issues`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the milestones that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
         * @summary List milestones
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugMilestonesGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugMilestonesGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugMilestonesGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/milestones`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified issue tracker milestone object.
         * @summary Get a milestone
         * @param {number} milestoneId The milestone\&#39;s id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet: async (milestoneId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'milestoneId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet', 'milestoneId', milestoneId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/milestones/{milestone_id}`
                .replace(`{${"milestone_id"}}`, encodeURIComponent(String(milestoneId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the versions that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
         * @summary List defined versions for issues
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugVersionsGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugVersionsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugVersionsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/versions`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified issue tracker version object.
         * @summary Get a defined version for issues
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {number} versionId The version\&#39;s id
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugVersionsVersionIdGet: async (repoSlug: string, versionId: number, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugVersionsVersionIdGet', 'repoSlug', repoSlug)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugVersionsVersionIdGet', 'versionId', versionId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugVersionsVersionIdGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/versions/{version_id}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["issue"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IssueTrackerApi - functional programming interface
 */
export const IssueTrackerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IssueTrackerApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the specified issue tracker component object.
         * @summary Get a component for issues
         * @param {number} componentId The component\&#39;s id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugComponentsComponentIdGet(componentId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Component>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugComponentsComponentIdGet(componentId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugComponentsComponentIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the components that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
         * @summary List components
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugComponentsGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedComponents>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugComponentsGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugComponentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A POST request to this endpoint initiates a new background celery task that archives the repo\'s issues.  When the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the \'Location\' response header. This url is the endpoint for where the user can obtain their zip files.\"
         * @summary Export issues
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {ExportOptions} [body] The options to apply to the export. Available options include &#x60;project_key&#x60; and &#x60;project_name&#x60; which, if specified, are used as the project key and name in the exported Jira json format. Option &#x60;send_email&#x60; specifies whether an email should be sent upon export result. Option &#x60;include_attachments&#x60; specifies whether attachments are included in the export.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesExportPost(repoSlug: string, workspace: string, body?: ExportOptions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesExportPost(repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesExportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is used to poll for the progress of an issue export job and return the zip file after the job is complete. As long as the job is running, this will return a 202 response with in the response body a description of the current status.  After the job has been scheduled, but before it starts executing, the endpoint returns a 202 response with status `ACCEPTED`.  Once it starts running, it is a 202 response with status `STARTED` and progress filled.  After it is finished, it becomes a 200 response with status `SUCCESS` or `FAILURE`.
         * @summary Check issue export status
         * @param {string} repoName The name of the repo
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} taskId The ID of the export task
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet(repoName: string, repoSlug: string, taskId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueJobStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet(repoName, repoSlug, taskId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the issues in the issue tracker.
         * @summary List issues
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedIssues>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * When using GET, this endpoint reports the status of the current import task.  After the job has been scheduled, but before it starts executing, the endpoint returns a 202 response with status `ACCEPTED`.  Once it starts running, it is a 202 response with status `STARTED` and progress filled.  After it is finished, it becomes a 200 response with status `SUCCESS` or `FAILURE`.
         * @summary Check issue import status
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesImportGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueJobStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesImportGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesImportGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All existing issues will be deleted and replaced by the contents of the imported zip file.  Imports are done through a multipart/form-data POST. There is one valid and required form field, with the name \"archive,\" which needs to be a file field:  ``` $ curl -u <username> -X POST -F archive=@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import ```
         * @summary Import issues
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesImportPost(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueJobStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesImportPost(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesImportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all attachments for this issue.  This returns the files\' meta data. This does not return the files\' actual contents.  The files are always ordered by their upload date.
         * @summary List attachments for an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet(issueId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedIssueAttachments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet(issueId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an attachment.
         * @summary Delete an attachment for an issue
         * @param {string} issueId The issue id
         * @param {string} path Path to the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete(issueId: string, path: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete(issueId, path, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the contents of the specified file attachment.  Note that this endpoint does not return a JSON response, but instead returns a redirect pointing to the actual file that in turn will return the raw contents.  The redirect URL contains a one-time token that has a limited lifetime. As a result, the link should not be persisted, stored, or shared.
         * @summary Get attachment for an issue
         * @param {string} issueId The issue id
         * @param {string} path Path to the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet(issueId: string, path: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet(issueId, path, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload new issue attachments.  To upload files, perform a `multipart/form-data` POST containing one or more file fields.  When a file is uploaded with the same name as an existing attachment, then the existing file will be replaced.
         * @summary Upload an attachment to an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost(issueId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost(issueId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specified issue change object.  This resource is only available on repositories that have the issue tracker enabled.
         * @summary Get issue change object
         * @param {string} changeId The issue change id
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet(changeId: string, issueId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueChange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet(changeId, issueId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the list of all changes that have been made to the specified issue. Changes are returned in chronological order with the oldest change first.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the `/issues/123/changes` endpoint. It also has a comment associated with the change.  Note that this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api) for details.  Changes support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that can be used to search for specific changes. For instance, to see when an issue transitioned to \"resolved\":  ``` $ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \\    -G --data-urlencode=\'q=changes.state.new = \"resolved\"\' ```  This resource is only available on repositories that have the issue tracker enabled.  N.B.  The `changes.assignee` and `changes.assignee_account_id` fields are not a `user` object. Instead, they contain the raw `username` and `account_id` of the user. This is to protect the integrity of the audit log even after a user account gets deleted.  The `changes.assignee` field is deprecated will disappear in the future. Use `changes.assignee_account_id` instead.
         * @summary List changes on an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details.
         * @param {string} [sort]  Name of a response property to sort results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results) for details. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet(issueId: string, repoSlug: string, workspace: string, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedLogEntries>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet(issueId, repoSlug, workspace, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Makes a change to the specified issue.  For example, to change an issue\'s state and assignee, create a new change object that modifies these fields:  ``` curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \\   -s -u evzijst -X POST -H \"Content-Type: application/json\" \\   -d \'{     \"changes\": {       \"assignee_account_id\": {         \"new\": \"557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\"       },       \"state\": {         \"new\": \'resolved\"       }     }     \"message\": {       \"raw\": \"This is now resolved.\"     }   }\' ```  The above example also includes a custom comment to go alongside the change. This comment will also be visible on the issue page in the UI.  The fields of the `changes` object are strings, not objects. This allows for immutable change log records, even after user accounts, milestones, or other objects recorded in a change entry, get renamed or deleted.  The `assignee_account_id` field stores the account id. When POSTing a new change and changing the assignee, the client should therefore use the user\'s account_id in the `changes.assignee_account_id.new` field.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.
         * @summary Modify the state of an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {IssueChange} body The new issue state change. The only required elements are &#x60;changes.[].new&#x60;. All other elements can be omitted from the body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost(issueId: string, repoSlug: string, workspace: string, body: IssueChange, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueChange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost(issueId, repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified comment.
         * @summary Delete a comment on an issue
         * @param {number} commentId The id of the comment.
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete(commentId: number, issueId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete(commentId, issueId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specified issue comment object.
         * @summary Get a comment on an issue
         * @param {number} commentId The id of the comment.
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet(commentId: number, issueId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet(commentId, issueId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the content of the specified issue comment. Note that only the `content.raw` field can be modified.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \\   -X PUT -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"Lorem ipsum.\"}\' ```
         * @summary Update a comment on an issue
         * @param {number} commentId The id of the comment.
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {IssueComment} body The updated comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut(commentId: number, issueId: string, repoSlug: string, workspace: string, body: IssueComment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut(commentId, issueId, repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all comments that were made on the specified issue.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List comments on an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet(issueId: string, repoSlug: string, workspace: string, q?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedIssueComments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet(issueId, repoSlug, workspace, q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new issue comment.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \\   -X POST -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"Lorem ipsum.\"}}\' ```
         * @summary Create a comment on an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {IssueComment} body The new issue comment object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost(issueId: string, repoSlug: string, workspace: string, body: IssueComment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost(issueId, repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified issue. This requires write access to the repository.
         * @summary Delete an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdDelete(issueId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdDelete(issueId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specified issue.
         * @summary Get an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdGet(issueId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdGet(issueId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modifies the issue.  ``` $ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \\   -u evzijst -s -X PUT -H \'Content-Type: application/json\' \\   -d \'{   \"title\": \"Updated title\",   \"assignee\": {     \"account_id\": \"5d5355e8c6b9320d9ea5b28d\"   },   \"priority\": \"minor\",   \"version\": {     \"name\": \"1.0\"   },   \"component\": null }\' ```  This example changes the `title`, `assignee`, `priority` and the `version`. It also removes the value of the `component` from the issue by setting the field to `null`. Any field not present keeps its existing value.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the `/issues/123/changes` endpoint. It also has a comment associated with the change.
         * @summary Update an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdPut(issueId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdPut(issueId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retract your vote.
         * @summary Remove vote for an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete(issueId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete(issueId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check whether the authenticated user has voted for this issue. A 204 status code indicates that the user has voted, while a 404 implies they haven\'t.
         * @summary Check if current user voted for an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet(issueId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet(issueId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Vote for this issue.  To cast your vote, do an empty PUT. The 204 status code indicates that the operation was successful.
         * @summary Vote for an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut(issueId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut(issueId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stop watching this issue.
         * @summary Stop watching an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete(issueId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete(issueId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Indicated whether or not the authenticated user is watching this issue.
         * @summary Check if current user is watching a issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet(issueId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet(issueId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start watching this issue.  To start watching this issue, do an empty PUT. The 204 status code indicates that the operation was successful.
         * @summary Watch an issue
         * @param {string} issueId The issue id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut(issueId: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut(issueId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new issue.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.  The authenticated user is used for the issue\'s `reporter` field.
         * @summary Create an issue
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Issue} body The new issue. The only required element is &#x60;title&#x60;. All other elements can be omitted from the body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugIssuesPost(repoSlug: string, workspace: string, body: Issue, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugIssuesPost(repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugIssuesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the milestones that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
         * @summary List milestones
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugMilestonesGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMilestones>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugMilestonesGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugMilestonesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specified issue tracker milestone object.
         * @summary Get a milestone
         * @param {number} milestoneId The milestone\&#39;s id
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet(milestoneId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Milestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet(milestoneId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the versions that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
         * @summary List defined versions for issues
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugVersionsGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVersions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugVersionsGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugVersionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specified issue tracker version object.
         * @summary Get a defined version for issues
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {number} versionId The version\&#39;s id
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugVersionsVersionIdGet(repoSlug: string, versionId: number, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugVersionsVersionIdGet(repoSlug, versionId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssueTrackerApi.repositoriesWorkspaceRepoSlugVersionsVersionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IssueTrackerApi - factory interface
 */
export const IssueTrackerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IssueTrackerApiFp(configuration)
    return {
        /**
         * Returns the specified issue tracker component object.
         * @summary Get a component for issues
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugComponentsComponentIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugComponentsComponentIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugComponentsComponentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Component> {
            return localVarFp.repositoriesWorkspaceRepoSlugComponentsComponentIdGet(requestParameters.componentId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the components that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
         * @summary List components
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugComponentsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugComponentsGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugComponentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedComponents> {
            return localVarFp.repositoriesWorkspaceRepoSlugComponentsGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * A POST request to this endpoint initiates a new background celery task that archives the repo\'s issues.  When the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the \'Location\' response header. This url is the endpoint for where the user can obtain their zip files.\"
         * @summary Export issues
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesExportPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesExportPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used to poll for the progress of an issue export job and return the zip file after the job is complete. As long as the job is running, this will return a 202 response with in the response body a description of the current status.  After the job has been scheduled, but before it starts executing, the endpoint returns a 202 response with status `ACCEPTED`.  Once it starts running, it is a 202 response with status `STARTED` and progress filled.  After it is finished, it becomes a 200 response with status `SUCCESS` or `FAILURE`.
         * @summary Check issue export status
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<IssueJobStatus> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet(requestParameters.repoName, requestParameters.repoSlug, requestParameters.taskId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the issues in the issue tracker.
         * @summary List issues
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedIssues> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * When using GET, this endpoint reports the status of the current import task.  After the job has been scheduled, but before it starts executing, the endpoint returns a 202 response with status `ACCEPTED`.  Once it starts running, it is a 202 response with status `STARTED` and progress filled.  After it is finished, it becomes a 200 response with status `SUCCESS` or `FAILURE`.
         * @summary Check issue import status
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesImportGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesImportGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesImportGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<IssueJobStatus> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesImportGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All existing issues will be deleted and replaced by the contents of the imported zip file.  Imports are done through a multipart/form-data POST. There is one valid and required form field, with the name \"archive,\" which needs to be a file field:  ``` $ curl -u <username> -X POST -F archive=@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import ```
         * @summary Import issues
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesImportPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesImportPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesImportPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<IssueJobStatus> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesImportPost(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all attachments for this issue.  This returns the files\' meta data. This does not return the files\' actual contents.  The files are always ordered by their upload date.
         * @summary List attachments for an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedIssueAttachments> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an attachment.
         * @summary Delete an attachment for an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete(requestParameters.issueId, requestParameters.path, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the contents of the specified file attachment.  Note that this endpoint does not return a JSON response, but instead returns a redirect pointing to the actual file that in turn will return the raw contents.  The redirect URL contains a one-time token that has a limited lifetime. As a result, the link should not be persisted, stored, or shared.
         * @summary Get attachment for an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet(requestParameters.issueId, requestParameters.path, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload new issue attachments.  To upload files, perform a `multipart/form-data` POST containing one or more file fields.  When a file is uploaded with the same name as an existing attachment, then the existing file will be replaced.
         * @summary Upload an attachment to an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified issue change object.  This resource is only available on repositories that have the issue tracker enabled.
         * @summary Get issue change object
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<IssueChange> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet(requestParameters.changeId, requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of all changes that have been made to the specified issue. Changes are returned in chronological order with the oldest change first.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the `/issues/123/changes` endpoint. It also has a comment associated with the change.  Note that this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api) for details.  Changes support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that can be used to search for specific changes. For instance, to see when an issue transitioned to \"resolved\":  ``` $ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \\    -G --data-urlencode=\'q=changes.state.new = \"resolved\"\' ```  This resource is only available on repositories that have the issue tracker enabled.  N.B.  The `changes.assignee` and `changes.assignee_account_id` fields are not a `user` object. Instead, they contain the raw `username` and `account_id` of the user. This is to protect the integrity of the audit log even after a user account gets deleted.  The `changes.assignee` field is deprecated will disappear in the future. Use `changes.assignee_account_id` instead.
         * @summary List changes on an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedLogEntries> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Makes a change to the specified issue.  For example, to change an issue\'s state and assignee, create a new change object that modifies these fields:  ``` curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \\   -s -u evzijst -X POST -H \"Content-Type: application/json\" \\   -d \'{     \"changes\": {       \"assignee_account_id\": {         \"new\": \"557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\"       },       \"state\": {         \"new\": \'resolved\"       }     }     \"message\": {       \"raw\": \"This is now resolved.\"     }   }\' ```  The above example also includes a custom comment to go alongside the change. This comment will also be visible on the issue page in the UI.  The fields of the `changes` object are strings, not objects. This allows for immutable change log records, even after user accounts, milestones, or other objects recorded in a change entry, get renamed or deleted.  The `assignee_account_id` field stores the account id. When POSTing a new change and changing the assignee, the client should therefore use the user\'s account_id in the `changes.assignee_account_id.new` field.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.
         * @summary Modify the state of an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<IssueChange> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified comment.
         * @summary Delete a comment on an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete(requestParameters.commentId, requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified issue comment object.
         * @summary Get a comment on an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<IssueComment> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet(requestParameters.commentId, requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the content of the specified issue comment. Note that only the `content.raw` field can be modified.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \\   -X PUT -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"Lorem ipsum.\"}\' ```
         * @summary Update a comment on an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<IssueComment> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut(requestParameters.commentId, requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all comments that were made on the specified issue.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List comments on an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedIssueComments> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new issue comment.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \\   -X POST -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"Lorem ipsum.\"}}\' ```
         * @summary Create a comment on an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified issue. This requires write access to the repository.
         * @summary Delete an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdDelete(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified issue.
         * @summary Get an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Issue> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdGet(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies the issue.  ``` $ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \\   -u evzijst -s -X PUT -H \'Content-Type: application/json\' \\   -d \'{   \"title\": \"Updated title\",   \"assignee\": {     \"account_id\": \"5d5355e8c6b9320d9ea5b28d\"   },   \"priority\": \"minor\",   \"version\": {     \"name\": \"1.0\"   },   \"component\": null }\' ```  This example changes the `title`, `assignee`, `priority` and the `version`. It also removes the value of the `component` from the issue by setting the field to `null`. Any field not present keeps its existing value.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the `/issues/123/changes` endpoint. It also has a comment associated with the change.
         * @summary Update an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdPut(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Issue> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdPut(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Retract your vote.
         * @summary Remove vote for an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelError> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Check whether the authenticated user has voted for this issue. A 204 status code indicates that the user has voted, while a 404 implies they haven\'t.
         * @summary Check if current user voted for an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelError> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Vote for this issue.  To cast your vote, do an empty PUT. The 204 status code indicates that the operation was successful.
         * @summary Vote for an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelError> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop watching this issue.
         * @summary Stop watching an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelError> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Indicated whether or not the authenticated user is watching this issue.
         * @summary Check if current user is watching a issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelError> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Start watching this issue.  To start watching this issue, do an empty PUT. The 204 status code indicates that the operation was successful.
         * @summary Watch an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelError> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new issue.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.  The authenticated user is used for the issue\'s `reporter` field.
         * @summary Create an issue
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugIssuesPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Issue> {
            return localVarFp.repositoriesWorkspaceRepoSlugIssuesPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the milestones that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
         * @summary List milestones
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugMilestonesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugMilestonesGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugMilestonesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedMilestones> {
            return localVarFp.repositoriesWorkspaceRepoSlugMilestonesGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified issue tracker milestone object.
         * @summary Get a milestone
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Milestone> {
            return localVarFp.repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet(requestParameters.milestoneId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the versions that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
         * @summary List defined versions for issues
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugVersionsGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugVersionsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedVersions> {
            return localVarFp.repositoriesWorkspaceRepoSlugVersionsGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified issue tracker version object.
         * @summary Get a defined version for issues
         * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugVersionsVersionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugVersionsVersionIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugVersionsVersionIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Version> {
            return localVarFp.repositoriesWorkspaceRepoSlugVersionsVersionIdGet(requestParameters.repoSlug, requestParameters.versionId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IssueTrackerApi - interface
 */
export interface IssueTrackerApiInterface {
    /**
     * Returns the specified issue tracker component object.
     * @summary Get a component for issues
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugComponentsComponentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugComponentsComponentIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugComponentsComponentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Component>;

    /**
     * Returns the components that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
     * @summary List components
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugComponentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugComponentsGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugComponentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedComponents>;

    /**
     * A POST request to this endpoint initiates a new background celery task that archives the repo\'s issues.  When the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the \'Location\' response header. This url is the endpoint for where the user can obtain their zip files.\"
     * @summary Export issues
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesExportPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * This endpoint is used to poll for the progress of an issue export job and return the zip file after the job is complete. As long as the job is running, this will return a 202 response with in the response body a description of the current status.  After the job has been scheduled, but before it starts executing, the endpoint returns a 202 response with status `ACCEPTED`.  Once it starts running, it is a 202 response with status `STARTED` and progress filled.  After it is finished, it becomes a 200 response with status `SUCCESS` or `FAILURE`.
     * @summary Check issue export status
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<IssueJobStatus>;

    /**
     * Returns the issues in the issue tracker.
     * @summary List issues
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedIssues>;

    /**
     * When using GET, this endpoint reports the status of the current import task.  After the job has been scheduled, but before it starts executing, the endpoint returns a 202 response with status `ACCEPTED`.  Once it starts running, it is a 202 response with status `STARTED` and progress filled.  After it is finished, it becomes a 200 response with status `SUCCESS` or `FAILURE`.
     * @summary Check issue import status
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesImportGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesImportGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesImportGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<IssueJobStatus>;

    /**
     * A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All existing issues will be deleted and replaced by the contents of the imported zip file.  Imports are done through a multipart/form-data POST. There is one valid and required form field, with the name \"archive,\" which needs to be a file field:  ``` $ curl -u <username> -X POST -F archive=@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import ```
     * @summary Import issues
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesImportPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesImportPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesImportPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<IssueJobStatus>;

    /**
     * Returns all attachments for this issue.  This returns the files\' meta data. This does not return the files\' actual contents.  The files are always ordered by their upload date.
     * @summary List attachments for an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedIssueAttachments>;

    /**
     * Deletes an attachment.
     * @summary Delete an attachment for an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the contents of the specified file attachment.  Note that this endpoint does not return a JSON response, but instead returns a redirect pointing to the actual file that in turn will return the raw contents.  The redirect URL contains a one-time token that has a limited lifetime. As a result, the link should not be persisted, stored, or shared.
     * @summary Get attachment for an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Upload new issue attachments.  To upload files, perform a `multipart/form-data` POST containing one or more file fields.  When a file is uploaded with the same name as an existing attachment, then the existing file will be replaced.
     * @summary Upload an attachment to an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the specified issue change object.  This resource is only available on repositories that have the issue tracker enabled.
     * @summary Get issue change object
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<IssueChange>;

    /**
     * Returns the list of all changes that have been made to the specified issue. Changes are returned in chronological order with the oldest change first.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the `/issues/123/changes` endpoint. It also has a comment associated with the change.  Note that this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api) for details.  Changes support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that can be used to search for specific changes. For instance, to see when an issue transitioned to \"resolved\":  ``` $ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \\    -G --data-urlencode=\'q=changes.state.new = \"resolved\"\' ```  This resource is only available on repositories that have the issue tracker enabled.  N.B.  The `changes.assignee` and `changes.assignee_account_id` fields are not a `user` object. Instead, they contain the raw `username` and `account_id` of the user. This is to protect the integrity of the audit log even after a user account gets deleted.  The `changes.assignee` field is deprecated will disappear in the future. Use `changes.assignee_account_id` instead.
     * @summary List changes on an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedLogEntries>;

    /**
     * Makes a change to the specified issue.  For example, to change an issue\'s state and assignee, create a new change object that modifies these fields:  ``` curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \\   -s -u evzijst -X POST -H \"Content-Type: application/json\" \\   -d \'{     \"changes\": {       \"assignee_account_id\": {         \"new\": \"557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\"       },       \"state\": {         \"new\": \'resolved\"       }     }     \"message\": {       \"raw\": \"This is now resolved.\"     }   }\' ```  The above example also includes a custom comment to go alongside the change. This comment will also be visible on the issue page in the UI.  The fields of the `changes` object are strings, not objects. This allows for immutable change log records, even after user accounts, milestones, or other objects recorded in a change entry, get renamed or deleted.  The `assignee_account_id` field stores the account id. When POSTing a new change and changing the assignee, the client should therefore use the user\'s account_id in the `changes.assignee_account_id.new` field.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.
     * @summary Modify the state of an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<IssueChange>;

    /**
     * Deletes the specified comment.
     * @summary Delete a comment on an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the specified issue comment object.
     * @summary Get a comment on an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<IssueComment>;

    /**
     * Updates the content of the specified issue comment. Note that only the `content.raw` field can be modified.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \\   -X PUT -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"Lorem ipsum.\"}\' ```
     * @summary Update a comment on an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<IssueComment>;

    /**
     * Returns a paginated list of all comments that were made on the specified issue.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary List comments on an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedIssueComments>;

    /**
     * Creates a new issue comment.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \\   -X POST -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"Lorem ipsum.\"}}\' ```
     * @summary Create a comment on an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Deletes the specified issue. This requires write access to the repository.
     * @summary Delete an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the specified issue.
     * @summary Get an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * Modifies the issue.  ``` $ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \\   -u evzijst -s -X PUT -H \'Content-Type: application/json\' \\   -d \'{   \"title\": \"Updated title\",   \"assignee\": {     \"account_id\": \"5d5355e8c6b9320d9ea5b28d\"   },   \"priority\": \"minor\",   \"version\": {     \"name\": \"1.0\"   },   \"component\": null }\' ```  This example changes the `title`, `assignee`, `priority` and the `version`. It also removes the value of the `component` from the issue by setting the field to `null`. Any field not present keeps its existing value.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the `/issues/123/changes` endpoint. It also has a comment associated with the change.
     * @summary Update an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdPut(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * Retract your vote.
     * @summary Remove vote for an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelError>;

    /**
     * Check whether the authenticated user has voted for this issue. A 204 status code indicates that the user has voted, while a 404 implies they haven\'t.
     * @summary Check if current user voted for an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelError>;

    /**
     * Vote for this issue.  To cast your vote, do an empty PUT. The 204 status code indicates that the operation was successful.
     * @summary Vote for an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelError>;

    /**
     * Stop watching this issue.
     * @summary Stop watching an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelError>;

    /**
     * Indicated whether or not the authenticated user is watching this issue.
     * @summary Check if current user is watching a issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelError>;

    /**
     * Start watching this issue.  To start watching this issue, do an empty PUT. The 204 status code indicates that the operation was successful.
     * @summary Watch an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelError>;

    /**
     * Creates a new issue.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.  The authenticated user is used for the issue\'s `reporter` field.
     * @summary Create an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugIssuesPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * Returns the milestones that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
     * @summary List milestones
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugMilestonesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugMilestonesGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugMilestonesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedMilestones>;

    /**
     * Returns the specified issue tracker milestone object.
     * @summary Get a milestone
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Milestone>;

    /**
     * Returns the versions that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
     * @summary List defined versions for issues
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugVersionsGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugVersionsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedVersions>;

    /**
     * Returns the specified issue tracker version object.
     * @summary Get a defined version for issues
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugVersionsVersionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugVersionsVersionIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugVersionsVersionIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Version>;

}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugComponentsComponentIdGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugComponentsComponentIdGetRequest {
    /**
     * The component\&#39;s id
     */
    readonly componentId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugComponentsGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugComponentsGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesExportPost operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The options to apply to the export. Available options include &#x60;project_key&#x60; and &#x60;project_name&#x60; which, if specified, are used as the project key and name in the exported Jira json format. Option &#x60;send_email&#x60; specifies whether an email should be sent upon export result. Option &#x60;include_attachments&#x60; specifies whether attachments are included in the export.
     */
    readonly body?: ExportOptions
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetRequest {
    /**
     * The name of the repo
     */
    readonly repoName: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * The ID of the export task
     */
    readonly taskId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesImportGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesImportGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesImportPost operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesImportPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * Path to the file.
     */
    readonly path: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * Path to the file.
     */
    readonly path: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetRequest {
    /**
     * The issue change id
     */
    readonly changeId: string

    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     *  Query string to narrow down the response. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details.
     */
    readonly q?: string

    /**
     *  Name of a response property to sort results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results) for details. 
     */
    readonly sort?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The new issue state change. The only required elements are &#x60;changes.[].new&#x60;. All other elements can be omitted from the body.
     */
    readonly body: IssueChange
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest {
    /**
     * The id of the comment.
     */
    readonly commentId: number

    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetRequest {
    /**
     * The id of the comment.
     */
    readonly commentId: number

    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest {
    /**
     * The id of the comment.
     */
    readonly commentId: number

    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The updated comment.
     */
    readonly body: IssueComment
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     *  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
     */
    readonly q?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The new issue comment object.
     */
    readonly body: IssueComment
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdDelete operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdGetRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdPut operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdPutRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutRequest {
    /**
     * The issue id
     */
    readonly issueId: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugIssuesPost operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The new issue. The only required element is &#x60;title&#x60;. All other elements can be omitted from the body.
     */
    readonly body: Issue
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugMilestonesGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugMilestonesGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetRequest {
    /**
     * The milestone\&#39;s id
     */
    readonly milestoneId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugVersionsGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugVersionsGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugVersionsVersionIdGet operation in IssueTrackerApi.
 */
export interface IssueTrackerApiRepositoriesWorkspaceRepoSlugVersionsVersionIdGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * The version\&#39;s id
     */
    readonly versionId: number

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * IssueTrackerApi - object-oriented interface
 */
export class IssueTrackerApi extends BaseAPI implements IssueTrackerApiInterface {
    /**
     * Returns the specified issue tracker component object.
     * @summary Get a component for issues
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugComponentsComponentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugComponentsComponentIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugComponentsComponentIdGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugComponentsComponentIdGet(requestParameters.componentId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the components that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
     * @summary List components
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugComponentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugComponentsGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugComponentsGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugComponentsGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A POST request to this endpoint initiates a new background celery task that archives the repo\'s issues.  When the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the \'Location\' response header. This url is the endpoint for where the user can obtain their zip files.\"
     * @summary Export issues
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesExportPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesExportPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used to poll for the progress of an issue export job and return the zip file after the job is complete. As long as the job is running, this will return a 202 response with in the response body a description of the current status.  After the job has been scheduled, but before it starts executing, the endpoint returns a 202 response with status `ACCEPTED`.  Once it starts running, it is a 202 response with status `STARTED` and progress filled.  After it is finished, it becomes a 200 response with status `SUCCESS` or `FAILURE`.
     * @summary Check issue export status
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet(requestParameters.repoName, requestParameters.repoSlug, requestParameters.taskId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the issues in the issue tracker.
     * @summary List issues
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When using GET, this endpoint reports the status of the current import task.  After the job has been scheduled, but before it starts executing, the endpoint returns a 202 response with status `ACCEPTED`.  Once it starts running, it is a 202 response with status `STARTED` and progress filled.  After it is finished, it becomes a 200 response with status `SUCCESS` or `FAILURE`.
     * @summary Check issue import status
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesImportGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesImportGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesImportGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesImportGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All existing issues will be deleted and replaced by the contents of the imported zip file.  Imports are done through a multipart/form-data POST. There is one valid and required form field, with the name \"archive,\" which needs to be a file field:  ``` $ curl -u <username> -X POST -F archive=@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import ```
     * @summary Import issues
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesImportPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesImportPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesImportPostRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesImportPost(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all attachments for this issue.  This returns the files\' meta data. This does not return the files\' actual contents.  The files are always ordered by their upload date.
     * @summary List attachments for an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an attachment.
     * @summary Delete an attachment for an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete(requestParameters.issueId, requestParameters.path, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the contents of the specified file attachment.  Note that this endpoint does not return a JSON response, but instead returns a redirect pointing to the actual file that in turn will return the raw contents.  The redirect URL contains a one-time token that has a limited lifetime. As a result, the link should not be persisted, stored, or shared.
     * @summary Get attachment for an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet(requestParameters.issueId, requestParameters.path, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload new issue attachments.  To upload files, perform a `multipart/form-data` POST containing one or more file fields.  When a file is uploaded with the same name as an existing attachment, then the existing file will be replaced.
     * @summary Upload an attachment to an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified issue change object.  This resource is only available on repositories that have the issue tracker enabled.
     * @summary Get issue change object
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet(requestParameters.changeId, requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of all changes that have been made to the specified issue. Changes are returned in chronological order with the oldest change first.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the `/issues/123/changes` endpoint. It also has a comment associated with the change.  Note that this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api) for details.  Changes support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that can be used to search for specific changes. For instance, to see when an issue transitioned to \"resolved\":  ``` $ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \\    -G --data-urlencode=\'q=changes.state.new = \"resolved\"\' ```  This resource is only available on repositories that have the issue tracker enabled.  N.B.  The `changes.assignee` and `changes.assignee_account_id` fields are not a `user` object. Instead, they contain the raw `username` and `account_id` of the user. This is to protect the integrity of the audit log even after a user account gets deleted.  The `changes.assignee` field is deprecated will disappear in the future. Use `changes.assignee_account_id` instead.
     * @summary List changes on an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Makes a change to the specified issue.  For example, to change an issue\'s state and assignee, create a new change object that modifies these fields:  ``` curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \\   -s -u evzijst -X POST -H \"Content-Type: application/json\" \\   -d \'{     \"changes\": {       \"assignee_account_id\": {         \"new\": \"557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\"       },       \"state\": {         \"new\": \'resolved\"       }     }     \"message\": {       \"raw\": \"This is now resolved.\"     }   }\' ```  The above example also includes a custom comment to go alongside the change. This comment will also be visible on the issue page in the UI.  The fields of the `changes` object are strings, not objects. This allows for immutable change log records, even after user accounts, milestones, or other objects recorded in a change entry, get renamed or deleted.  The `assignee_account_id` field stores the account id. When POSTing a new change and changing the assignee, the client should therefore use the user\'s account_id in the `changes.assignee_account_id.new` field.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.
     * @summary Modify the state of an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified comment.
     * @summary Delete a comment on an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete(requestParameters.commentId, requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified issue comment object.
     * @summary Get a comment on an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet(requestParameters.commentId, requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the content of the specified issue comment. Note that only the `content.raw` field can be modified.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \\   -X PUT -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"Lorem ipsum.\"}\' ```
     * @summary Update a comment on an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut(requestParameters.commentId, requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all comments that were made on the specified issue.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary List comments on an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new issue comment.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \\   -X POST -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"Lorem ipsum.\"}}\' ```
     * @summary Create a comment on an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified issue. This requires write access to the repository.
     * @summary Delete an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdDelete(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified issue.
     * @summary Get an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdGet(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies the issue.  ``` $ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \\   -u evzijst -s -X PUT -H \'Content-Type: application/json\' \\   -d \'{   \"title\": \"Updated title\",   \"assignee\": {     \"account_id\": \"5d5355e8c6b9320d9ea5b28d\"   },   \"priority\": \"minor\",   \"version\": {     \"name\": \"1.0\"   },   \"component\": null }\' ```  This example changes the `title`, `assignee`, `priority` and the `version`. It also removes the value of the `component` from the issue by setting the field to `null`. Any field not present keeps its existing value.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the `/issues/123/changes` endpoint. It also has a comment associated with the change.
     * @summary Update an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdPut(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdPutRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdPut(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retract your vote.
     * @summary Remove vote for an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check whether the authenticated user has voted for this issue. A 204 status code indicates that the user has voted, while a 404 implies they haven\'t.
     * @summary Check if current user voted for an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Vote for this issue.  To cast your vote, do an empty PUT. The 204 status code indicates that the operation was successful.
     * @summary Vote for an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop watching this issue.
     * @summary Stop watching an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Indicated whether or not the authenticated user is watching this issue.
     * @summary Check if current user is watching a issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start watching this issue.  To start watching this issue, do an empty PUT. The 204 status code indicates that the operation was successful.
     * @summary Watch an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut(requestParameters.issueId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new issue.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.  The authenticated user is used for the issue\'s `reporter` field.
     * @summary Create an issue
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugIssuesPost(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugIssuesPostRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugIssuesPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the milestones that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
     * @summary List milestones
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugMilestonesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugMilestonesGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugMilestonesGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugMilestonesGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified issue tracker milestone object.
     * @summary Get a milestone
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet(requestParameters.milestoneId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the versions that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
     * @summary List defined versions for issues
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugVersionsGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugVersionsGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugVersionsGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified issue tracker version object.
     * @summary Get a defined version for issues
     * @param {IssueTrackerApiRepositoriesWorkspaceRepoSlugVersionsVersionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugVersionsVersionIdGet(requestParameters: IssueTrackerApiRepositoriesWorkspaceRepoSlugVersionsVersionIdGetRequest, options?: RawAxiosRequestConfig) {
        return IssueTrackerApiFp(this.configuration).repositoriesWorkspaceRepoSlugVersionsVersionIdGet(requestParameters.repoSlug, requestParameters.versionId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PipelinesApi - axios parameter creator
 */
export const PipelinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a deployment environment level variable.
         * @summary Create a variable for an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} environmentUuid The environment.
         * @param {DeploymentVariable} body The variable to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeploymentVariable: async (workspace: string, repoSlug: string, environmentUuid: string, body: DeploymentVariable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createDeploymentVariable', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('createDeploymentVariable', 'repoSlug', repoSlug)
            // verify required parameter 'environmentUuid' is not null or undefined
            assertParamExists('createDeploymentVariable', 'environmentUuid', environmentUuid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createDeploymentVariable', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"environment_uuid"}}`, encodeURIComponent(String(environmentUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint to create and initiate a pipeline. There are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated. # Trigger a Pipeline for a branch One way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline. The specified branch will be used to determine which pipeline definition from the `bitbucket-pipelines.yml` file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\   -d \'   {     \"target\": {       \"ref_type\": \"branch\",       \"type\": \"pipeline_ref_target\",       \"ref_name\": \"master\"     }   }\' ``` # Trigger a Pipeline for a commit on a branch or tag You can initiate a pipeline for a specific commit and in the context of a specified reference (e.g. a branch, tag or bookmark). The specified reference will be used to determine which pipeline definition from the bitbucket-pipelines.yml file will be applied to initiate the pipeline. The pipeline will clone the repository and then do a checkout the specified reference.  The following reference types are supported:  * `branch` * `named_branch` * `bookmark`  * `tag`  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\   https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\   -d \'   {     \"target\": {       \"commit\": {         \"type\": \"commit\",         \"hash\": \"ce5b7431602f7cbba007062eeb55225c6e18e956\"       },       \"ref_type\": \"branch\",       \"type\": \"pipeline_ref_target\",       \"ref_name\": \"master\"     }   }\' ``` # Trigger a specific pipeline definition for a commit You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit. In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition. The resulting pipeline will then clone the repository and checkout the specified revision.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\  -d \'   {      \"target\": {       \"commit\": {          \"hash\":\"a3c4e02c9a3755eccdc3764e6ea13facdf30f923\",          \"type\":\"commit\"        },         \"selector\": {            \"type\":\"custom\",               \"pattern\":\"Deploy to production\"           },         \"type\":\"pipeline_commit_target\"    }   }\' ``` # Trigger a specific pipeline definition for a commit on a branch or tag You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit in the context of a specified reference. In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition, as well as the reference information. The resulting pipeline will then clone the repository a checkout the specified reference.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\  -d \'   {      \"target\": {       \"commit\": {          \"hash\":\"a3c4e02c9a3755eccdc3764e6ea13facdf30f923\",          \"type\":\"commit\"        },        \"selector\": {           \"type\": \"custom\",           \"pattern\": \"Deploy to production\"        },        \"type\": \"pipeline_ref_target\",        \"ref_name\": \"master\",        \"ref_type\": \"branch\"      }   }\' ```   # Trigger a custom pipeline with variables In addition to triggering a custom pipeline that is defined in your `bitbucket-pipelines.yml` file as shown in the examples above, you can specify variables that will be available for your build. In the request, provide a list of variables, specifying the following for each variable: key, value, and whether it should be secured or not (this field is optional and defaults to not secured).  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \\  -d \'   {     \"target\": {       \"type\": \"pipeline_ref_target\",       \"ref_type\": \"branch\",       \"ref_name\": \"master\",       \"selector\": {         \"type\": \"custom\",         \"pattern\": \"Deploy to production\"       }     },     \"variables\": [       {         \"key\": \"var1key\",         \"value\": \"var1value\",         \"secured\": true       },       {         \"key\": \"var2key\",         \"value\": \"var2value\"       }     ]   }\' ```  # Trigger a pull request pipeline  You can also initiate a pipeline for a specific pull request.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \\  -d \'   {     \"target\": {       \"type\": \"pipeline_pullrequest_target\",       \"source\": \"pull-request-branch\",       \"destination\": \"master\",       \"destination_commit\": {         \"hash\": \"9f848b7\"       },       \"commit\": {         \"hash\": \"1a372fc\"       },       \"pullrequest\": {         \"id\": \"3\"       },       \"selector\": {         \"type\": \"pull-requests\",         \"pattern\": \"**\"       }     }   }\' ``` 
         * @summary Run a pipeline
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {Pipeline} body The pipeline to initiate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineForRepository: async (workspace: string, repoSlug: string, body: Pipeline, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createPipelineForRepository', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('createPipelineForRepository', 'repoSlug', repoSlug)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createPipelineForRepository', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an account level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Create a variable for a user
         * @param {string} username The account.
         * @param {PipelineVariable} [body] The variable to create.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createPipelineVariableForTeam: async (username: string, body?: PipelineVariable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('createPipelineVariableForTeam', 'username', username)
            const localVarPath = `/teams/{username}/pipelines_config/variables`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Create a variable for a user
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {PipelineVariable} [body] The variable to create.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createPipelineVariableForUser: async (selectedUser: string, body?: PipelineVariable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('createPipelineVariableForUser', 'selectedUser', selectedUser)
            const localVarPath = `/users/{selected_user}/pipelines_config/variables`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a workspace level variable.
         * @summary Create a variable for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {PipelineVariable} [body] The variable to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineVariableForWorkspace: async (workspace: string, body?: PipelineVariable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createPipelineVariableForWorkspace', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/pipelines-config/variables`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a repository level known host.
         * @summary Create a known host
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {PipelineKnownHost} body The known host to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepositoryPipelineKnownHost: async (workspace: string, repoSlug: string, body: PipelineKnownHost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createRepositoryPipelineKnownHost', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('createRepositoryPipelineKnownHost', 'repoSlug', repoSlug)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createRepositoryPipelineKnownHost', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a schedule for the given repository.
         * @summary Create a schedule
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {PipelineSchedulePostRequestBody} body The schedule to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepositoryPipelineSchedule: async (workspace: string, repoSlug: string, body: PipelineSchedulePostRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createRepositoryPipelineSchedule', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('createRepositoryPipelineSchedule', 'repoSlug', repoSlug)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createRepositoryPipelineSchedule', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/schedules`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a repository level variable.
         * @summary Create a variable for a repository
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {PipelineVariable} body The variable to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepositoryPipelineVariable: async (workspace: string, repoSlug: string, body: PipelineVariable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createRepositoryPipelineVariable', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('createRepositoryPipelineVariable', 'repoSlug', repoSlug)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createRepositoryPipelineVariable', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/variables`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a deployment environment level variable.
         * @summary Delete a variable for an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} environmentUuid The environment.
         * @param {string} variableUuid The UUID of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeploymentVariable: async (workspace: string, repoSlug: string, environmentUuid: string, variableUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteDeploymentVariable', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deleteDeploymentVariable', 'repoSlug', repoSlug)
            // verify required parameter 'environmentUuid' is not null or undefined
            assertParamExists('deleteDeploymentVariable', 'environmentUuid', environmentUuid)
            // verify required parameter 'variableUuid' is not null or undefined
            assertParamExists('deleteDeploymentVariable', 'variableUuid', variableUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables/{variable_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"environment_uuid"}}`, encodeURIComponent(String(environmentUuid)))
                .replace(`{${"variable_uuid"}}`, encodeURIComponent(String(variableUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Delete a variable for a team
         * @param {string} username The account.
         * @param {string} variableUuid The UUID of the variable to delete.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deletePipelineVariableForTeam: async (username: string, variableUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deletePipelineVariableForTeam', 'username', username)
            // verify required parameter 'variableUuid' is not null or undefined
            assertParamExists('deletePipelineVariableForTeam', 'variableUuid', variableUuid)
            const localVarPath = `/teams/{username}/pipelines_config/variables/{variable_uuid}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"variable_uuid"}}`, encodeURIComponent(String(variableUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an account level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Delete a variable for a user
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {string} variableUuid The UUID of the variable to delete.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deletePipelineVariableForUser: async (selectedUser: string, variableUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('deletePipelineVariableForUser', 'selectedUser', selectedUser)
            // verify required parameter 'variableUuid' is not null or undefined
            assertParamExists('deletePipelineVariableForUser', 'variableUuid', variableUuid)
            const localVarPath = `/users/{selected_user}/pipelines_config/variables/{variable_uuid}`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)))
                .replace(`{${"variable_uuid"}}`, encodeURIComponent(String(variableUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a workspace level variable.
         * @summary Delete a variable for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} variableUuid The UUID of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineVariableForWorkspace: async (workspace: string, variableUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deletePipelineVariableForWorkspace', 'workspace', workspace)
            // verify required parameter 'variableUuid' is not null or undefined
            assertParamExists('deletePipelineVariableForWorkspace', 'variableUuid', variableUuid)
            const localVarPath = `/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"variable_uuid"}}`, encodeURIComponent(String(variableUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a repository cache.
         * @summary Delete a cache
         * @param {string} workspace The account.
         * @param {string} repoSlug The repository.
         * @param {string} cacheUuid The UUID of the cache to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryPipelineCache: async (workspace: string, repoSlug: string, cacheUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteRepositoryPipelineCache', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deleteRepositoryPipelineCache', 'repoSlug', repoSlug)
            // verify required parameter 'cacheUuid' is not null or undefined
            assertParamExists('deleteRepositoryPipelineCache', 'cacheUuid', cacheUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines-config/caches/{cache_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"cache_uuid"}}`, encodeURIComponent(String(cacheUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete repository cache versions by name.
         * @summary Delete caches
         * @param {string} workspace The account.
         * @param {string} repoSlug The repository.
         * @param {string} name The cache name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryPipelineCaches: async (workspace: string, repoSlug: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteRepositoryPipelineCaches', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deleteRepositoryPipelineCaches', 'repoSlug', repoSlug)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteRepositoryPipelineCaches', 'name', name)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines-config/caches`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the repository SSH key pair.
         * @summary Delete SSH key pair
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryPipelineKeyPair: async (workspace: string, repoSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteRepositoryPipelineKeyPair', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deleteRepositoryPipelineKeyPair', 'repoSlug', repoSlug)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a repository level known host.
         * @summary Delete a known host
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} knownHostUuid The UUID of the known host to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryPipelineKnownHost: async (workspace: string, repoSlug: string, knownHostUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteRepositoryPipelineKnownHost', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deleteRepositoryPipelineKnownHost', 'repoSlug', repoSlug)
            // verify required parameter 'knownHostUuid' is not null or undefined
            assertParamExists('deleteRepositoryPipelineKnownHost', 'knownHostUuid', knownHostUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"known_host_uuid"}}`, encodeURIComponent(String(knownHostUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a schedule.
         * @summary Delete a schedule
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} scheduleUuid The uuid of the schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryPipelineSchedule: async (workspace: string, repoSlug: string, scheduleUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteRepositoryPipelineSchedule', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deleteRepositoryPipelineSchedule', 'repoSlug', repoSlug)
            // verify required parameter 'scheduleUuid' is not null or undefined
            assertParamExists('deleteRepositoryPipelineSchedule', 'scheduleUuid', scheduleUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"schedule_uuid"}}`, encodeURIComponent(String(scheduleUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a repository level variable.
         * @summary Delete a variable for a repository
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} variableUuid The UUID of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryPipelineVariable: async (workspace: string, repoSlug: string, variableUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteRepositoryPipelineVariable', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deleteRepositoryPipelineVariable', 'repoSlug', repoSlug)
            // verify required parameter 'variableUuid' is not null or undefined
            assertParamExists('deleteRepositoryPipelineVariable', 'variableUuid', variableUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"variable_uuid"}}`, encodeURIComponent(String(variableUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find deployment environment level variables.
         * @summary List variables for an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} environmentUuid The environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentVariables: async (workspace: string, repoSlug: string, environmentUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getDeploymentVariables', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getDeploymentVariables', 'repoSlug', repoSlug)
            // verify required parameter 'environmentUuid' is not null or undefined
            assertParamExists('getDeploymentVariables', 'environmentUuid', environmentUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"environment_uuid"}}`, encodeURIComponent(String(environmentUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
         * @summary Get OpenID configuration for OIDC in Pipelines
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOIDCConfiguration: async (workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getOIDCConfiguration', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/pipelines-config/identity/oidc/.well-known/openid-configuration`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
         * @summary Get keys for OIDC in Pipelines
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOIDCKeys: async (workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getOIDCKeys', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/pipelines-config/identity/oidc/keys.json`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the log file for a build container or service container.  This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
         * @summary Get the logs for the build container or a service container for a given step of a pipeline.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {string} stepUuid The UUID of the step.
         * @param {string} logUuid For the main build container specify the step UUID; for a service container specify the service container UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineContainerLog: async (workspace: string, repoSlug: string, pipelineUuid: string, stepUuid: string, logUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getPipelineContainerLog', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getPipelineContainerLog', 'repoSlug', repoSlug)
            // verify required parameter 'pipelineUuid' is not null or undefined
            assertParamExists('getPipelineContainerLog', 'pipelineUuid', pipelineUuid)
            // verify required parameter 'stepUuid' is not null or undefined
            assertParamExists('getPipelineContainerLog', 'stepUuid', stepUuid)
            // verify required parameter 'logUuid' is not null or undefined
            assertParamExists('getPipelineContainerLog', 'logUuid', logUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/logs/{log_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"pipeline_uuid"}}`, encodeURIComponent(String(pipelineUuid)))
                .replace(`{${"step_uuid"}}`, encodeURIComponent(String(stepUuid)))
                .replace(`{${"log_uuid"}}`, encodeURIComponent(String(logUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specified pipeline
         * @summary Get a pipeline
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The pipeline UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineForRepository: async (workspace: string, repoSlug: string, pipelineUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getPipelineForRepository', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getPipelineForRepository', 'repoSlug', repoSlug)
            // verify required parameter 'pipelineUuid' is not null or undefined
            assertParamExists('getPipelineForRepository', 'pipelineUuid', pipelineUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"pipeline_uuid"}}`, encodeURIComponent(String(pipelineUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a given step of a pipeline.
         * @summary Get a step of a pipeline
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {string} stepUuid The UUID of the step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineStepForRepository: async (workspace: string, repoSlug: string, pipelineUuid: string, stepUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getPipelineStepForRepository', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getPipelineStepForRepository', 'repoSlug', repoSlug)
            // verify required parameter 'pipelineUuid' is not null or undefined
            assertParamExists('getPipelineStepForRepository', 'pipelineUuid', pipelineUuid)
            // verify required parameter 'stepUuid' is not null or undefined
            assertParamExists('getPipelineStepForRepository', 'stepUuid', stepUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"pipeline_uuid"}}`, encodeURIComponent(String(pipelineUuid)))
                .replace(`{${"step_uuid"}}`, encodeURIComponent(String(stepUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the log file for a given step of a pipeline.  This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
         * @summary Get log file for a step
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {string} stepUuid The UUID of the step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineStepLogForRepository: async (workspace: string, repoSlug: string, pipelineUuid: string, stepUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getPipelineStepLogForRepository', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getPipelineStepLogForRepository', 'repoSlug', repoSlug)
            // verify required parameter 'pipelineUuid' is not null or undefined
            assertParamExists('getPipelineStepLogForRepository', 'pipelineUuid', pipelineUuid)
            // verify required parameter 'stepUuid' is not null or undefined
            assertParamExists('getPipelineStepLogForRepository', 'stepUuid', stepUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/log`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"pipeline_uuid"}}`, encodeURIComponent(String(pipelineUuid)))
                .replace(`{${"step_uuid"}}`, encodeURIComponent(String(stepUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find steps for the given pipeline.
         * @summary List steps for a pipeline
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineStepsForRepository: async (workspace: string, repoSlug: string, pipelineUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getPipelineStepsForRepository', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getPipelineStepsForRepository', 'repoSlug', repoSlug)
            // verify required parameter 'pipelineUuid' is not null or undefined
            assertParamExists('getPipelineStepsForRepository', 'pipelineUuid', pipelineUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"pipeline_uuid"}}`, encodeURIComponent(String(pipelineUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get test case reasons (output) for a given test case in a step of a pipeline.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {string} stepUuid The UUID of the step.
         * @param {string} testCaseUuid The UUID of the test case.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineTestReportTestCaseReasons: async (workspace: string, repoSlug: string, pipelineUuid: string, stepUuid: string, testCaseUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getPipelineTestReportTestCaseReasons', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getPipelineTestReportTestCaseReasons', 'repoSlug', repoSlug)
            // verify required parameter 'pipelineUuid' is not null or undefined
            assertParamExists('getPipelineTestReportTestCaseReasons', 'pipelineUuid', pipelineUuid)
            // verify required parameter 'stepUuid' is not null or undefined
            assertParamExists('getPipelineTestReportTestCaseReasons', 'stepUuid', stepUuid)
            // verify required parameter 'testCaseUuid' is not null or undefined
            assertParamExists('getPipelineTestReportTestCaseReasons', 'testCaseUuid', testCaseUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports/test_cases/{test_case_uuid}/test_case_reasons`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"pipeline_uuid"}}`, encodeURIComponent(String(pipelineUuid)))
                .replace(`{${"step_uuid"}}`, encodeURIComponent(String(stepUuid)))
                .replace(`{${"test_case_uuid"}}`, encodeURIComponent(String(testCaseUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get test cases for a given step of a pipeline.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {string} stepUuid The UUID of the step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineTestReportTestCases: async (workspace: string, repoSlug: string, pipelineUuid: string, stepUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getPipelineTestReportTestCases', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getPipelineTestReportTestCases', 'repoSlug', repoSlug)
            // verify required parameter 'pipelineUuid' is not null or undefined
            assertParamExists('getPipelineTestReportTestCases', 'pipelineUuid', pipelineUuid)
            // verify required parameter 'stepUuid' is not null or undefined
            assertParamExists('getPipelineTestReportTestCases', 'stepUuid', stepUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports/test_cases`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"pipeline_uuid"}}`, encodeURIComponent(String(pipelineUuid)))
                .replace(`{${"step_uuid"}}`, encodeURIComponent(String(stepUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a summary of test reports for a given step of a pipeline.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {string} stepUuid The UUID of the step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineTestReports: async (workspace: string, repoSlug: string, pipelineUuid: string, stepUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getPipelineTestReports', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getPipelineTestReports', 'repoSlug', repoSlug)
            // verify required parameter 'pipelineUuid' is not null or undefined
            assertParamExists('getPipelineTestReports', 'pipelineUuid', pipelineUuid)
            // verify required parameter 'stepUuid' is not null or undefined
            assertParamExists('getPipelineTestReports', 'stepUuid', stepUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"pipeline_uuid"}}`, encodeURIComponent(String(pipelineUuid)))
                .replace(`{${"step_uuid"}}`, encodeURIComponent(String(stepUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Get a variable for a team
         * @param {string} username The account.
         * @param {string} variableUuid The UUID of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPipelineVariableForTeam: async (username: string, variableUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getPipelineVariableForTeam', 'username', username)
            // verify required parameter 'variableUuid' is not null or undefined
            assertParamExists('getPipelineVariableForTeam', 'variableUuid', variableUuid)
            const localVarPath = `/teams/{username}/pipelines_config/variables/{variable_uuid}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"variable_uuid"}}`, encodeURIComponent(String(variableUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Get a variable for a user
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {string} variableUuid The UUID of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPipelineVariableForUser: async (selectedUser: string, variableUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('getPipelineVariableForUser', 'selectedUser', selectedUser)
            // verify required parameter 'variableUuid' is not null or undefined
            assertParamExists('getPipelineVariableForUser', 'variableUuid', variableUuid)
            const localVarPath = `/users/{selected_user}/pipelines_config/variables/{variable_uuid}`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)))
                .replace(`{${"variable_uuid"}}`, encodeURIComponent(String(variableUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a workspace level variable.
         * @summary Get variable for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} variableUuid The UUID of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineVariableForWorkspace: async (workspace: string, variableUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getPipelineVariableForWorkspace', 'workspace', workspace)
            // verify required parameter 'variableUuid' is not null or undefined
            assertParamExists('getPipelineVariableForWorkspace', 'variableUuid', variableUuid)
            const localVarPath = `/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"variable_uuid"}}`, encodeURIComponent(String(variableUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find account level variables. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary List variables for an account
         * @param {string} username The account.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPipelineVariablesForTeam: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getPipelineVariablesForTeam', 'username', username)
            const localVarPath = `/teams/{username}/pipelines_config/variables`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find user level variables. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary List variables for a user
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPipelineVariablesForUser: async (selectedUser: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('getPipelineVariablesForUser', 'selectedUser', selectedUser)
            const localVarPath = `/users/{selected_user}/pipelines_config/variables`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find workspace level variables.
         * @summary List variables for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineVariablesForWorkspace: async (workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getPipelineVariablesForWorkspace', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/pipelines-config/variables`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find pipelines in a repository.  Note that unlike other endpoints in the Bitbucket API, this endpoint utilizes query parameters to allow filtering and sorting of returned results. See [query parameters](#api-repositories-workspace-repo-slug-pipelines-get-request-Query%20parameters) for specific details. 
         * @summary List pipelines
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} [creatorUuid] The UUID of the creator of the pipeline to filter by.
         * @param {GetPipelinesForRepositoryTargetRefTypeEnum} [targetRefType] The type of the reference to filter by.
         * @param {string} [targetRefName] The reference name to filter by.
         * @param {string} [targetBranch] The name of the branch to filter by.
         * @param {string} [targetCommitHash] The revision to filter by.
         * @param {string} [targetSelectorPattern] The pipeline pattern to filter by.
         * @param {GetPipelinesForRepositoryTargetSelectorTypeEnum} [targetSelectorType] The type of pipeline to filter by.
         * @param {string} [createdOn] The creation date to filter by.
         * @param {GetPipelinesForRepositoryTriggerTypeEnum} [triggerType] The trigger type to filter by.
         * @param {GetPipelinesForRepositoryStatusEnum} [status] The pipeline status to filter by.
         * @param {GetPipelinesForRepositorySortEnum} [sort] The attribute name to sort on.
         * @param {number} [page] The page number of elements to retrieve.
         * @param {number} [pagelen] The maximum number of results to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelinesForRepository: async (workspace: string, repoSlug: string, creatorUuid?: string, targetRefType?: GetPipelinesForRepositoryTargetRefTypeEnum, targetRefName?: string, targetBranch?: string, targetCommitHash?: string, targetSelectorPattern?: string, targetSelectorType?: GetPipelinesForRepositoryTargetSelectorTypeEnum, createdOn?: string, triggerType?: GetPipelinesForRepositoryTriggerTypeEnum, status?: GetPipelinesForRepositoryStatusEnum, sort?: GetPipelinesForRepositorySortEnum, page?: number, pagelen?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getPipelinesForRepository', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getPipelinesForRepository', 'repoSlug', repoSlug)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (creatorUuid !== undefined) {
                localVarQueryParameter['creator.uuid'] = creatorUuid;
            }

            if (targetRefType !== undefined) {
                localVarQueryParameter['target.ref_type'] = targetRefType;
            }

            if (targetRefName !== undefined) {
                localVarQueryParameter['target.ref_name'] = targetRefName;
            }

            if (targetBranch !== undefined) {
                localVarQueryParameter['target.branch'] = targetBranch;
            }

            if (targetCommitHash !== undefined) {
                localVarQueryParameter['target.commit.hash'] = targetCommitHash;
            }

            if (targetSelectorPattern !== undefined) {
                localVarQueryParameter['target.selector.pattern'] = targetSelectorPattern;
            }

            if (targetSelectorType !== undefined) {
                localVarQueryParameter['target.selector.type'] = targetSelectorType;
            }

            if (createdOn !== undefined) {
                localVarQueryParameter['created_on'] = (createdOn as any instanceof Date) ?
                    (createdOn as any).toISOString() :
                    createdOn;
            }

            if (triggerType !== undefined) {
                localVarQueryParameter['trigger_type'] = triggerType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pagelen !== undefined) {
                localVarQueryParameter['pagelen'] = pagelen;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the URI of the content of the specified cache.
         * @summary Get cache content URI
         * @param {string} workspace The account.
         * @param {string} repoSlug The repository.
         * @param {string} cacheUuid The UUID of the cache.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineCacheContentURI: async (workspace: string, repoSlug: string, cacheUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getRepositoryPipelineCacheContentURI', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getRepositoryPipelineCacheContentURI', 'repoSlug', repoSlug)
            // verify required parameter 'cacheUuid' is not null or undefined
            assertParamExists('getRepositoryPipelineCacheContentURI', 'cacheUuid', cacheUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines-config/caches/{cache_uuid}/content-uri`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"cache_uuid"}}`, encodeURIComponent(String(cacheUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the repository pipelines caches.
         * @summary List caches
         * @param {string} workspace The account.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineCaches: async (workspace: string, repoSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getRepositoryPipelineCaches', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getRepositoryPipelineCaches', 'repoSlug', repoSlug)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines-config/caches`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the repository pipelines configuration.
         * @summary Get configuration
         * @param {string} workspace The account.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineConfig: async (workspace: string, repoSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getRepositoryPipelineConfig', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getRepositoryPipelineConfig', 'repoSlug', repoSlug)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a repository level known host.
         * @summary Get a known host
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} knownHostUuid The UUID of the known host to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineKnownHost: async (workspace: string, repoSlug: string, knownHostUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getRepositoryPipelineKnownHost', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getRepositoryPipelineKnownHost', 'repoSlug', repoSlug)
            // verify required parameter 'knownHostUuid' is not null or undefined
            assertParamExists('getRepositoryPipelineKnownHost', 'knownHostUuid', knownHostUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"known_host_uuid"}}`, encodeURIComponent(String(knownHostUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find repository level known hosts.
         * @summary List known hosts
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineKnownHosts: async (workspace: string, repoSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getRepositoryPipelineKnownHosts', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getRepositoryPipelineKnownHosts', 'repoSlug', repoSlug)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a schedule by its UUID.
         * @summary Get a schedule
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} scheduleUuid The uuid of the schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineSchedule: async (workspace: string, repoSlug: string, scheduleUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getRepositoryPipelineSchedule', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getRepositoryPipelineSchedule', 'repoSlug', repoSlug)
            // verify required parameter 'scheduleUuid' is not null or undefined
            assertParamExists('getRepositoryPipelineSchedule', 'scheduleUuid', scheduleUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"schedule_uuid"}}`, encodeURIComponent(String(scheduleUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the executions of a given schedule.
         * @summary List executions of a schedule
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} scheduleUuid The uuid of the schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineScheduleExecutions: async (workspace: string, repoSlug: string, scheduleUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getRepositoryPipelineScheduleExecutions', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getRepositoryPipelineScheduleExecutions', 'repoSlug', repoSlug)
            // verify required parameter 'scheduleUuid' is not null or undefined
            assertParamExists('getRepositoryPipelineScheduleExecutions', 'scheduleUuid', scheduleUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}/executions`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"schedule_uuid"}}`, encodeURIComponent(String(scheduleUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the configured schedules for the given repository.
         * @summary List schedules
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineSchedules: async (workspace: string, repoSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getRepositoryPipelineSchedules', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getRepositoryPipelineSchedules', 'repoSlug', repoSlug)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/schedules`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.
         * @summary Get SSH key pair
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineSshKeyPair: async (workspace: string, repoSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getRepositoryPipelineSshKeyPair', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getRepositoryPipelineSshKeyPair', 'repoSlug', repoSlug)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a repository level variable.
         * @summary Get a variable for a repository
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} variableUuid The UUID of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineVariable: async (workspace: string, repoSlug: string, variableUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getRepositoryPipelineVariable', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getRepositoryPipelineVariable', 'repoSlug', repoSlug)
            // verify required parameter 'variableUuid' is not null or undefined
            assertParamExists('getRepositoryPipelineVariable', 'variableUuid', variableUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"variable_uuid"}}`, encodeURIComponent(String(variableUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find repository level variables.
         * @summary List variables for a repository
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineVariables: async (workspace: string, repoSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getRepositoryPipelineVariables', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getRepositoryPipelineVariables', 'repoSlug', repoSlug)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/variables`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Signal the stop of a pipeline and all of its steps that not have completed yet.
         * @summary Stop a pipeline
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopPipeline: async (workspace: string, repoSlug: string, pipelineUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('stopPipeline', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('stopPipeline', 'repoSlug', repoSlug)
            // verify required parameter 'pipelineUuid' is not null or undefined
            assertParamExists('stopPipeline', 'pipelineUuid', pipelineUuid)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/stopPipeline`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"pipeline_uuid"}}`, encodeURIComponent(String(pipelineUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a deployment environment level variable.
         * @summary Update a variable for an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} environmentUuid The environment.
         * @param {string} variableUuid The UUID of the variable to update.
         * @param {DeploymentVariable} body The updated deployment variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeploymentVariable: async (workspace: string, repoSlug: string, environmentUuid: string, variableUuid: string, body: DeploymentVariable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateDeploymentVariable', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('updateDeploymentVariable', 'repoSlug', repoSlug)
            // verify required parameter 'environmentUuid' is not null or undefined
            assertParamExists('updateDeploymentVariable', 'environmentUuid', environmentUuid)
            // verify required parameter 'variableUuid' is not null or undefined
            assertParamExists('updateDeploymentVariable', 'variableUuid', variableUuid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateDeploymentVariable', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables/{variable_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"environment_uuid"}}`, encodeURIComponent(String(environmentUuid)))
                .replace(`{${"variable_uuid"}}`, encodeURIComponent(String(variableUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Update a variable for a team
         * @param {string} username The account.
         * @param {string} variableUuid The UUID of the variable.
         * @param {PipelineVariable} body The updated variable.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePipelineVariableForTeam: async (username: string, variableUuid: string, body: PipelineVariable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updatePipelineVariableForTeam', 'username', username)
            // verify required parameter 'variableUuid' is not null or undefined
            assertParamExists('updatePipelineVariableForTeam', 'variableUuid', variableUuid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updatePipelineVariableForTeam', 'body', body)
            const localVarPath = `/teams/{username}/pipelines_config/variables/{variable_uuid}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"variable_uuid"}}`, encodeURIComponent(String(variableUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Update a variable for a user
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {string} variableUuid The UUID of the variable.
         * @param {PipelineVariable} body The updated variable.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePipelineVariableForUser: async (selectedUser: string, variableUuid: string, body: PipelineVariable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('updatePipelineVariableForUser', 'selectedUser', selectedUser)
            // verify required parameter 'variableUuid' is not null or undefined
            assertParamExists('updatePipelineVariableForUser', 'variableUuid', variableUuid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updatePipelineVariableForUser', 'body', body)
            const localVarPath = `/users/{selected_user}/pipelines_config/variables/{variable_uuid}`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)))
                .replace(`{${"variable_uuid"}}`, encodeURIComponent(String(variableUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a workspace level variable.
         * @summary Update variable for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} variableUuid The UUID of the variable.
         * @param {PipelineVariable} body The updated variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipelineVariableForWorkspace: async (workspace: string, variableUuid: string, body: PipelineVariable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updatePipelineVariableForWorkspace', 'workspace', workspace)
            // verify required parameter 'variableUuid' is not null or undefined
            assertParamExists('updatePipelineVariableForWorkspace', 'variableUuid', variableUuid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updatePipelineVariableForWorkspace', 'body', body)
            const localVarPath = `/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"variable_uuid"}}`, encodeURIComponent(String(variableUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.
         * @summary Update the next build number
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {PipelineBuildNumber} body The build number to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepositoryBuildNumber: async (workspace: string, repoSlug: string, body: PipelineBuildNumber, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateRepositoryBuildNumber', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('updateRepositoryBuildNumber', 'repoSlug', repoSlug)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateRepositoryBuildNumber', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/build_number`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the pipelines configuration for a repository.
         * @summary Update configuration
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {PipelinesConfig} body The updated repository pipelines configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepositoryPipelineConfig: async (workspace: string, repoSlug: string, body: PipelinesConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateRepositoryPipelineConfig', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('updateRepositoryPipelineConfig', 'repoSlug', repoSlug)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateRepositoryPipelineConfig', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.
         * @summary Update SSH key pair
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {PipelineSshKeyPair} body The created or updated SSH key pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepositoryPipelineKeyPair: async (workspace: string, repoSlug: string, body: PipelineSshKeyPair, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateRepositoryPipelineKeyPair', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('updateRepositoryPipelineKeyPair', 'repoSlug', repoSlug)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateRepositoryPipelineKeyPair', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a repository level known host.
         * @summary Update a known host
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} knownHostUuid The UUID of the known host to update.
         * @param {PipelineKnownHost} body The updated known host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepositoryPipelineKnownHost: async (workspace: string, repoSlug: string, knownHostUuid: string, body: PipelineKnownHost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateRepositoryPipelineKnownHost', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('updateRepositoryPipelineKnownHost', 'repoSlug', repoSlug)
            // verify required parameter 'knownHostUuid' is not null or undefined
            assertParamExists('updateRepositoryPipelineKnownHost', 'knownHostUuid', knownHostUuid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateRepositoryPipelineKnownHost', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"known_host_uuid"}}`, encodeURIComponent(String(knownHostUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a schedule.
         * @summary Update a schedule
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} scheduleUuid The uuid of the schedule.
         * @param {PipelineSchedulePutRequestBody} body The schedule to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepositoryPipelineSchedule: async (workspace: string, repoSlug: string, scheduleUuid: string, body: PipelineSchedulePutRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateRepositoryPipelineSchedule', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('updateRepositoryPipelineSchedule', 'repoSlug', repoSlug)
            // verify required parameter 'scheduleUuid' is not null or undefined
            assertParamExists('updateRepositoryPipelineSchedule', 'scheduleUuid', scheduleUuid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateRepositoryPipelineSchedule', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"schedule_uuid"}}`, encodeURIComponent(String(scheduleUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a repository level variable.
         * @summary Update a variable for a repository
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} variableUuid The UUID of the variable to update.
         * @param {PipelineVariable} body The updated variable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepositoryPipelineVariable: async (workspace: string, repoSlug: string, variableUuid: string, body: PipelineVariable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateRepositoryPipelineVariable', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('updateRepositoryPipelineVariable', 'repoSlug', repoSlug)
            // verify required parameter 'variableUuid' is not null or undefined
            assertParamExists('updateRepositoryPipelineVariable', 'variableUuid', variableUuid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateRepositoryPipelineVariable', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"variable_uuid"}}`, encodeURIComponent(String(variableUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pipeline:variable"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelinesApi - functional programming interface
 */
export const PipelinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PipelinesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a deployment environment level variable.
         * @summary Create a variable for an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} environmentUuid The environment.
         * @param {DeploymentVariable} body The variable to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeploymentVariable(workspace: string, repoSlug: string, environmentUuid: string, body: DeploymentVariable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeploymentVariable(workspace, repoSlug, environmentUuid, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.createDeploymentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint to create and initiate a pipeline. There are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated. # Trigger a Pipeline for a branch One way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline. The specified branch will be used to determine which pipeline definition from the `bitbucket-pipelines.yml` file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\   -d \'   {     \"target\": {       \"ref_type\": \"branch\",       \"type\": \"pipeline_ref_target\",       \"ref_name\": \"master\"     }   }\' ``` # Trigger a Pipeline for a commit on a branch or tag You can initiate a pipeline for a specific commit and in the context of a specified reference (e.g. a branch, tag or bookmark). The specified reference will be used to determine which pipeline definition from the bitbucket-pipelines.yml file will be applied to initiate the pipeline. The pipeline will clone the repository and then do a checkout the specified reference.  The following reference types are supported:  * `branch` * `named_branch` * `bookmark`  * `tag`  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\   https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\   -d \'   {     \"target\": {       \"commit\": {         \"type\": \"commit\",         \"hash\": \"ce5b7431602f7cbba007062eeb55225c6e18e956\"       },       \"ref_type\": \"branch\",       \"type\": \"pipeline_ref_target\",       \"ref_name\": \"master\"     }   }\' ``` # Trigger a specific pipeline definition for a commit You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit. In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition. The resulting pipeline will then clone the repository and checkout the specified revision.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\  -d \'   {      \"target\": {       \"commit\": {          \"hash\":\"a3c4e02c9a3755eccdc3764e6ea13facdf30f923\",          \"type\":\"commit\"        },         \"selector\": {            \"type\":\"custom\",               \"pattern\":\"Deploy to production\"           },         \"type\":\"pipeline_commit_target\"    }   }\' ``` # Trigger a specific pipeline definition for a commit on a branch or tag You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit in the context of a specified reference. In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition, as well as the reference information. The resulting pipeline will then clone the repository a checkout the specified reference.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\  -d \'   {      \"target\": {       \"commit\": {          \"hash\":\"a3c4e02c9a3755eccdc3764e6ea13facdf30f923\",          \"type\":\"commit\"        },        \"selector\": {           \"type\": \"custom\",           \"pattern\": \"Deploy to production\"        },        \"type\": \"pipeline_ref_target\",        \"ref_name\": \"master\",        \"ref_type\": \"branch\"      }   }\' ```   # Trigger a custom pipeline with variables In addition to triggering a custom pipeline that is defined in your `bitbucket-pipelines.yml` file as shown in the examples above, you can specify variables that will be available for your build. In the request, provide a list of variables, specifying the following for each variable: key, value, and whether it should be secured or not (this field is optional and defaults to not secured).  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \\  -d \'   {     \"target\": {       \"type\": \"pipeline_ref_target\",       \"ref_type\": \"branch\",       \"ref_name\": \"master\",       \"selector\": {         \"type\": \"custom\",         \"pattern\": \"Deploy to production\"       }     },     \"variables\": [       {         \"key\": \"var1key\",         \"value\": \"var1value\",         \"secured\": true       },       {         \"key\": \"var2key\",         \"value\": \"var2value\"       }     ]   }\' ```  # Trigger a pull request pipeline  You can also initiate a pipeline for a specific pull request.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \\  -d \'   {     \"target\": {       \"type\": \"pipeline_pullrequest_target\",       \"source\": \"pull-request-branch\",       \"destination\": \"master\",       \"destination_commit\": {         \"hash\": \"9f848b7\"       },       \"commit\": {         \"hash\": \"1a372fc\"       },       \"pullrequest\": {         \"id\": \"3\"       },       \"selector\": {         \"type\": \"pull-requests\",         \"pattern\": \"**\"       }     }   }\' ``` 
         * @summary Run a pipeline
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {Pipeline} body The pipeline to initiate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPipelineForRepository(workspace: string, repoSlug: string, body: Pipeline, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipelineForRepository(workspace, repoSlug, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.createPipelineForRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an account level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Create a variable for a user
         * @param {string} username The account.
         * @param {PipelineVariable} [body] The variable to create.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createPipelineVariableForTeam(username: string, body?: PipelineVariable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipelineVariableForTeam(username, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.createPipelineVariableForTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Create a variable for a user
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {PipelineVariable} [body] The variable to create.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createPipelineVariableForUser(selectedUser: string, body?: PipelineVariable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipelineVariableForUser(selectedUser, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.createPipelineVariableForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a workspace level variable.
         * @summary Create a variable for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {PipelineVariable} [body] The variable to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPipelineVariableForWorkspace(workspace: string, body?: PipelineVariable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipelineVariableForWorkspace(workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.createPipelineVariableForWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a repository level known host.
         * @summary Create a known host
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {PipelineKnownHost} body The known host to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepositoryPipelineKnownHost(workspace: string, repoSlug: string, body: PipelineKnownHost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineKnownHost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepositoryPipelineKnownHost(workspace, repoSlug, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.createRepositoryPipelineKnownHost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a schedule for the given repository.
         * @summary Create a schedule
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {PipelineSchedulePostRequestBody} body The schedule to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepositoryPipelineSchedule(workspace: string, repoSlug: string, body: PipelineSchedulePostRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineSchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepositoryPipelineSchedule(workspace, repoSlug, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.createRepositoryPipelineSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a repository level variable.
         * @summary Create a variable for a repository
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {PipelineVariable} body The variable to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepositoryPipelineVariable(workspace: string, repoSlug: string, body: PipelineVariable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepositoryPipelineVariable(workspace, repoSlug, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.createRepositoryPipelineVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a deployment environment level variable.
         * @summary Delete a variable for an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} environmentUuid The environment.
         * @param {string} variableUuid The UUID of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeploymentVariable(workspace: string, repoSlug: string, environmentUuid: string, variableUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeploymentVariable(workspace, repoSlug, environmentUuid, variableUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.deleteDeploymentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Delete a variable for a team
         * @param {string} username The account.
         * @param {string} variableUuid The UUID of the variable to delete.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deletePipelineVariableForTeam(username: string, variableUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePipelineVariableForTeam(username, variableUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.deletePipelineVariableForTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an account level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Delete a variable for a user
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {string} variableUuid The UUID of the variable to delete.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deletePipelineVariableForUser(selectedUser: string, variableUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePipelineVariableForUser(selectedUser, variableUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.deletePipelineVariableForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a workspace level variable.
         * @summary Delete a variable for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} variableUuid The UUID of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePipelineVariableForWorkspace(workspace: string, variableUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePipelineVariableForWorkspace(workspace, variableUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.deletePipelineVariableForWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a repository cache.
         * @summary Delete a cache
         * @param {string} workspace The account.
         * @param {string} repoSlug The repository.
         * @param {string} cacheUuid The UUID of the cache to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepositoryPipelineCache(workspace: string, repoSlug: string, cacheUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepositoryPipelineCache(workspace, repoSlug, cacheUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.deleteRepositoryPipelineCache']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete repository cache versions by name.
         * @summary Delete caches
         * @param {string} workspace The account.
         * @param {string} repoSlug The repository.
         * @param {string} name The cache name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepositoryPipelineCaches(workspace: string, repoSlug: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepositoryPipelineCaches(workspace, repoSlug, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.deleteRepositoryPipelineCaches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the repository SSH key pair.
         * @summary Delete SSH key pair
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepositoryPipelineKeyPair(workspace: string, repoSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepositoryPipelineKeyPair(workspace, repoSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.deleteRepositoryPipelineKeyPair']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a repository level known host.
         * @summary Delete a known host
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} knownHostUuid The UUID of the known host to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepositoryPipelineKnownHost(workspace: string, repoSlug: string, knownHostUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepositoryPipelineKnownHost(workspace, repoSlug, knownHostUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.deleteRepositoryPipelineKnownHost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a schedule.
         * @summary Delete a schedule
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} scheduleUuid The uuid of the schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepositoryPipelineSchedule(workspace: string, repoSlug: string, scheduleUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepositoryPipelineSchedule(workspace, repoSlug, scheduleUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.deleteRepositoryPipelineSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a repository level variable.
         * @summary Delete a variable for a repository
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} variableUuid The UUID of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepositoryPipelineVariable(workspace: string, repoSlug: string, variableUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepositoryPipelineVariable(workspace, repoSlug, variableUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.deleteRepositoryPipelineVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find deployment environment level variables.
         * @summary List variables for an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} environmentUuid The environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentVariables(workspace: string, repoSlug: string, environmentUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDeploymentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentVariables(workspace, repoSlug, environmentUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getDeploymentVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
         * @summary Get OpenID configuration for OIDC in Pipelines
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOIDCConfiguration(workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOIDCConfiguration(workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getOIDCConfiguration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
         * @summary Get keys for OIDC in Pipelines
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOIDCKeys(workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOIDCKeys(workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getOIDCKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the log file for a build container or service container.  This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
         * @summary Get the logs for the build container or a service container for a given step of a pipeline.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {string} stepUuid The UUID of the step.
         * @param {string} logUuid For the main build container specify the step UUID; for a service container specify the service container UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineContainerLog(workspace: string, repoSlug: string, pipelineUuid: string, stepUuid: string, logUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineContainerLog(workspace, repoSlug, pipelineUuid, stepUuid, logUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineContainerLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specified pipeline
         * @summary Get a pipeline
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The pipeline UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineForRepository(workspace: string, repoSlug: string, pipelineUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineForRepository(workspace, repoSlug, pipelineUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineForRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a given step of a pipeline.
         * @summary Get a step of a pipeline
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {string} stepUuid The UUID of the step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineStepForRepository(workspace: string, repoSlug: string, pipelineUuid: string, stepUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineStep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineStepForRepository(workspace, repoSlug, pipelineUuid, stepUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineStepForRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the log file for a given step of a pipeline.  This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
         * @summary Get log file for a step
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {string} stepUuid The UUID of the step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineStepLogForRepository(workspace: string, repoSlug: string, pipelineUuid: string, stepUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineStepLogForRepository(workspace, repoSlug, pipelineUuid, stepUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineStepLogForRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find steps for the given pipeline.
         * @summary List steps for a pipeline
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineStepsForRepository(workspace: string, repoSlug: string, pipelineUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPipelineSteps>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineStepsForRepository(workspace, repoSlug, pipelineUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineStepsForRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get test case reasons (output) for a given test case in a step of a pipeline.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {string} stepUuid The UUID of the step.
         * @param {string} testCaseUuid The UUID of the test case.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineTestReportTestCaseReasons(workspace: string, repoSlug: string, pipelineUuid: string, stepUuid: string, testCaseUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineTestReportTestCaseReasons(workspace, repoSlug, pipelineUuid, stepUuid, testCaseUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineTestReportTestCaseReasons']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get test cases for a given step of a pipeline.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {string} stepUuid The UUID of the step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineTestReportTestCases(workspace: string, repoSlug: string, pipelineUuid: string, stepUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineTestReportTestCases(workspace, repoSlug, pipelineUuid, stepUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineTestReportTestCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a summary of test reports for a given step of a pipeline.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {string} stepUuid The UUID of the step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineTestReports(workspace: string, repoSlug: string, pipelineUuid: string, stepUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineTestReports(workspace, repoSlug, pipelineUuid, stepUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineTestReports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Get a variable for a team
         * @param {string} username The account.
         * @param {string} variableUuid The UUID of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getPipelineVariableForTeam(username: string, variableUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineVariableForTeam(username, variableUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineVariableForTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Get a variable for a user
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {string} variableUuid The UUID of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getPipelineVariableForUser(selectedUser: string, variableUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineVariableForUser(selectedUser, variableUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineVariableForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a workspace level variable.
         * @summary Get variable for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} variableUuid The UUID of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineVariableForWorkspace(workspace: string, variableUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineVariableForWorkspace(workspace, variableUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineVariableForWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find account level variables. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary List variables for an account
         * @param {string} username The account.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getPipelineVariablesForTeam(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPipelineVariables>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineVariablesForTeam(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineVariablesForTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find user level variables. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary List variables for a user
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getPipelineVariablesForUser(selectedUser: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPipelineVariables>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineVariablesForUser(selectedUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineVariablesForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find workspace level variables.
         * @summary List variables for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineVariablesForWorkspace(workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPipelineVariables>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineVariablesForWorkspace(workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineVariablesForWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find pipelines in a repository.  Note that unlike other endpoints in the Bitbucket API, this endpoint utilizes query parameters to allow filtering and sorting of returned results. See [query parameters](#api-repositories-workspace-repo-slug-pipelines-get-request-Query%20parameters) for specific details. 
         * @summary List pipelines
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} [creatorUuid] The UUID of the creator of the pipeline to filter by.
         * @param {GetPipelinesForRepositoryTargetRefTypeEnum} [targetRefType] The type of the reference to filter by.
         * @param {string} [targetRefName] The reference name to filter by.
         * @param {string} [targetBranch] The name of the branch to filter by.
         * @param {string} [targetCommitHash] The revision to filter by.
         * @param {string} [targetSelectorPattern] The pipeline pattern to filter by.
         * @param {GetPipelinesForRepositoryTargetSelectorTypeEnum} [targetSelectorType] The type of pipeline to filter by.
         * @param {string} [createdOn] The creation date to filter by.
         * @param {GetPipelinesForRepositoryTriggerTypeEnum} [triggerType] The trigger type to filter by.
         * @param {GetPipelinesForRepositoryStatusEnum} [status] The pipeline status to filter by.
         * @param {GetPipelinesForRepositorySortEnum} [sort] The attribute name to sort on.
         * @param {number} [page] The page number of elements to retrieve.
         * @param {number} [pagelen] The maximum number of results to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelinesForRepository(workspace: string, repoSlug: string, creatorUuid?: string, targetRefType?: GetPipelinesForRepositoryTargetRefTypeEnum, targetRefName?: string, targetBranch?: string, targetCommitHash?: string, targetSelectorPattern?: string, targetSelectorType?: GetPipelinesForRepositoryTargetSelectorTypeEnum, createdOn?: string, triggerType?: GetPipelinesForRepositoryTriggerTypeEnum, status?: GetPipelinesForRepositoryStatusEnum, sort?: GetPipelinesForRepositorySortEnum, page?: number, pagelen?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPipelines>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelinesForRepository(workspace, repoSlug, creatorUuid, targetRefType, targetRefName, targetBranch, targetCommitHash, targetSelectorPattern, targetSelectorType, createdOn, triggerType, status, sort, page, pagelen, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelinesForRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the URI of the content of the specified cache.
         * @summary Get cache content URI
         * @param {string} workspace The account.
         * @param {string} repoSlug The repository.
         * @param {string} cacheUuid The UUID of the cache.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryPipelineCacheContentURI(workspace: string, repoSlug: string, cacheUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineCacheContentUri>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryPipelineCacheContentURI(workspace, repoSlug, cacheUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getRepositoryPipelineCacheContentURI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the repository pipelines caches.
         * @summary List caches
         * @param {string} workspace The account.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryPipelineCaches(workspace: string, repoSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPipelineCaches>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryPipelineCaches(workspace, repoSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getRepositoryPipelineCaches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the repository pipelines configuration.
         * @summary Get configuration
         * @param {string} workspace The account.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryPipelineConfig(workspace: string, repoSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelinesConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryPipelineConfig(workspace, repoSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getRepositoryPipelineConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a repository level known host.
         * @summary Get a known host
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} knownHostUuid The UUID of the known host to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryPipelineKnownHost(workspace: string, repoSlug: string, knownHostUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineKnownHost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryPipelineKnownHost(workspace, repoSlug, knownHostUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getRepositoryPipelineKnownHost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find repository level known hosts.
         * @summary List known hosts
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryPipelineKnownHosts(workspace: string, repoSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPipelineKnownHosts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryPipelineKnownHosts(workspace, repoSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getRepositoryPipelineKnownHosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a schedule by its UUID.
         * @summary Get a schedule
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} scheduleUuid The uuid of the schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryPipelineSchedule(workspace: string, repoSlug: string, scheduleUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineSchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryPipelineSchedule(workspace, repoSlug, scheduleUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getRepositoryPipelineSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the executions of a given schedule.
         * @summary List executions of a schedule
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} scheduleUuid The uuid of the schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryPipelineScheduleExecutions(workspace: string, repoSlug: string, scheduleUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPipelineScheduleExecutions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryPipelineScheduleExecutions(workspace, repoSlug, scheduleUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getRepositoryPipelineScheduleExecutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the configured schedules for the given repository.
         * @summary List schedules
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryPipelineSchedules(workspace: string, repoSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPipelineSchedules>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryPipelineSchedules(workspace, repoSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getRepositoryPipelineSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.
         * @summary Get SSH key pair
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryPipelineSshKeyPair(workspace: string, repoSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineSshKeyPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryPipelineSshKeyPair(workspace, repoSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getRepositoryPipelineSshKeyPair']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a repository level variable.
         * @summary Get a variable for a repository
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} variableUuid The UUID of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryPipelineVariable(workspace: string, repoSlug: string, variableUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryPipelineVariable(workspace, repoSlug, variableUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getRepositoryPipelineVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find repository level variables.
         * @summary List variables for a repository
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryPipelineVariables(workspace: string, repoSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPipelineVariables>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryPipelineVariables(workspace, repoSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getRepositoryPipelineVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Signal the stop of a pipeline and all of its steps that not have completed yet.
         * @summary Stop a pipeline
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} pipelineUuid The UUID of the pipeline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopPipeline(workspace: string, repoSlug: string, pipelineUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopPipeline(workspace, repoSlug, pipelineUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.stopPipeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a deployment environment level variable.
         * @summary Update a variable for an environment
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} environmentUuid The environment.
         * @param {string} variableUuid The UUID of the variable to update.
         * @param {DeploymentVariable} body The updated deployment variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeploymentVariable(workspace: string, repoSlug: string, environmentUuid: string, variableUuid: string, body: DeploymentVariable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeploymentVariable(workspace, repoSlug, environmentUuid, variableUuid, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.updateDeploymentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Update a variable for a team
         * @param {string} username The account.
         * @param {string} variableUuid The UUID of the variable.
         * @param {PipelineVariable} body The updated variable.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updatePipelineVariableForTeam(username: string, variableUuid: string, body: PipelineVariable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePipelineVariableForTeam(username, variableUuid, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.updatePipelineVariableForTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Update a variable for a user
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {string} variableUuid The UUID of the variable.
         * @param {PipelineVariable} body The updated variable.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updatePipelineVariableForUser(selectedUser: string, variableUuid: string, body: PipelineVariable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePipelineVariableForUser(selectedUser, variableUuid, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.updatePipelineVariableForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a workspace level variable.
         * @summary Update variable for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} variableUuid The UUID of the variable.
         * @param {PipelineVariable} body The updated variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePipelineVariableForWorkspace(workspace: string, variableUuid: string, body: PipelineVariable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePipelineVariableForWorkspace(workspace, variableUuid, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.updatePipelineVariableForWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.
         * @summary Update the next build number
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {PipelineBuildNumber} body The build number to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepositoryBuildNumber(workspace: string, repoSlug: string, body: PipelineBuildNumber, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineBuildNumber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepositoryBuildNumber(workspace, repoSlug, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.updateRepositoryBuildNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the pipelines configuration for a repository.
         * @summary Update configuration
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {PipelinesConfig} body The updated repository pipelines configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepositoryPipelineConfig(workspace: string, repoSlug: string, body: PipelinesConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelinesConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepositoryPipelineConfig(workspace, repoSlug, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.updateRepositoryPipelineConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.
         * @summary Update SSH key pair
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {PipelineSshKeyPair} body The created or updated SSH key pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepositoryPipelineKeyPair(workspace: string, repoSlug: string, body: PipelineSshKeyPair, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineSshKeyPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepositoryPipelineKeyPair(workspace, repoSlug, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.updateRepositoryPipelineKeyPair']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a repository level known host.
         * @summary Update a known host
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} knownHostUuid The UUID of the known host to update.
         * @param {PipelineKnownHost} body The updated known host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepositoryPipelineKnownHost(workspace: string, repoSlug: string, knownHostUuid: string, body: PipelineKnownHost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineKnownHost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepositoryPipelineKnownHost(workspace, repoSlug, knownHostUuid, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.updateRepositoryPipelineKnownHost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a schedule.
         * @summary Update a schedule
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} scheduleUuid The uuid of the schedule.
         * @param {PipelineSchedulePutRequestBody} body The schedule to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepositoryPipelineSchedule(workspace: string, repoSlug: string, scheduleUuid: string, body: PipelineSchedulePutRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineSchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepositoryPipelineSchedule(workspace, repoSlug, scheduleUuid, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.updateRepositoryPipelineSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a repository level variable.
         * @summary Update a variable for a repository
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} variableUuid The UUID of the variable to update.
         * @param {PipelineVariable} body The updated variable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepositoryPipelineVariable(workspace: string, repoSlug: string, variableUuid: string, body: PipelineVariable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepositoryPipelineVariable(workspace, repoSlug, variableUuid, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.updateRepositoryPipelineVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PipelinesApi - factory interface
 */
export const PipelinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelinesApiFp(configuration)
    return {
        /**
         * Create a deployment environment level variable.
         * @summary Create a variable for an environment
         * @param {PipelinesApiCreateDeploymentVariableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeploymentVariable(requestParameters: PipelinesApiCreateDeploymentVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentVariable> {
            return localVarFp.createDeploymentVariable(requestParameters.workspace, requestParameters.repoSlug, requestParameters.environmentUuid, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint to create and initiate a pipeline. There are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated. # Trigger a Pipeline for a branch One way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline. The specified branch will be used to determine which pipeline definition from the `bitbucket-pipelines.yml` file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\   -d \'   {     \"target\": {       \"ref_type\": \"branch\",       \"type\": \"pipeline_ref_target\",       \"ref_name\": \"master\"     }   }\' ``` # Trigger a Pipeline for a commit on a branch or tag You can initiate a pipeline for a specific commit and in the context of a specified reference (e.g. a branch, tag or bookmark). The specified reference will be used to determine which pipeline definition from the bitbucket-pipelines.yml file will be applied to initiate the pipeline. The pipeline will clone the repository and then do a checkout the specified reference.  The following reference types are supported:  * `branch` * `named_branch` * `bookmark`  * `tag`  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\   https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\   -d \'   {     \"target\": {       \"commit\": {         \"type\": \"commit\",         \"hash\": \"ce5b7431602f7cbba007062eeb55225c6e18e956\"       },       \"ref_type\": \"branch\",       \"type\": \"pipeline_ref_target\",       \"ref_name\": \"master\"     }   }\' ``` # Trigger a specific pipeline definition for a commit You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit. In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition. The resulting pipeline will then clone the repository and checkout the specified revision.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\  -d \'   {      \"target\": {       \"commit\": {          \"hash\":\"a3c4e02c9a3755eccdc3764e6ea13facdf30f923\",          \"type\":\"commit\"        },         \"selector\": {            \"type\":\"custom\",               \"pattern\":\"Deploy to production\"           },         \"type\":\"pipeline_commit_target\"    }   }\' ``` # Trigger a specific pipeline definition for a commit on a branch or tag You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit in the context of a specified reference. In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition, as well as the reference information. The resulting pipeline will then clone the repository a checkout the specified reference.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\  -d \'   {      \"target\": {       \"commit\": {          \"hash\":\"a3c4e02c9a3755eccdc3764e6ea13facdf30f923\",          \"type\":\"commit\"        },        \"selector\": {           \"type\": \"custom\",           \"pattern\": \"Deploy to production\"        },        \"type\": \"pipeline_ref_target\",        \"ref_name\": \"master\",        \"ref_type\": \"branch\"      }   }\' ```   # Trigger a custom pipeline with variables In addition to triggering a custom pipeline that is defined in your `bitbucket-pipelines.yml` file as shown in the examples above, you can specify variables that will be available for your build. In the request, provide a list of variables, specifying the following for each variable: key, value, and whether it should be secured or not (this field is optional and defaults to not secured).  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \\  -d \'   {     \"target\": {       \"type\": \"pipeline_ref_target\",       \"ref_type\": \"branch\",       \"ref_name\": \"master\",       \"selector\": {         \"type\": \"custom\",         \"pattern\": \"Deploy to production\"       }     },     \"variables\": [       {         \"key\": \"var1key\",         \"value\": \"var1value\",         \"secured\": true       },       {         \"key\": \"var2key\",         \"value\": \"var2value\"       }     ]   }\' ```  # Trigger a pull request pipeline  You can also initiate a pipeline for a specific pull request.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \\  -d \'   {     \"target\": {       \"type\": \"pipeline_pullrequest_target\",       \"source\": \"pull-request-branch\",       \"destination\": \"master\",       \"destination_commit\": {         \"hash\": \"9f848b7\"       },       \"commit\": {         \"hash\": \"1a372fc\"       },       \"pullrequest\": {         \"id\": \"3\"       },       \"selector\": {         \"type\": \"pull-requests\",         \"pattern\": \"**\"       }     }   }\' ``` 
         * @summary Run a pipeline
         * @param {PipelinesApiCreatePipelineForRepositoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineForRepository(requestParameters: PipelinesApiCreatePipelineForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pipeline> {
            return localVarFp.createPipelineForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an account level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Create a variable for a user
         * @param {PipelinesApiCreatePipelineVariableForTeamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createPipelineVariableForTeam(requestParameters: PipelinesApiCreatePipelineVariableForTeamRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable> {
            return localVarFp.createPipelineVariableForTeam(requestParameters.username, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Create a variable for a user
         * @param {PipelinesApiCreatePipelineVariableForUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createPipelineVariableForUser(requestParameters: PipelinesApiCreatePipelineVariableForUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable> {
            return localVarFp.createPipelineVariableForUser(requestParameters.selectedUser, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a workspace level variable.
         * @summary Create a variable for a workspace
         * @param {PipelinesApiCreatePipelineVariableForWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineVariableForWorkspace(requestParameters: PipelinesApiCreatePipelineVariableForWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable> {
            return localVarFp.createPipelineVariableForWorkspace(requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a repository level known host.
         * @summary Create a known host
         * @param {PipelinesApiCreateRepositoryPipelineKnownHostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepositoryPipelineKnownHost(requestParameters: PipelinesApiCreateRepositoryPipelineKnownHostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineKnownHost> {
            return localVarFp.createRepositoryPipelineKnownHost(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a schedule for the given repository.
         * @summary Create a schedule
         * @param {PipelinesApiCreateRepositoryPipelineScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepositoryPipelineSchedule(requestParameters: PipelinesApiCreateRepositoryPipelineScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineSchedule> {
            return localVarFp.createRepositoryPipelineSchedule(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a repository level variable.
         * @summary Create a variable for a repository
         * @param {PipelinesApiCreateRepositoryPipelineVariableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepositoryPipelineVariable(requestParameters: PipelinesApiCreateRepositoryPipelineVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable> {
            return localVarFp.createRepositoryPipelineVariable(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a deployment environment level variable.
         * @summary Delete a variable for an environment
         * @param {PipelinesApiDeleteDeploymentVariableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeploymentVariable(requestParameters: PipelinesApiDeleteDeploymentVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDeploymentVariable(requestParameters.workspace, requestParameters.repoSlug, requestParameters.environmentUuid, requestParameters.variableUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Delete a variable for a team
         * @param {PipelinesApiDeletePipelineVariableForTeamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deletePipelineVariableForTeam(requestParameters: PipelinesApiDeletePipelineVariableForTeamRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePipelineVariableForTeam(requestParameters.username, requestParameters.variableUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an account level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Delete a variable for a user
         * @param {PipelinesApiDeletePipelineVariableForUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deletePipelineVariableForUser(requestParameters: PipelinesApiDeletePipelineVariableForUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePipelineVariableForUser(requestParameters.selectedUser, requestParameters.variableUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a workspace level variable.
         * @summary Delete a variable for a workspace
         * @param {PipelinesApiDeletePipelineVariableForWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineVariableForWorkspace(requestParameters: PipelinesApiDeletePipelineVariableForWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePipelineVariableForWorkspace(requestParameters.workspace, requestParameters.variableUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a repository cache.
         * @summary Delete a cache
         * @param {PipelinesApiDeleteRepositoryPipelineCacheRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryPipelineCache(requestParameters: PipelinesApiDeleteRepositoryPipelineCacheRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRepositoryPipelineCache(requestParameters.workspace, requestParameters.repoSlug, requestParameters.cacheUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete repository cache versions by name.
         * @summary Delete caches
         * @param {PipelinesApiDeleteRepositoryPipelineCachesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryPipelineCaches(requestParameters: PipelinesApiDeleteRepositoryPipelineCachesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRepositoryPipelineCaches(requestParameters.workspace, requestParameters.repoSlug, requestParameters.name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the repository SSH key pair.
         * @summary Delete SSH key pair
         * @param {PipelinesApiDeleteRepositoryPipelineKeyPairRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryPipelineKeyPair(requestParameters: PipelinesApiDeleteRepositoryPipelineKeyPairRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRepositoryPipelineKeyPair(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a repository level known host.
         * @summary Delete a known host
         * @param {PipelinesApiDeleteRepositoryPipelineKnownHostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryPipelineKnownHost(requestParameters: PipelinesApiDeleteRepositoryPipelineKnownHostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRepositoryPipelineKnownHost(requestParameters.workspace, requestParameters.repoSlug, requestParameters.knownHostUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a schedule.
         * @summary Delete a schedule
         * @param {PipelinesApiDeleteRepositoryPipelineScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryPipelineSchedule(requestParameters: PipelinesApiDeleteRepositoryPipelineScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRepositoryPipelineSchedule(requestParameters.workspace, requestParameters.repoSlug, requestParameters.scheduleUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a repository level variable.
         * @summary Delete a variable for a repository
         * @param {PipelinesApiDeleteRepositoryPipelineVariableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryPipelineVariable(requestParameters: PipelinesApiDeleteRepositoryPipelineVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRepositoryPipelineVariable(requestParameters.workspace, requestParameters.repoSlug, requestParameters.variableUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Find deployment environment level variables.
         * @summary List variables for an environment
         * @param {PipelinesApiGetDeploymentVariablesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentVariables(requestParameters: PipelinesApiGetDeploymentVariablesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDeploymentVariable> {
            return localVarFp.getDeploymentVariables(requestParameters.workspace, requestParameters.repoSlug, requestParameters.environmentUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
         * @summary Get OpenID configuration for OIDC in Pipelines
         * @param {PipelinesApiGetOIDCConfigurationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOIDCConfiguration(requestParameters: PipelinesApiGetOIDCConfigurationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getOIDCConfiguration(requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
         * @summary Get keys for OIDC in Pipelines
         * @param {PipelinesApiGetOIDCKeysRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOIDCKeys(requestParameters: PipelinesApiGetOIDCKeysRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getOIDCKeys(requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the log file for a build container or service container.  This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
         * @summary Get the logs for the build container or a service container for a given step of a pipeline.
         * @param {PipelinesApiGetPipelineContainerLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineContainerLog(requestParameters: PipelinesApiGetPipelineContainerLogRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getPipelineContainerLog(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, requestParameters.stepUuid, requestParameters.logUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specified pipeline
         * @summary Get a pipeline
         * @param {PipelinesApiGetPipelineForRepositoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineForRepository(requestParameters: PipelinesApiGetPipelineForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pipeline> {
            return localVarFp.getPipelineForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a given step of a pipeline.
         * @summary Get a step of a pipeline
         * @param {PipelinesApiGetPipelineStepForRepositoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineStepForRepository(requestParameters: PipelinesApiGetPipelineStepForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineStep> {
            return localVarFp.getPipelineStepForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, requestParameters.stepUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the log file for a given step of a pipeline.  This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
         * @summary Get log file for a step
         * @param {PipelinesApiGetPipelineStepLogForRepositoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineStepLogForRepository(requestParameters: PipelinesApiGetPipelineStepLogForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getPipelineStepLogForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, requestParameters.stepUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Find steps for the given pipeline.
         * @summary List steps for a pipeline
         * @param {PipelinesApiGetPipelineStepsForRepositoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineStepsForRepository(requestParameters: PipelinesApiGetPipelineStepsForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineSteps> {
            return localVarFp.getPipelineStepsForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get test case reasons (output) for a given test case in a step of a pipeline.
         * @param {PipelinesApiGetPipelineTestReportTestCaseReasonsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineTestReportTestCaseReasons(requestParameters: PipelinesApiGetPipelineTestReportTestCaseReasonsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getPipelineTestReportTestCaseReasons(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, requestParameters.stepUuid, requestParameters.testCaseUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get test cases for a given step of a pipeline.
         * @param {PipelinesApiGetPipelineTestReportTestCasesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineTestReportTestCases(requestParameters: PipelinesApiGetPipelineTestReportTestCasesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getPipelineTestReportTestCases(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, requestParameters.stepUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a summary of test reports for a given step of a pipeline.
         * @param {PipelinesApiGetPipelineTestReportsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineTestReports(requestParameters: PipelinesApiGetPipelineTestReportsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getPipelineTestReports(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, requestParameters.stepUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Get a variable for a team
         * @param {PipelinesApiGetPipelineVariableForTeamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPipelineVariableForTeam(requestParameters: PipelinesApiGetPipelineVariableForTeamRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable> {
            return localVarFp.getPipelineVariableForTeam(requestParameters.username, requestParameters.variableUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Get a variable for a user
         * @param {PipelinesApiGetPipelineVariableForUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPipelineVariableForUser(requestParameters: PipelinesApiGetPipelineVariableForUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable> {
            return localVarFp.getPipelineVariableForUser(requestParameters.selectedUser, requestParameters.variableUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a workspace level variable.
         * @summary Get variable for a workspace
         * @param {PipelinesApiGetPipelineVariableForWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineVariableForWorkspace(requestParameters: PipelinesApiGetPipelineVariableForWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable> {
            return localVarFp.getPipelineVariableForWorkspace(requestParameters.workspace, requestParameters.variableUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Find account level variables. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary List variables for an account
         * @param {PipelinesApiGetPipelineVariablesForTeamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPipelineVariablesForTeam(requestParameters: PipelinesApiGetPipelineVariablesForTeamRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineVariables> {
            return localVarFp.getPipelineVariablesForTeam(requestParameters.username, options).then((request) => request(axios, basePath));
        },
        /**
         * Find user level variables. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary List variables for a user
         * @param {PipelinesApiGetPipelineVariablesForUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPipelineVariablesForUser(requestParameters: PipelinesApiGetPipelineVariablesForUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineVariables> {
            return localVarFp.getPipelineVariablesForUser(requestParameters.selectedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Find workspace level variables.
         * @summary List variables for a workspace
         * @param {PipelinesApiGetPipelineVariablesForWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineVariablesForWorkspace(requestParameters: PipelinesApiGetPipelineVariablesForWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineVariables> {
            return localVarFp.getPipelineVariablesForWorkspace(requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Find pipelines in a repository.  Note that unlike other endpoints in the Bitbucket API, this endpoint utilizes query parameters to allow filtering and sorting of returned results. See [query parameters](#api-repositories-workspace-repo-slug-pipelines-get-request-Query%20parameters) for specific details. 
         * @summary List pipelines
         * @param {PipelinesApiGetPipelinesForRepositoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelinesForRepository(requestParameters: PipelinesApiGetPipelinesForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelines> {
            return localVarFp.getPipelinesForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.creatorUuid, requestParameters.targetRefType, requestParameters.targetRefName, requestParameters.targetBranch, requestParameters.targetCommitHash, requestParameters.targetSelectorPattern, requestParameters.targetSelectorType, requestParameters.createdOn, requestParameters.triggerType, requestParameters.status, requestParameters.sort, requestParameters.page, requestParameters.pagelen, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the URI of the content of the specified cache.
         * @summary Get cache content URI
         * @param {PipelinesApiGetRepositoryPipelineCacheContentURIRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineCacheContentURI(requestParameters: PipelinesApiGetRepositoryPipelineCacheContentURIRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineCacheContentUri> {
            return localVarFp.getRepositoryPipelineCacheContentURI(requestParameters.workspace, requestParameters.repoSlug, requestParameters.cacheUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the repository pipelines caches.
         * @summary List caches
         * @param {PipelinesApiGetRepositoryPipelineCachesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineCaches(requestParameters: PipelinesApiGetRepositoryPipelineCachesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineCaches> {
            return localVarFp.getRepositoryPipelineCaches(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the repository pipelines configuration.
         * @summary Get configuration
         * @param {PipelinesApiGetRepositoryPipelineConfigRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineConfig(requestParameters: PipelinesApiGetRepositoryPipelineConfigRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelinesConfig> {
            return localVarFp.getRepositoryPipelineConfig(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a repository level known host.
         * @summary Get a known host
         * @param {PipelinesApiGetRepositoryPipelineKnownHostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineKnownHost(requestParameters: PipelinesApiGetRepositoryPipelineKnownHostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineKnownHost> {
            return localVarFp.getRepositoryPipelineKnownHost(requestParameters.workspace, requestParameters.repoSlug, requestParameters.knownHostUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Find repository level known hosts.
         * @summary List known hosts
         * @param {PipelinesApiGetRepositoryPipelineKnownHostsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineKnownHosts(requestParameters: PipelinesApiGetRepositoryPipelineKnownHostsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineKnownHosts> {
            return localVarFp.getRepositoryPipelineKnownHosts(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a schedule by its UUID.
         * @summary Get a schedule
         * @param {PipelinesApiGetRepositoryPipelineScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineSchedule(requestParameters: PipelinesApiGetRepositoryPipelineScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineSchedule> {
            return localVarFp.getRepositoryPipelineSchedule(requestParameters.workspace, requestParameters.repoSlug, requestParameters.scheduleUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the executions of a given schedule.
         * @summary List executions of a schedule
         * @param {PipelinesApiGetRepositoryPipelineScheduleExecutionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineScheduleExecutions(requestParameters: PipelinesApiGetRepositoryPipelineScheduleExecutionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineScheduleExecutions> {
            return localVarFp.getRepositoryPipelineScheduleExecutions(requestParameters.workspace, requestParameters.repoSlug, requestParameters.scheduleUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the configured schedules for the given repository.
         * @summary List schedules
         * @param {PipelinesApiGetRepositoryPipelineSchedulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineSchedules(requestParameters: PipelinesApiGetRepositoryPipelineSchedulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineSchedules> {
            return localVarFp.getRepositoryPipelineSchedules(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.
         * @summary Get SSH key pair
         * @param {PipelinesApiGetRepositoryPipelineSshKeyPairRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineSshKeyPair(requestParameters: PipelinesApiGetRepositoryPipelineSshKeyPairRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineSshKeyPair> {
            return localVarFp.getRepositoryPipelineSshKeyPair(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a repository level variable.
         * @summary Get a variable for a repository
         * @param {PipelinesApiGetRepositoryPipelineVariableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineVariable(requestParameters: PipelinesApiGetRepositoryPipelineVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable> {
            return localVarFp.getRepositoryPipelineVariable(requestParameters.workspace, requestParameters.repoSlug, requestParameters.variableUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Find repository level variables.
         * @summary List variables for a repository
         * @param {PipelinesApiGetRepositoryPipelineVariablesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPipelineVariables(requestParameters: PipelinesApiGetRepositoryPipelineVariablesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineVariables> {
            return localVarFp.getRepositoryPipelineVariables(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * Signal the stop of a pipeline and all of its steps that not have completed yet.
         * @summary Stop a pipeline
         * @param {PipelinesApiStopPipelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopPipeline(requestParameters: PipelinesApiStopPipelineRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stopPipeline(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a deployment environment level variable.
         * @summary Update a variable for an environment
         * @param {PipelinesApiUpdateDeploymentVariableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeploymentVariable(requestParameters: PipelinesApiUpdateDeploymentVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentVariable> {
            return localVarFp.updateDeploymentVariable(requestParameters.workspace, requestParameters.repoSlug, requestParameters.environmentUuid, requestParameters.variableUuid, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Update a variable for a team
         * @param {PipelinesApiUpdatePipelineVariableForTeamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePipelineVariableForTeam(requestParameters: PipelinesApiUpdatePipelineVariableForTeamRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable> {
            return localVarFp.updatePipelineVariableForTeam(requestParameters.username, requestParameters.variableUuid, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
         * @summary Update a variable for a user
         * @param {PipelinesApiUpdatePipelineVariableForUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePipelineVariableForUser(requestParameters: PipelinesApiUpdatePipelineVariableForUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable> {
            return localVarFp.updatePipelineVariableForUser(requestParameters.selectedUser, requestParameters.variableUuid, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a workspace level variable.
         * @summary Update variable for a workspace
         * @param {PipelinesApiUpdatePipelineVariableForWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipelineVariableForWorkspace(requestParameters: PipelinesApiUpdatePipelineVariableForWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable> {
            return localVarFp.updatePipelineVariableForWorkspace(requestParameters.workspace, requestParameters.variableUuid, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.
         * @summary Update the next build number
         * @param {PipelinesApiUpdateRepositoryBuildNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepositoryBuildNumber(requestParameters: PipelinesApiUpdateRepositoryBuildNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineBuildNumber> {
            return localVarFp.updateRepositoryBuildNumber(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the pipelines configuration for a repository.
         * @summary Update configuration
         * @param {PipelinesApiUpdateRepositoryPipelineConfigRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepositoryPipelineConfig(requestParameters: PipelinesApiUpdateRepositoryPipelineConfigRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelinesConfig> {
            return localVarFp.updateRepositoryPipelineConfig(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.
         * @summary Update SSH key pair
         * @param {PipelinesApiUpdateRepositoryPipelineKeyPairRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepositoryPipelineKeyPair(requestParameters: PipelinesApiUpdateRepositoryPipelineKeyPairRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineSshKeyPair> {
            return localVarFp.updateRepositoryPipelineKeyPair(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a repository level known host.
         * @summary Update a known host
         * @param {PipelinesApiUpdateRepositoryPipelineKnownHostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepositoryPipelineKnownHost(requestParameters: PipelinesApiUpdateRepositoryPipelineKnownHostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineKnownHost> {
            return localVarFp.updateRepositoryPipelineKnownHost(requestParameters.workspace, requestParameters.repoSlug, requestParameters.knownHostUuid, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a schedule.
         * @summary Update a schedule
         * @param {PipelinesApiUpdateRepositoryPipelineScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepositoryPipelineSchedule(requestParameters: PipelinesApiUpdateRepositoryPipelineScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineSchedule> {
            return localVarFp.updateRepositoryPipelineSchedule(requestParameters.workspace, requestParameters.repoSlug, requestParameters.scheduleUuid, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a repository level variable.
         * @summary Update a variable for a repository
         * @param {PipelinesApiUpdateRepositoryPipelineVariableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepositoryPipelineVariable(requestParameters: PipelinesApiUpdateRepositoryPipelineVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable> {
            return localVarFp.updateRepositoryPipelineVariable(requestParameters.workspace, requestParameters.repoSlug, requestParameters.variableUuid, requestParameters.body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PipelinesApi - interface
 */
export interface PipelinesApiInterface {
    /**
     * Create a deployment environment level variable.
     * @summary Create a variable for an environment
     * @param {PipelinesApiCreateDeploymentVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDeploymentVariable(requestParameters: PipelinesApiCreateDeploymentVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentVariable>;

    /**
     * Endpoint to create and initiate a pipeline. There are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated. # Trigger a Pipeline for a branch One way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline. The specified branch will be used to determine which pipeline definition from the `bitbucket-pipelines.yml` file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\   -d \'   {     \"target\": {       \"ref_type\": \"branch\",       \"type\": \"pipeline_ref_target\",       \"ref_name\": \"master\"     }   }\' ``` # Trigger a Pipeline for a commit on a branch or tag You can initiate a pipeline for a specific commit and in the context of a specified reference (e.g. a branch, tag or bookmark). The specified reference will be used to determine which pipeline definition from the bitbucket-pipelines.yml file will be applied to initiate the pipeline. The pipeline will clone the repository and then do a checkout the specified reference.  The following reference types are supported:  * `branch` * `named_branch` * `bookmark`  * `tag`  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\   https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\   -d \'   {     \"target\": {       \"commit\": {         \"type\": \"commit\",         \"hash\": \"ce5b7431602f7cbba007062eeb55225c6e18e956\"       },       \"ref_type\": \"branch\",       \"type\": \"pipeline_ref_target\",       \"ref_name\": \"master\"     }   }\' ``` # Trigger a specific pipeline definition for a commit You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit. In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition. The resulting pipeline will then clone the repository and checkout the specified revision.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\  -d \'   {      \"target\": {       \"commit\": {          \"hash\":\"a3c4e02c9a3755eccdc3764e6ea13facdf30f923\",          \"type\":\"commit\"        },         \"selector\": {            \"type\":\"custom\",               \"pattern\":\"Deploy to production\"           },         \"type\":\"pipeline_commit_target\"    }   }\' ``` # Trigger a specific pipeline definition for a commit on a branch or tag You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit in the context of a specified reference. In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition, as well as the reference information. The resulting pipeline will then clone the repository a checkout the specified reference.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\  -d \'   {      \"target\": {       \"commit\": {          \"hash\":\"a3c4e02c9a3755eccdc3764e6ea13facdf30f923\",          \"type\":\"commit\"        },        \"selector\": {           \"type\": \"custom\",           \"pattern\": \"Deploy to production\"        },        \"type\": \"pipeline_ref_target\",        \"ref_name\": \"master\",        \"ref_type\": \"branch\"      }   }\' ```   # Trigger a custom pipeline with variables In addition to triggering a custom pipeline that is defined in your `bitbucket-pipelines.yml` file as shown in the examples above, you can specify variables that will be available for your build. In the request, provide a list of variables, specifying the following for each variable: key, value, and whether it should be secured or not (this field is optional and defaults to not secured).  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \\  -d \'   {     \"target\": {       \"type\": \"pipeline_ref_target\",       \"ref_type\": \"branch\",       \"ref_name\": \"master\",       \"selector\": {         \"type\": \"custom\",         \"pattern\": \"Deploy to production\"       }     },     \"variables\": [       {         \"key\": \"var1key\",         \"value\": \"var1value\",         \"secured\": true       },       {         \"key\": \"var2key\",         \"value\": \"var2value\"       }     ]   }\' ```  # Trigger a pull request pipeline  You can also initiate a pipeline for a specific pull request.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \\  -d \'   {     \"target\": {       \"type\": \"pipeline_pullrequest_target\",       \"source\": \"pull-request-branch\",       \"destination\": \"master\",       \"destination_commit\": {         \"hash\": \"9f848b7\"       },       \"commit\": {         \"hash\": \"1a372fc\"       },       \"pullrequest\": {         \"id\": \"3\"       },       \"selector\": {         \"type\": \"pull-requests\",         \"pattern\": \"**\"       }     }   }\' ``` 
     * @summary Run a pipeline
     * @param {PipelinesApiCreatePipelineForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPipelineForRepository(requestParameters: PipelinesApiCreatePipelineForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pipeline>;

    /**
     * Create an account level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Create a variable for a user
     * @param {PipelinesApiCreatePipelineVariableForTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    createPipelineVariableForTeam(requestParameters: PipelinesApiCreatePipelineVariableForTeamRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable>;

    /**
     * Create a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Create a variable for a user
     * @param {PipelinesApiCreatePipelineVariableForUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    createPipelineVariableForUser(requestParameters: PipelinesApiCreatePipelineVariableForUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable>;

    /**
     * Create a workspace level variable.
     * @summary Create a variable for a workspace
     * @param {PipelinesApiCreatePipelineVariableForWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPipelineVariableForWorkspace(requestParameters: PipelinesApiCreatePipelineVariableForWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable>;

    /**
     * Create a repository level known host.
     * @summary Create a known host
     * @param {PipelinesApiCreateRepositoryPipelineKnownHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepositoryPipelineKnownHost(requestParameters: PipelinesApiCreateRepositoryPipelineKnownHostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineKnownHost>;

    /**
     * Create a schedule for the given repository.
     * @summary Create a schedule
     * @param {PipelinesApiCreateRepositoryPipelineScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepositoryPipelineSchedule(requestParameters: PipelinesApiCreateRepositoryPipelineScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineSchedule>;

    /**
     * Create a repository level variable.
     * @summary Create a variable for a repository
     * @param {PipelinesApiCreateRepositoryPipelineVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepositoryPipelineVariable(requestParameters: PipelinesApiCreateRepositoryPipelineVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable>;

    /**
     * Delete a deployment environment level variable.
     * @summary Delete a variable for an environment
     * @param {PipelinesApiDeleteDeploymentVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDeploymentVariable(requestParameters: PipelinesApiDeleteDeploymentVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Delete a variable for a team
     * @param {PipelinesApiDeletePipelineVariableForTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    deletePipelineVariableForTeam(requestParameters: PipelinesApiDeletePipelineVariableForTeamRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete an account level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Delete a variable for a user
     * @param {PipelinesApiDeletePipelineVariableForUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    deletePipelineVariableForUser(requestParameters: PipelinesApiDeletePipelineVariableForUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete a workspace level variable.
     * @summary Delete a variable for a workspace
     * @param {PipelinesApiDeletePipelineVariableForWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePipelineVariableForWorkspace(requestParameters: PipelinesApiDeletePipelineVariableForWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete a repository cache.
     * @summary Delete a cache
     * @param {PipelinesApiDeleteRepositoryPipelineCacheRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRepositoryPipelineCache(requestParameters: PipelinesApiDeleteRepositoryPipelineCacheRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete repository cache versions by name.
     * @summary Delete caches
     * @param {PipelinesApiDeleteRepositoryPipelineCachesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRepositoryPipelineCaches(requestParameters: PipelinesApiDeleteRepositoryPipelineCachesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete the repository SSH key pair.
     * @summary Delete SSH key pair
     * @param {PipelinesApiDeleteRepositoryPipelineKeyPairRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRepositoryPipelineKeyPair(requestParameters: PipelinesApiDeleteRepositoryPipelineKeyPairRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete a repository level known host.
     * @summary Delete a known host
     * @param {PipelinesApiDeleteRepositoryPipelineKnownHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRepositoryPipelineKnownHost(requestParameters: PipelinesApiDeleteRepositoryPipelineKnownHostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete a schedule.
     * @summary Delete a schedule
     * @param {PipelinesApiDeleteRepositoryPipelineScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRepositoryPipelineSchedule(requestParameters: PipelinesApiDeleteRepositoryPipelineScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete a repository level variable.
     * @summary Delete a variable for a repository
     * @param {PipelinesApiDeleteRepositoryPipelineVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRepositoryPipelineVariable(requestParameters: PipelinesApiDeleteRepositoryPipelineVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Find deployment environment level variables.
     * @summary List variables for an environment
     * @param {PipelinesApiGetDeploymentVariablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeploymentVariables(requestParameters: PipelinesApiGetDeploymentVariablesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDeploymentVariable>;

    /**
     * This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
     * @summary Get OpenID configuration for OIDC in Pipelines
     * @param {PipelinesApiGetOIDCConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOIDCConfiguration(requestParameters: PipelinesApiGetOIDCConfigurationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
     * @summary Get keys for OIDC in Pipelines
     * @param {PipelinesApiGetOIDCKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOIDCKeys(requestParameters: PipelinesApiGetOIDCKeysRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve the log file for a build container or service container.  This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
     * @summary Get the logs for the build container or a service container for a given step of a pipeline.
     * @param {PipelinesApiGetPipelineContainerLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineContainerLog(requestParameters: PipelinesApiGetPipelineContainerLogRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve a specified pipeline
     * @summary Get a pipeline
     * @param {PipelinesApiGetPipelineForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineForRepository(requestParameters: PipelinesApiGetPipelineForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pipeline>;

    /**
     * Retrieve a given step of a pipeline.
     * @summary Get a step of a pipeline
     * @param {PipelinesApiGetPipelineStepForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineStepForRepository(requestParameters: PipelinesApiGetPipelineStepForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineStep>;

    /**
     * Retrieve the log file for a given step of a pipeline.  This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
     * @summary Get log file for a step
     * @param {PipelinesApiGetPipelineStepLogForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineStepLogForRepository(requestParameters: PipelinesApiGetPipelineStepLogForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Find steps for the given pipeline.
     * @summary List steps for a pipeline
     * @param {PipelinesApiGetPipelineStepsForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineStepsForRepository(requestParameters: PipelinesApiGetPipelineStepsForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineSteps>;

    /**
     * 
     * @summary Get test case reasons (output) for a given test case in a step of a pipeline.
     * @param {PipelinesApiGetPipelineTestReportTestCaseReasonsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineTestReportTestCaseReasons(requestParameters: PipelinesApiGetPipelineTestReportTestCaseReasonsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get test cases for a given step of a pipeline.
     * @param {PipelinesApiGetPipelineTestReportTestCasesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineTestReportTestCases(requestParameters: PipelinesApiGetPipelineTestReportTestCasesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get a summary of test reports for a given step of a pipeline.
     * @param {PipelinesApiGetPipelineTestReportsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineTestReports(requestParameters: PipelinesApiGetPipelineTestReportsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Get a variable for a team
     * @param {PipelinesApiGetPipelineVariableForTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getPipelineVariableForTeam(requestParameters: PipelinesApiGetPipelineVariableForTeamRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable>;

    /**
     * Retrieve a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Get a variable for a user
     * @param {PipelinesApiGetPipelineVariableForUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getPipelineVariableForUser(requestParameters: PipelinesApiGetPipelineVariableForUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable>;

    /**
     * Retrieve a workspace level variable.
     * @summary Get variable for a workspace
     * @param {PipelinesApiGetPipelineVariableForWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineVariableForWorkspace(requestParameters: PipelinesApiGetPipelineVariableForWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable>;

    /**
     * Find account level variables. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary List variables for an account
     * @param {PipelinesApiGetPipelineVariablesForTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getPipelineVariablesForTeam(requestParameters: PipelinesApiGetPipelineVariablesForTeamRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineVariables>;

    /**
     * Find user level variables. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary List variables for a user
     * @param {PipelinesApiGetPipelineVariablesForUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getPipelineVariablesForUser(requestParameters: PipelinesApiGetPipelineVariablesForUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineVariables>;

    /**
     * Find workspace level variables.
     * @summary List variables for a workspace
     * @param {PipelinesApiGetPipelineVariablesForWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineVariablesForWorkspace(requestParameters: PipelinesApiGetPipelineVariablesForWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineVariables>;

    /**
     * Find pipelines in a repository.  Note that unlike other endpoints in the Bitbucket API, this endpoint utilizes query parameters to allow filtering and sorting of returned results. See [query parameters](#api-repositories-workspace-repo-slug-pipelines-get-request-Query%20parameters) for specific details. 
     * @summary List pipelines
     * @param {PipelinesApiGetPipelinesForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelinesForRepository(requestParameters: PipelinesApiGetPipelinesForRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelines>;

    /**
     * Retrieve the URI of the content of the specified cache.
     * @summary Get cache content URI
     * @param {PipelinesApiGetRepositoryPipelineCacheContentURIRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositoryPipelineCacheContentURI(requestParameters: PipelinesApiGetRepositoryPipelineCacheContentURIRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineCacheContentUri>;

    /**
     * Retrieve the repository pipelines caches.
     * @summary List caches
     * @param {PipelinesApiGetRepositoryPipelineCachesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositoryPipelineCaches(requestParameters: PipelinesApiGetRepositoryPipelineCachesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineCaches>;

    /**
     * Retrieve the repository pipelines configuration.
     * @summary Get configuration
     * @param {PipelinesApiGetRepositoryPipelineConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositoryPipelineConfig(requestParameters: PipelinesApiGetRepositoryPipelineConfigRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelinesConfig>;

    /**
     * Retrieve a repository level known host.
     * @summary Get a known host
     * @param {PipelinesApiGetRepositoryPipelineKnownHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositoryPipelineKnownHost(requestParameters: PipelinesApiGetRepositoryPipelineKnownHostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineKnownHost>;

    /**
     * Find repository level known hosts.
     * @summary List known hosts
     * @param {PipelinesApiGetRepositoryPipelineKnownHostsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositoryPipelineKnownHosts(requestParameters: PipelinesApiGetRepositoryPipelineKnownHostsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineKnownHosts>;

    /**
     * Retrieve a schedule by its UUID.
     * @summary Get a schedule
     * @param {PipelinesApiGetRepositoryPipelineScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositoryPipelineSchedule(requestParameters: PipelinesApiGetRepositoryPipelineScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineSchedule>;

    /**
     * Retrieve the executions of a given schedule.
     * @summary List executions of a schedule
     * @param {PipelinesApiGetRepositoryPipelineScheduleExecutionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositoryPipelineScheduleExecutions(requestParameters: PipelinesApiGetRepositoryPipelineScheduleExecutionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineScheduleExecutions>;

    /**
     * Retrieve the configured schedules for the given repository.
     * @summary List schedules
     * @param {PipelinesApiGetRepositoryPipelineSchedulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositoryPipelineSchedules(requestParameters: PipelinesApiGetRepositoryPipelineSchedulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineSchedules>;

    /**
     * Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.
     * @summary Get SSH key pair
     * @param {PipelinesApiGetRepositoryPipelineSshKeyPairRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositoryPipelineSshKeyPair(requestParameters: PipelinesApiGetRepositoryPipelineSshKeyPairRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineSshKeyPair>;

    /**
     * Retrieve a repository level variable.
     * @summary Get a variable for a repository
     * @param {PipelinesApiGetRepositoryPipelineVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositoryPipelineVariable(requestParameters: PipelinesApiGetRepositoryPipelineVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable>;

    /**
     * Find repository level variables.
     * @summary List variables for a repository
     * @param {PipelinesApiGetRepositoryPipelineVariablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositoryPipelineVariables(requestParameters: PipelinesApiGetRepositoryPipelineVariablesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPipelineVariables>;

    /**
     * Signal the stop of a pipeline and all of its steps that not have completed yet.
     * @summary Stop a pipeline
     * @param {PipelinesApiStopPipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopPipeline(requestParameters: PipelinesApiStopPipelineRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Update a deployment environment level variable.
     * @summary Update a variable for an environment
     * @param {PipelinesApiUpdateDeploymentVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDeploymentVariable(requestParameters: PipelinesApiUpdateDeploymentVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentVariable>;

    /**
     * Update a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Update a variable for a team
     * @param {PipelinesApiUpdatePipelineVariableForTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    updatePipelineVariableForTeam(requestParameters: PipelinesApiUpdatePipelineVariableForTeamRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable>;

    /**
     * Update a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Update a variable for a user
     * @param {PipelinesApiUpdatePipelineVariableForUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    updatePipelineVariableForUser(requestParameters: PipelinesApiUpdatePipelineVariableForUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable>;

    /**
     * Update a workspace level variable.
     * @summary Update variable for a workspace
     * @param {PipelinesApiUpdatePipelineVariableForWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePipelineVariableForWorkspace(requestParameters: PipelinesApiUpdatePipelineVariableForWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable>;

    /**
     * Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.
     * @summary Update the next build number
     * @param {PipelinesApiUpdateRepositoryBuildNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepositoryBuildNumber(requestParameters: PipelinesApiUpdateRepositoryBuildNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineBuildNumber>;

    /**
     * Update the pipelines configuration for a repository.
     * @summary Update configuration
     * @param {PipelinesApiUpdateRepositoryPipelineConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepositoryPipelineConfig(requestParameters: PipelinesApiUpdateRepositoryPipelineConfigRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelinesConfig>;

    /**
     * Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.
     * @summary Update SSH key pair
     * @param {PipelinesApiUpdateRepositoryPipelineKeyPairRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepositoryPipelineKeyPair(requestParameters: PipelinesApiUpdateRepositoryPipelineKeyPairRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineSshKeyPair>;

    /**
     * Update a repository level known host.
     * @summary Update a known host
     * @param {PipelinesApiUpdateRepositoryPipelineKnownHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepositoryPipelineKnownHost(requestParameters: PipelinesApiUpdateRepositoryPipelineKnownHostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineKnownHost>;

    /**
     * Update a schedule.
     * @summary Update a schedule
     * @param {PipelinesApiUpdateRepositoryPipelineScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepositoryPipelineSchedule(requestParameters: PipelinesApiUpdateRepositoryPipelineScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineSchedule>;

    /**
     * Update a repository level variable.
     * @summary Update a variable for a repository
     * @param {PipelinesApiUpdateRepositoryPipelineVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepositoryPipelineVariable(requestParameters: PipelinesApiUpdateRepositoryPipelineVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineVariable>;

}

/**
 * Request parameters for createDeploymentVariable operation in PipelinesApi.
 */
export interface PipelinesApiCreateDeploymentVariableRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The environment.
     */
    readonly environmentUuid: string

    /**
     * The variable to create
     */
    readonly body: DeploymentVariable
}

/**
 * Request parameters for createPipelineForRepository operation in PipelinesApi.
 */
export interface PipelinesApiCreatePipelineForRepositoryRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The pipeline to initiate.
     */
    readonly body: Pipeline
}

/**
 * Request parameters for createPipelineVariableForTeam operation in PipelinesApi.
 */
export interface PipelinesApiCreatePipelineVariableForTeamRequest {
    /**
     * The account.
     */
    readonly username: string

    /**
     * The variable to create.
     */
    readonly body?: PipelineVariable
}

/**
 * Request parameters for createPipelineVariableForUser operation in PipelinesApi.
 */
export interface PipelinesApiCreatePipelineVariableForUserRequest {
    /**
     * Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
     */
    readonly selectedUser: string

    /**
     * The variable to create.
     */
    readonly body?: PipelineVariable
}

/**
 * Request parameters for createPipelineVariableForWorkspace operation in PipelinesApi.
 */
export interface PipelinesApiCreatePipelineVariableForWorkspaceRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The variable to create.
     */
    readonly body?: PipelineVariable
}

/**
 * Request parameters for createRepositoryPipelineKnownHost operation in PipelinesApi.
 */
export interface PipelinesApiCreateRepositoryPipelineKnownHostRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The known host to create.
     */
    readonly body: PipelineKnownHost
}

/**
 * Request parameters for createRepositoryPipelineSchedule operation in PipelinesApi.
 */
export interface PipelinesApiCreateRepositoryPipelineScheduleRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The schedule to create.
     */
    readonly body: PipelineSchedulePostRequestBody
}

/**
 * Request parameters for createRepositoryPipelineVariable operation in PipelinesApi.
 */
export interface PipelinesApiCreateRepositoryPipelineVariableRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The variable to create.
     */
    readonly body: PipelineVariable
}

/**
 * Request parameters for deleteDeploymentVariable operation in PipelinesApi.
 */
export interface PipelinesApiDeleteDeploymentVariableRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The environment.
     */
    readonly environmentUuid: string

    /**
     * The UUID of the variable to delete.
     */
    readonly variableUuid: string
}

/**
 * Request parameters for deletePipelineVariableForTeam operation in PipelinesApi.
 */
export interface PipelinesApiDeletePipelineVariableForTeamRequest {
    /**
     * The account.
     */
    readonly username: string

    /**
     * The UUID of the variable to delete.
     */
    readonly variableUuid: string
}

/**
 * Request parameters for deletePipelineVariableForUser operation in PipelinesApi.
 */
export interface PipelinesApiDeletePipelineVariableForUserRequest {
    /**
     * Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
     */
    readonly selectedUser: string

    /**
     * The UUID of the variable to delete.
     */
    readonly variableUuid: string
}

/**
 * Request parameters for deletePipelineVariableForWorkspace operation in PipelinesApi.
 */
export interface PipelinesApiDeletePipelineVariableForWorkspaceRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The UUID of the variable to delete.
     */
    readonly variableUuid: string
}

/**
 * Request parameters for deleteRepositoryPipelineCache operation in PipelinesApi.
 */
export interface PipelinesApiDeleteRepositoryPipelineCacheRequest {
    /**
     * The account.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the cache to delete.
     */
    readonly cacheUuid: string
}

/**
 * Request parameters for deleteRepositoryPipelineCaches operation in PipelinesApi.
 */
export interface PipelinesApiDeleteRepositoryPipelineCachesRequest {
    /**
     * The account.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The cache name.
     */
    readonly name: string
}

/**
 * Request parameters for deleteRepositoryPipelineKeyPair operation in PipelinesApi.
 */
export interface PipelinesApiDeleteRepositoryPipelineKeyPairRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string
}

/**
 * Request parameters for deleteRepositoryPipelineKnownHost operation in PipelinesApi.
 */
export interface PipelinesApiDeleteRepositoryPipelineKnownHostRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the known host to delete.
     */
    readonly knownHostUuid: string
}

/**
 * Request parameters for deleteRepositoryPipelineSchedule operation in PipelinesApi.
 */
export interface PipelinesApiDeleteRepositoryPipelineScheduleRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The uuid of the schedule.
     */
    readonly scheduleUuid: string
}

/**
 * Request parameters for deleteRepositoryPipelineVariable operation in PipelinesApi.
 */
export interface PipelinesApiDeleteRepositoryPipelineVariableRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the variable to delete.
     */
    readonly variableUuid: string
}

/**
 * Request parameters for getDeploymentVariables operation in PipelinesApi.
 */
export interface PipelinesApiGetDeploymentVariablesRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The environment.
     */
    readonly environmentUuid: string
}

/**
 * Request parameters for getOIDCConfiguration operation in PipelinesApi.
 */
export interface PipelinesApiGetOIDCConfigurationRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string
}

/**
 * Request parameters for getOIDCKeys operation in PipelinesApi.
 */
export interface PipelinesApiGetOIDCKeysRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string
}

/**
 * Request parameters for getPipelineContainerLog operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelineContainerLogRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the pipeline.
     */
    readonly pipelineUuid: string

    /**
     * The UUID of the step.
     */
    readonly stepUuid: string

    /**
     * For the main build container specify the step UUID; for a service container specify the service container UUID
     */
    readonly logUuid: string
}

/**
 * Request parameters for getPipelineForRepository operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelineForRepositoryRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The pipeline UUID.
     */
    readonly pipelineUuid: string
}

/**
 * Request parameters for getPipelineStepForRepository operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelineStepForRepositoryRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the pipeline.
     */
    readonly pipelineUuid: string

    /**
     * The UUID of the step.
     */
    readonly stepUuid: string
}

/**
 * Request parameters for getPipelineStepLogForRepository operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelineStepLogForRepositoryRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the pipeline.
     */
    readonly pipelineUuid: string

    /**
     * The UUID of the step.
     */
    readonly stepUuid: string
}

/**
 * Request parameters for getPipelineStepsForRepository operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelineStepsForRepositoryRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the pipeline.
     */
    readonly pipelineUuid: string
}

/**
 * Request parameters for getPipelineTestReportTestCaseReasons operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelineTestReportTestCaseReasonsRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the pipeline.
     */
    readonly pipelineUuid: string

    /**
     * The UUID of the step.
     */
    readonly stepUuid: string

    /**
     * The UUID of the test case.
     */
    readonly testCaseUuid: string
}

/**
 * Request parameters for getPipelineTestReportTestCases operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelineTestReportTestCasesRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the pipeline.
     */
    readonly pipelineUuid: string

    /**
     * The UUID of the step.
     */
    readonly stepUuid: string
}

/**
 * Request parameters for getPipelineTestReports operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelineTestReportsRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the pipeline.
     */
    readonly pipelineUuid: string

    /**
     * The UUID of the step.
     */
    readonly stepUuid: string
}

/**
 * Request parameters for getPipelineVariableForTeam operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelineVariableForTeamRequest {
    /**
     * The account.
     */
    readonly username: string

    /**
     * The UUID of the variable to retrieve.
     */
    readonly variableUuid: string
}

/**
 * Request parameters for getPipelineVariableForUser operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelineVariableForUserRequest {
    /**
     * Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
     */
    readonly selectedUser: string

    /**
     * The UUID of the variable to retrieve.
     */
    readonly variableUuid: string
}

/**
 * Request parameters for getPipelineVariableForWorkspace operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelineVariableForWorkspaceRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The UUID of the variable to retrieve.
     */
    readonly variableUuid: string
}

/**
 * Request parameters for getPipelineVariablesForTeam operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelineVariablesForTeamRequest {
    /**
     * The account.
     */
    readonly username: string
}

/**
 * Request parameters for getPipelineVariablesForUser operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelineVariablesForUserRequest {
    /**
     * Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
     */
    readonly selectedUser: string
}

/**
 * Request parameters for getPipelineVariablesForWorkspace operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelineVariablesForWorkspaceRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string
}

/**
 * Request parameters for getPipelinesForRepository operation in PipelinesApi.
 */
export interface PipelinesApiGetPipelinesForRepositoryRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the creator of the pipeline to filter by.
     */
    readonly creatorUuid?: string

    /**
     * The type of the reference to filter by.
     */
    readonly targetRefType?: GetPipelinesForRepositoryTargetRefTypeEnum

    /**
     * The reference name to filter by.
     */
    readonly targetRefName?: string

    /**
     * The name of the branch to filter by.
     */
    readonly targetBranch?: string

    /**
     * The revision to filter by.
     */
    readonly targetCommitHash?: string

    /**
     * The pipeline pattern to filter by.
     */
    readonly targetSelectorPattern?: string

    /**
     * The type of pipeline to filter by.
     */
    readonly targetSelectorType?: GetPipelinesForRepositoryTargetSelectorTypeEnum

    /**
     * The creation date to filter by.
     */
    readonly createdOn?: string

    /**
     * The trigger type to filter by.
     */
    readonly triggerType?: GetPipelinesForRepositoryTriggerTypeEnum

    /**
     * The pipeline status to filter by.
     */
    readonly status?: GetPipelinesForRepositoryStatusEnum

    /**
     * The attribute name to sort on.
     */
    readonly sort?: GetPipelinesForRepositorySortEnum

    /**
     * The page number of elements to retrieve.
     */
    readonly page?: number

    /**
     * The maximum number of results to return.
     */
    readonly pagelen?: number
}

/**
 * Request parameters for getRepositoryPipelineCacheContentURI operation in PipelinesApi.
 */
export interface PipelinesApiGetRepositoryPipelineCacheContentURIRequest {
    /**
     * The account.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the cache.
     */
    readonly cacheUuid: string
}

/**
 * Request parameters for getRepositoryPipelineCaches operation in PipelinesApi.
 */
export interface PipelinesApiGetRepositoryPipelineCachesRequest {
    /**
     * The account.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string
}

/**
 * Request parameters for getRepositoryPipelineConfig operation in PipelinesApi.
 */
export interface PipelinesApiGetRepositoryPipelineConfigRequest {
    /**
     * The account.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string
}

/**
 * Request parameters for getRepositoryPipelineKnownHost operation in PipelinesApi.
 */
export interface PipelinesApiGetRepositoryPipelineKnownHostRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the known host to retrieve.
     */
    readonly knownHostUuid: string
}

/**
 * Request parameters for getRepositoryPipelineKnownHosts operation in PipelinesApi.
 */
export interface PipelinesApiGetRepositoryPipelineKnownHostsRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string
}

/**
 * Request parameters for getRepositoryPipelineSchedule operation in PipelinesApi.
 */
export interface PipelinesApiGetRepositoryPipelineScheduleRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The uuid of the schedule.
     */
    readonly scheduleUuid: string
}

/**
 * Request parameters for getRepositoryPipelineScheduleExecutions operation in PipelinesApi.
 */
export interface PipelinesApiGetRepositoryPipelineScheduleExecutionsRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The uuid of the schedule.
     */
    readonly scheduleUuid: string
}

/**
 * Request parameters for getRepositoryPipelineSchedules operation in PipelinesApi.
 */
export interface PipelinesApiGetRepositoryPipelineSchedulesRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string
}

/**
 * Request parameters for getRepositoryPipelineSshKeyPair operation in PipelinesApi.
 */
export interface PipelinesApiGetRepositoryPipelineSshKeyPairRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string
}

/**
 * Request parameters for getRepositoryPipelineVariable operation in PipelinesApi.
 */
export interface PipelinesApiGetRepositoryPipelineVariableRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the variable to retrieve.
     */
    readonly variableUuid: string
}

/**
 * Request parameters for getRepositoryPipelineVariables operation in PipelinesApi.
 */
export interface PipelinesApiGetRepositoryPipelineVariablesRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string
}

/**
 * Request parameters for stopPipeline operation in PipelinesApi.
 */
export interface PipelinesApiStopPipelineRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the pipeline.
     */
    readonly pipelineUuid: string
}

/**
 * Request parameters for updateDeploymentVariable operation in PipelinesApi.
 */
export interface PipelinesApiUpdateDeploymentVariableRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The environment.
     */
    readonly environmentUuid: string

    /**
     * The UUID of the variable to update.
     */
    readonly variableUuid: string

    /**
     * The updated deployment variable.
     */
    readonly body: DeploymentVariable
}

/**
 * Request parameters for updatePipelineVariableForTeam operation in PipelinesApi.
 */
export interface PipelinesApiUpdatePipelineVariableForTeamRequest {
    /**
     * The account.
     */
    readonly username: string

    /**
     * The UUID of the variable.
     */
    readonly variableUuid: string

    /**
     * The updated variable.
     */
    readonly body: PipelineVariable
}

/**
 * Request parameters for updatePipelineVariableForUser operation in PipelinesApi.
 */
export interface PipelinesApiUpdatePipelineVariableForUserRequest {
    /**
     * Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
     */
    readonly selectedUser: string

    /**
     * The UUID of the variable.
     */
    readonly variableUuid: string

    /**
     * The updated variable.
     */
    readonly body: PipelineVariable
}

/**
 * Request parameters for updatePipelineVariableForWorkspace operation in PipelinesApi.
 */
export interface PipelinesApiUpdatePipelineVariableForWorkspaceRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The UUID of the variable.
     */
    readonly variableUuid: string

    /**
     * The updated variable.
     */
    readonly body: PipelineVariable
}

/**
 * Request parameters for updateRepositoryBuildNumber operation in PipelinesApi.
 */
export interface PipelinesApiUpdateRepositoryBuildNumberRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The build number to update.
     */
    readonly body: PipelineBuildNumber
}

/**
 * Request parameters for updateRepositoryPipelineConfig operation in PipelinesApi.
 */
export interface PipelinesApiUpdateRepositoryPipelineConfigRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The updated repository pipelines configuration.
     */
    readonly body: PipelinesConfig
}

/**
 * Request parameters for updateRepositoryPipelineKeyPair operation in PipelinesApi.
 */
export interface PipelinesApiUpdateRepositoryPipelineKeyPairRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The created or updated SSH key pair.
     */
    readonly body: PipelineSshKeyPair
}

/**
 * Request parameters for updateRepositoryPipelineKnownHost operation in PipelinesApi.
 */
export interface PipelinesApiUpdateRepositoryPipelineKnownHostRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the known host to update.
     */
    readonly knownHostUuid: string

    /**
     * The updated known host.
     */
    readonly body: PipelineKnownHost
}

/**
 * Request parameters for updateRepositoryPipelineSchedule operation in PipelinesApi.
 */
export interface PipelinesApiUpdateRepositoryPipelineScheduleRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The uuid of the schedule.
     */
    readonly scheduleUuid: string

    /**
     * The schedule to update.
     */
    readonly body: PipelineSchedulePutRequestBody
}

/**
 * Request parameters for updateRepositoryPipelineVariable operation in PipelinesApi.
 */
export interface PipelinesApiUpdateRepositoryPipelineVariableRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The UUID of the variable to update.
     */
    readonly variableUuid: string

    /**
     * The updated variable
     */
    readonly body: PipelineVariable
}

/**
 * PipelinesApi - object-oriented interface
 */
export class PipelinesApi extends BaseAPI implements PipelinesApiInterface {
    /**
     * Create a deployment environment level variable.
     * @summary Create a variable for an environment
     * @param {PipelinesApiCreateDeploymentVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createDeploymentVariable(requestParameters: PipelinesApiCreateDeploymentVariableRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).createDeploymentVariable(requestParameters.workspace, requestParameters.repoSlug, requestParameters.environmentUuid, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint to create and initiate a pipeline. There are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated. # Trigger a Pipeline for a branch One way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline. The specified branch will be used to determine which pipeline definition from the `bitbucket-pipelines.yml` file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\   -d \'   {     \"target\": {       \"ref_type\": \"branch\",       \"type\": \"pipeline_ref_target\",       \"ref_name\": \"master\"     }   }\' ``` # Trigger a Pipeline for a commit on a branch or tag You can initiate a pipeline for a specific commit and in the context of a specified reference (e.g. a branch, tag or bookmark). The specified reference will be used to determine which pipeline definition from the bitbucket-pipelines.yml file will be applied to initiate the pipeline. The pipeline will clone the repository and then do a checkout the specified reference.  The following reference types are supported:  * `branch` * `named_branch` * `bookmark`  * `tag`  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\   https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\   -d \'   {     \"target\": {       \"commit\": {         \"type\": \"commit\",         \"hash\": \"ce5b7431602f7cbba007062eeb55225c6e18e956\"       },       \"ref_type\": \"branch\",       \"type\": \"pipeline_ref_target\",       \"ref_name\": \"master\"     }   }\' ``` # Trigger a specific pipeline definition for a commit You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit. In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition. The resulting pipeline will then clone the repository and checkout the specified revision.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\  -d \'   {      \"target\": {       \"commit\": {          \"hash\":\"a3c4e02c9a3755eccdc3764e6ea13facdf30f923\",          \"type\":\"commit\"        },         \"selector\": {            \"type\":\"custom\",               \"pattern\":\"Deploy to production\"           },         \"type\":\"pipeline_commit_target\"    }   }\' ``` # Trigger a specific pipeline definition for a commit on a branch or tag You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit in the context of a specified reference. In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition, as well as the reference information. The resulting pipeline will then clone the repository a checkout the specified reference.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \\  -d \'   {      \"target\": {       \"commit\": {          \"hash\":\"a3c4e02c9a3755eccdc3764e6ea13facdf30f923\",          \"type\":\"commit\"        },        \"selector\": {           \"type\": \"custom\",           \"pattern\": \"Deploy to production\"        },        \"type\": \"pipeline_ref_target\",        \"ref_name\": \"master\",        \"ref_type\": \"branch\"      }   }\' ```   # Trigger a custom pipeline with variables In addition to triggering a custom pipeline that is defined in your `bitbucket-pipelines.yml` file as shown in the examples above, you can specify variables that will be available for your build. In the request, provide a list of variables, specifying the following for each variable: key, value, and whether it should be secured or not (this field is optional and defaults to not secured).  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \\  -d \'   {     \"target\": {       \"type\": \"pipeline_ref_target\",       \"ref_type\": \"branch\",       \"ref_name\": \"master\",       \"selector\": {         \"type\": \"custom\",         \"pattern\": \"Deploy to production\"       }     },     \"variables\": [       {         \"key\": \"var1key\",         \"value\": \"var1value\",         \"secured\": true       },       {         \"key\": \"var2key\",         \"value\": \"var2value\"       }     ]   }\' ```  # Trigger a pull request pipeline  You can also initiate a pipeline for a specific pull request.  ### Example  ``` $ curl -X POST -is -u username:password \\   -H \'Content-Type: application/json\' \\  https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \\  -d \'   {     \"target\": {       \"type\": \"pipeline_pullrequest_target\",       \"source\": \"pull-request-branch\",       \"destination\": \"master\",       \"destination_commit\": {         \"hash\": \"9f848b7\"       },       \"commit\": {         \"hash\": \"1a372fc\"       },       \"pullrequest\": {         \"id\": \"3\"       },       \"selector\": {         \"type\": \"pull-requests\",         \"pattern\": \"**\"       }     }   }\' ``` 
     * @summary Run a pipeline
     * @param {PipelinesApiCreatePipelineForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPipelineForRepository(requestParameters: PipelinesApiCreatePipelineForRepositoryRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).createPipelineForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an account level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Create a variable for a user
     * @param {PipelinesApiCreatePipelineVariableForTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public createPipelineVariableForTeam(requestParameters: PipelinesApiCreatePipelineVariableForTeamRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).createPipelineVariableForTeam(requestParameters.username, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Create a variable for a user
     * @param {PipelinesApiCreatePipelineVariableForUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public createPipelineVariableForUser(requestParameters: PipelinesApiCreatePipelineVariableForUserRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).createPipelineVariableForUser(requestParameters.selectedUser, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a workspace level variable.
     * @summary Create a variable for a workspace
     * @param {PipelinesApiCreatePipelineVariableForWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPipelineVariableForWorkspace(requestParameters: PipelinesApiCreatePipelineVariableForWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).createPipelineVariableForWorkspace(requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a repository level known host.
     * @summary Create a known host
     * @param {PipelinesApiCreateRepositoryPipelineKnownHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRepositoryPipelineKnownHost(requestParameters: PipelinesApiCreateRepositoryPipelineKnownHostRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).createRepositoryPipelineKnownHost(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a schedule for the given repository.
     * @summary Create a schedule
     * @param {PipelinesApiCreateRepositoryPipelineScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRepositoryPipelineSchedule(requestParameters: PipelinesApiCreateRepositoryPipelineScheduleRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).createRepositoryPipelineSchedule(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a repository level variable.
     * @summary Create a variable for a repository
     * @param {PipelinesApiCreateRepositoryPipelineVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRepositoryPipelineVariable(requestParameters: PipelinesApiCreateRepositoryPipelineVariableRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).createRepositoryPipelineVariable(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a deployment environment level variable.
     * @summary Delete a variable for an environment
     * @param {PipelinesApiDeleteDeploymentVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteDeploymentVariable(requestParameters: PipelinesApiDeleteDeploymentVariableRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).deleteDeploymentVariable(requestParameters.workspace, requestParameters.repoSlug, requestParameters.environmentUuid, requestParameters.variableUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Delete a variable for a team
     * @param {PipelinesApiDeletePipelineVariableForTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public deletePipelineVariableForTeam(requestParameters: PipelinesApiDeletePipelineVariableForTeamRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).deletePipelineVariableForTeam(requestParameters.username, requestParameters.variableUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an account level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Delete a variable for a user
     * @param {PipelinesApiDeletePipelineVariableForUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public deletePipelineVariableForUser(requestParameters: PipelinesApiDeletePipelineVariableForUserRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).deletePipelineVariableForUser(requestParameters.selectedUser, requestParameters.variableUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a workspace level variable.
     * @summary Delete a variable for a workspace
     * @param {PipelinesApiDeletePipelineVariableForWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePipelineVariableForWorkspace(requestParameters: PipelinesApiDeletePipelineVariableForWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).deletePipelineVariableForWorkspace(requestParameters.workspace, requestParameters.variableUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a repository cache.
     * @summary Delete a cache
     * @param {PipelinesApiDeleteRepositoryPipelineCacheRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRepositoryPipelineCache(requestParameters: PipelinesApiDeleteRepositoryPipelineCacheRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).deleteRepositoryPipelineCache(requestParameters.workspace, requestParameters.repoSlug, requestParameters.cacheUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete repository cache versions by name.
     * @summary Delete caches
     * @param {PipelinesApiDeleteRepositoryPipelineCachesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRepositoryPipelineCaches(requestParameters: PipelinesApiDeleteRepositoryPipelineCachesRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).deleteRepositoryPipelineCaches(requestParameters.workspace, requestParameters.repoSlug, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the repository SSH key pair.
     * @summary Delete SSH key pair
     * @param {PipelinesApiDeleteRepositoryPipelineKeyPairRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRepositoryPipelineKeyPair(requestParameters: PipelinesApiDeleteRepositoryPipelineKeyPairRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).deleteRepositoryPipelineKeyPair(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a repository level known host.
     * @summary Delete a known host
     * @param {PipelinesApiDeleteRepositoryPipelineKnownHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRepositoryPipelineKnownHost(requestParameters: PipelinesApiDeleteRepositoryPipelineKnownHostRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).deleteRepositoryPipelineKnownHost(requestParameters.workspace, requestParameters.repoSlug, requestParameters.knownHostUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a schedule.
     * @summary Delete a schedule
     * @param {PipelinesApiDeleteRepositoryPipelineScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRepositoryPipelineSchedule(requestParameters: PipelinesApiDeleteRepositoryPipelineScheduleRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).deleteRepositoryPipelineSchedule(requestParameters.workspace, requestParameters.repoSlug, requestParameters.scheduleUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a repository level variable.
     * @summary Delete a variable for a repository
     * @param {PipelinesApiDeleteRepositoryPipelineVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRepositoryPipelineVariable(requestParameters: PipelinesApiDeleteRepositoryPipelineVariableRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).deleteRepositoryPipelineVariable(requestParameters.workspace, requestParameters.repoSlug, requestParameters.variableUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find deployment environment level variables.
     * @summary List variables for an environment
     * @param {PipelinesApiGetDeploymentVariablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDeploymentVariables(requestParameters: PipelinesApiGetDeploymentVariablesRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getDeploymentVariables(requestParameters.workspace, requestParameters.repoSlug, requestParameters.environmentUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
     * @summary Get OpenID configuration for OIDC in Pipelines
     * @param {PipelinesApiGetOIDCConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOIDCConfiguration(requestParameters: PipelinesApiGetOIDCConfigurationRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getOIDCConfiguration(requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
     * @summary Get keys for OIDC in Pipelines
     * @param {PipelinesApiGetOIDCKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOIDCKeys(requestParameters: PipelinesApiGetOIDCKeysRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getOIDCKeys(requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the log file for a build container or service container.  This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
     * @summary Get the logs for the build container or a service container for a given step of a pipeline.
     * @param {PipelinesApiGetPipelineContainerLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineContainerLog(requestParameters: PipelinesApiGetPipelineContainerLogRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineContainerLog(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, requestParameters.stepUuid, requestParameters.logUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specified pipeline
     * @summary Get a pipeline
     * @param {PipelinesApiGetPipelineForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineForRepository(requestParameters: PipelinesApiGetPipelineForRepositoryRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a given step of a pipeline.
     * @summary Get a step of a pipeline
     * @param {PipelinesApiGetPipelineStepForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineStepForRepository(requestParameters: PipelinesApiGetPipelineStepForRepositoryRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineStepForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, requestParameters.stepUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the log file for a given step of a pipeline.  This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
     * @summary Get log file for a step
     * @param {PipelinesApiGetPipelineStepLogForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineStepLogForRepository(requestParameters: PipelinesApiGetPipelineStepLogForRepositoryRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineStepLogForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, requestParameters.stepUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find steps for the given pipeline.
     * @summary List steps for a pipeline
     * @param {PipelinesApiGetPipelineStepsForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineStepsForRepository(requestParameters: PipelinesApiGetPipelineStepsForRepositoryRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineStepsForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get test case reasons (output) for a given test case in a step of a pipeline.
     * @param {PipelinesApiGetPipelineTestReportTestCaseReasonsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineTestReportTestCaseReasons(requestParameters: PipelinesApiGetPipelineTestReportTestCaseReasonsRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineTestReportTestCaseReasons(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, requestParameters.stepUuid, requestParameters.testCaseUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get test cases for a given step of a pipeline.
     * @param {PipelinesApiGetPipelineTestReportTestCasesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineTestReportTestCases(requestParameters: PipelinesApiGetPipelineTestReportTestCasesRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineTestReportTestCases(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, requestParameters.stepUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a summary of test reports for a given step of a pipeline.
     * @param {PipelinesApiGetPipelineTestReportsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineTestReports(requestParameters: PipelinesApiGetPipelineTestReportsRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineTestReports(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, requestParameters.stepUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Get a variable for a team
     * @param {PipelinesApiGetPipelineVariableForTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public getPipelineVariableForTeam(requestParameters: PipelinesApiGetPipelineVariableForTeamRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineVariableForTeam(requestParameters.username, requestParameters.variableUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Get a variable for a user
     * @param {PipelinesApiGetPipelineVariableForUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public getPipelineVariableForUser(requestParameters: PipelinesApiGetPipelineVariableForUserRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineVariableForUser(requestParameters.selectedUser, requestParameters.variableUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a workspace level variable.
     * @summary Get variable for a workspace
     * @param {PipelinesApiGetPipelineVariableForWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineVariableForWorkspace(requestParameters: PipelinesApiGetPipelineVariableForWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineVariableForWorkspace(requestParameters.workspace, requestParameters.variableUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find account level variables. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary List variables for an account
     * @param {PipelinesApiGetPipelineVariablesForTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public getPipelineVariablesForTeam(requestParameters: PipelinesApiGetPipelineVariablesForTeamRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineVariablesForTeam(requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find user level variables. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary List variables for a user
     * @param {PipelinesApiGetPipelineVariablesForUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public getPipelineVariablesForUser(requestParameters: PipelinesApiGetPipelineVariablesForUserRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineVariablesForUser(requestParameters.selectedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find workspace level variables.
     * @summary List variables for a workspace
     * @param {PipelinesApiGetPipelineVariablesForWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineVariablesForWorkspace(requestParameters: PipelinesApiGetPipelineVariablesForWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineVariablesForWorkspace(requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find pipelines in a repository.  Note that unlike other endpoints in the Bitbucket API, this endpoint utilizes query parameters to allow filtering and sorting of returned results. See [query parameters](#api-repositories-workspace-repo-slug-pipelines-get-request-Query%20parameters) for specific details. 
     * @summary List pipelines
     * @param {PipelinesApiGetPipelinesForRepositoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelinesForRepository(requestParameters: PipelinesApiGetPipelinesForRepositoryRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelinesForRepository(requestParameters.workspace, requestParameters.repoSlug, requestParameters.creatorUuid, requestParameters.targetRefType, requestParameters.targetRefName, requestParameters.targetBranch, requestParameters.targetCommitHash, requestParameters.targetSelectorPattern, requestParameters.targetSelectorType, requestParameters.createdOn, requestParameters.triggerType, requestParameters.status, requestParameters.sort, requestParameters.page, requestParameters.pagelen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the URI of the content of the specified cache.
     * @summary Get cache content URI
     * @param {PipelinesApiGetRepositoryPipelineCacheContentURIRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryPipelineCacheContentURI(requestParameters: PipelinesApiGetRepositoryPipelineCacheContentURIRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getRepositoryPipelineCacheContentURI(requestParameters.workspace, requestParameters.repoSlug, requestParameters.cacheUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the repository pipelines caches.
     * @summary List caches
     * @param {PipelinesApiGetRepositoryPipelineCachesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryPipelineCaches(requestParameters: PipelinesApiGetRepositoryPipelineCachesRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getRepositoryPipelineCaches(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the repository pipelines configuration.
     * @summary Get configuration
     * @param {PipelinesApiGetRepositoryPipelineConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryPipelineConfig(requestParameters: PipelinesApiGetRepositoryPipelineConfigRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getRepositoryPipelineConfig(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a repository level known host.
     * @summary Get a known host
     * @param {PipelinesApiGetRepositoryPipelineKnownHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryPipelineKnownHost(requestParameters: PipelinesApiGetRepositoryPipelineKnownHostRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getRepositoryPipelineKnownHost(requestParameters.workspace, requestParameters.repoSlug, requestParameters.knownHostUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find repository level known hosts.
     * @summary List known hosts
     * @param {PipelinesApiGetRepositoryPipelineKnownHostsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryPipelineKnownHosts(requestParameters: PipelinesApiGetRepositoryPipelineKnownHostsRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getRepositoryPipelineKnownHosts(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a schedule by its UUID.
     * @summary Get a schedule
     * @param {PipelinesApiGetRepositoryPipelineScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryPipelineSchedule(requestParameters: PipelinesApiGetRepositoryPipelineScheduleRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getRepositoryPipelineSchedule(requestParameters.workspace, requestParameters.repoSlug, requestParameters.scheduleUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the executions of a given schedule.
     * @summary List executions of a schedule
     * @param {PipelinesApiGetRepositoryPipelineScheduleExecutionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryPipelineScheduleExecutions(requestParameters: PipelinesApiGetRepositoryPipelineScheduleExecutionsRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getRepositoryPipelineScheduleExecutions(requestParameters.workspace, requestParameters.repoSlug, requestParameters.scheduleUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the configured schedules for the given repository.
     * @summary List schedules
     * @param {PipelinesApiGetRepositoryPipelineSchedulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryPipelineSchedules(requestParameters: PipelinesApiGetRepositoryPipelineSchedulesRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getRepositoryPipelineSchedules(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.
     * @summary Get SSH key pair
     * @param {PipelinesApiGetRepositoryPipelineSshKeyPairRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryPipelineSshKeyPair(requestParameters: PipelinesApiGetRepositoryPipelineSshKeyPairRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getRepositoryPipelineSshKeyPair(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a repository level variable.
     * @summary Get a variable for a repository
     * @param {PipelinesApiGetRepositoryPipelineVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryPipelineVariable(requestParameters: PipelinesApiGetRepositoryPipelineVariableRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getRepositoryPipelineVariable(requestParameters.workspace, requestParameters.repoSlug, requestParameters.variableUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find repository level variables.
     * @summary List variables for a repository
     * @param {PipelinesApiGetRepositoryPipelineVariablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryPipelineVariables(requestParameters: PipelinesApiGetRepositoryPipelineVariablesRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getRepositoryPipelineVariables(requestParameters.workspace, requestParameters.repoSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Signal the stop of a pipeline and all of its steps that not have completed yet.
     * @summary Stop a pipeline
     * @param {PipelinesApiStopPipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public stopPipeline(requestParameters: PipelinesApiStopPipelineRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).stopPipeline(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pipelineUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a deployment environment level variable.
     * @summary Update a variable for an environment
     * @param {PipelinesApiUpdateDeploymentVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDeploymentVariable(requestParameters: PipelinesApiUpdateDeploymentVariableRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).updateDeploymentVariable(requestParameters.workspace, requestParameters.repoSlug, requestParameters.environmentUuid, requestParameters.variableUuid, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a team level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Update a variable for a team
     * @param {PipelinesApiUpdatePipelineVariableForTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public updatePipelineVariableForTeam(requestParameters: PipelinesApiUpdatePipelineVariableForTeamRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).updatePipelineVariableForTeam(requestParameters.username, requestParameters.variableUuid, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user level variable. This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * @summary Update a variable for a user
     * @param {PipelinesApiUpdatePipelineVariableForUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public updatePipelineVariableForUser(requestParameters: PipelinesApiUpdatePipelineVariableForUserRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).updatePipelineVariableForUser(requestParameters.selectedUser, requestParameters.variableUuid, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a workspace level variable.
     * @summary Update variable for a workspace
     * @param {PipelinesApiUpdatePipelineVariableForWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePipelineVariableForWorkspace(requestParameters: PipelinesApiUpdatePipelineVariableForWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).updatePipelineVariableForWorkspace(requestParameters.workspace, requestParameters.variableUuid, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.
     * @summary Update the next build number
     * @param {PipelinesApiUpdateRepositoryBuildNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRepositoryBuildNumber(requestParameters: PipelinesApiUpdateRepositoryBuildNumberRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).updateRepositoryBuildNumber(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the pipelines configuration for a repository.
     * @summary Update configuration
     * @param {PipelinesApiUpdateRepositoryPipelineConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRepositoryPipelineConfig(requestParameters: PipelinesApiUpdateRepositoryPipelineConfigRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).updateRepositoryPipelineConfig(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.
     * @summary Update SSH key pair
     * @param {PipelinesApiUpdateRepositoryPipelineKeyPairRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRepositoryPipelineKeyPair(requestParameters: PipelinesApiUpdateRepositoryPipelineKeyPairRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).updateRepositoryPipelineKeyPair(requestParameters.workspace, requestParameters.repoSlug, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a repository level known host.
     * @summary Update a known host
     * @param {PipelinesApiUpdateRepositoryPipelineKnownHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRepositoryPipelineKnownHost(requestParameters: PipelinesApiUpdateRepositoryPipelineKnownHostRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).updateRepositoryPipelineKnownHost(requestParameters.workspace, requestParameters.repoSlug, requestParameters.knownHostUuid, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a schedule.
     * @summary Update a schedule
     * @param {PipelinesApiUpdateRepositoryPipelineScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRepositoryPipelineSchedule(requestParameters: PipelinesApiUpdateRepositoryPipelineScheduleRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).updateRepositoryPipelineSchedule(requestParameters.workspace, requestParameters.repoSlug, requestParameters.scheduleUuid, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a repository level variable.
     * @summary Update a variable for a repository
     * @param {PipelinesApiUpdateRepositoryPipelineVariableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRepositoryPipelineVariable(requestParameters: PipelinesApiUpdateRepositoryPipelineVariableRequest, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).updateRepositoryPipelineVariable(requestParameters.workspace, requestParameters.repoSlug, requestParameters.variableUuid, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetPipelinesForRepositoryTargetRefTypeEnum = {
    Branch: 'BRANCH',
    Tag: 'TAG',
    AnnotatedTag: 'ANNOTATED_TAG'
} as const;
export type GetPipelinesForRepositoryTargetRefTypeEnum = typeof GetPipelinesForRepositoryTargetRefTypeEnum[keyof typeof GetPipelinesForRepositoryTargetRefTypeEnum];
export const GetPipelinesForRepositoryTargetSelectorTypeEnum = {
    Branch: 'BRANCH',
    Tag: 'TAG',
    Custom: 'CUSTOM',
    Pullrequests: 'PULLREQUESTS',
    Default: 'DEFAULT'
} as const;
export type GetPipelinesForRepositoryTargetSelectorTypeEnum = typeof GetPipelinesForRepositoryTargetSelectorTypeEnum[keyof typeof GetPipelinesForRepositoryTargetSelectorTypeEnum];
export const GetPipelinesForRepositoryTriggerTypeEnum = {
    Push: 'PUSH',
    Manual: 'MANUAL',
    Scheduled: 'SCHEDULED',
    ParentStep: 'PARENT_STEP'
} as const;
export type GetPipelinesForRepositoryTriggerTypeEnum = typeof GetPipelinesForRepositoryTriggerTypeEnum[keyof typeof GetPipelinesForRepositoryTriggerTypeEnum];
export const GetPipelinesForRepositoryStatusEnum = {
    Parsing: 'PARSING',
    Pending: 'PENDING',
    Paused: 'PAUSED',
    Halted: 'HALTED',
    Building: 'BUILDING',
    Error: 'ERROR',
    Passed: 'PASSED',
    Failed: 'FAILED',
    Stopped: 'STOPPED',
    Unknown: 'UNKNOWN'
} as const;
export type GetPipelinesForRepositoryStatusEnum = typeof GetPipelinesForRepositoryStatusEnum[keyof typeof GetPipelinesForRepositoryStatusEnum];
export const GetPipelinesForRepositorySortEnum = {
    CreatorUuid: 'creator.uuid',
    CreatedOn: 'created_on',
    RunCreationDate: 'run_creation_date'
} as const;
export type GetPipelinesForRepositorySortEnum = typeof GetPipelinesForRepositorySortEnum[keyof typeof GetPipelinesForRepositorySortEnum];


/**
 * ProjectsApi - axios parameter creator
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new project.  Note that the avatar has to be embedded as either a data-url or a URL to an external image as shown in the examples below:  ``` $ body=$(cat << EOF {     \"name\": \"Mars Project\",     \"key\": \"MARS\",     \"description\": \"Software for colonizing mars.\",     \"links\": {         \"avatar\": {             \"href\": \"data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/...\"         }     },     \"is_private\": false } EOF ) $ curl -H \"Content-Type: application/json\" \\        -X POST \\        -d \"$body\" \\        https://api.bitbucket.org/2.0/workspaces/teams-in-space/projects/ | jq . {   // Serialized project document } ```  or even:  ``` $ body=$(cat << EOF {     \"name\": \"Mars Project\",     \"key\": \"MARS\",     \"description\": \"Software for colonizing mars.\",     \"links\": {         \"avatar\": {             \"href\": \"http://i.imgur.com/72tRx4w.gif\"         }     },     \"is_private\": false } EOF ) $ curl -H \"Content-Type: application/json\" \\        -X POST \\        -d \"$body\" \\        https://api.bitbucket.org/2.0/workspaces/teams-in-space/projects/ | jq . {   // Serialized project document } ```
         * @summary Create a project in a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Project} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsPost: async (workspace: string, body: Project, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsPost', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsPost', 'body', body)
            const localVarPath = `/workspaces/{workspace}/projects`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of all default reviewers for a project. This is a list of users that will be added as default reviewers to pull requests for any repository within the project.
         * @summary List the default reviewers in a project
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDefaultReviewersGet: async (projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDefaultReviewersGet', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDefaultReviewersGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/default-reviewers`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a default reviewer from the project.  Example: ``` $ curl https://api.bitbucket.org/2.0/.../default-reviewers/%7Bf0e0e8e9-66c1-4b85-a784-44a9eb9ef1a6%7D  HTTP/1.1 204 ```
         * @summary Remove the specific user from the project\'s default reviewers
         * @param {string} projectKey The project in question. This can either be the actual &#x60;key&#x60; assigned to the project or the &#x60;UUID&#x60; (surrounded by curly-braces (&#x60;{}&#x60;)). 
         * @param {string} selectedUser This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDelete: async (projectKey: string, selectedUser: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDelete', 'projectKey', projectKey)
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDelete', 'selectedUser', selectedUser)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDelete', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/default-reviewers/{selected_user}`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified default reviewer.
         * @summary Get a default reviewer
         * @param {string} projectKey The project in question. This can either be the actual &#x60;key&#x60; assigned to the project or the &#x60;UUID&#x60; (surrounded by curly-braces (&#x60;{}&#x60;)). 
         * @param {string} selectedUser This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGet: async (projectKey: string, selectedUser: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGet', 'projectKey', projectKey)
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGet', 'selectedUser', selectedUser)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/default-reviewers/{selected_user}`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds the specified user to the project\'s list of default reviewers. The method is idempotent. Accepts an optional body containing the `uuid` of the user to be added.
         * @summary Add the specific user as a default reviewer for the project
         * @param {string} projectKey The project in question. This can either be the actual &#x60;key&#x60; assigned to the project or the &#x60;UUID&#x60; (surrounded by curly-braces (&#x60;{}&#x60;)). 
         * @param {string} selectedUser This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPut: async (projectKey: string, selectedUser: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPut', 'projectKey', projectKey)
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPut', 'selectedUser', selectedUser)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPut', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/default-reviewers/{selected_user}`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes this project. This is an irreversible operation.  You cannot delete a project that still contains repositories. To delete the project, [delete](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-repo-slug-delete) or transfer the repositories first.  Example: ``` $ curl -X DELETE https://api.bitbucket.org/2.0/workspaces/bbworkspace1/projects/PROJ ```
         * @summary Delete a project for a workspace
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDelete: async (projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDelete', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyDelete', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the requested project.
         * @summary Get a project for a workspace
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyGet: async (projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyGet', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of explicit group permissions for the given project. This endpoint does not support BBQL features.
         * @summary List explicit group permissions for a project
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGet: async (projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGet', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/permissions-config/groups`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the project group permission between the requested project and group, if one exists.  Only users with admin permission for the project may access this resource.
         * @summary Delete an explicit group permission for a project
         * @param {string} groupSlug Slug of the requested group.
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDelete: async (groupSlug: string, projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupSlug' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDelete', 'groupSlug', groupSlug)
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDelete', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDelete', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/permissions-config/groups/{group_slug}`
                .replace(`{${"group_slug"}}`, encodeURIComponent(String(groupSlug)))
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the group permission for a given group and project.  Only users with admin permission for the project may access this resource.  Permissions can be:  * `admin` * `create-repo` * `write` * `read` * `none`
         * @summary Get an explicit group permission for a project
         * @param {string} groupSlug Slug of the requested group.
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGet: async (groupSlug: string, projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupSlug' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGet', 'groupSlug', groupSlug)
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGet', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/permissions-config/groups/{group_slug}`
                .replace(`{${"group_slug"}}`, encodeURIComponent(String(groupSlug)))
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the group permission, or grants a new permission if one does not already exist.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.  Permissions can be:  * `admin` * `create-repo` * `write` * `read`
         * @summary Update an explicit group permission for a project
         * @param {string} groupSlug Slug of the requested group.
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema} body The permission to grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPut: async (groupSlug: string, projectKey: string, workspace: string, body: BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupSlug' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPut', 'groupSlug', groupSlug)
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPut', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPut', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPut', 'body', body)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/permissions-config/groups/{group_slug}`
                .replace(`{${"group_slug"}}`, encodeURIComponent(String(groupSlug)))
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of explicit user permissions for the given project. This endpoint does not support BBQL features.
         * @summary List explicit user permissions for a project
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGet: async (projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGet', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/permissions-config/users`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the project user permission between the requested project and user, if one exists.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.
         * @summary Delete an explicit user permission for a project
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} selectedUserId This can either be the username, the user\&#39;s UUID surrounded by curly-braces, for example: {account UUID}, or the user\&#39;s Atlassian ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDelete: async (projectKey: string, selectedUserId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDelete', 'projectKey', projectKey)
            // verify required parameter 'selectedUserId' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDelete', 'selectedUserId', selectedUserId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDelete', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/permissions-config/users/{selected_user_id}`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"selected_user_id"}}`, encodeURIComponent(String(selectedUserId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the explicit user permission for a given user and project.  Only users with admin permission for the project may access this resource.  Permissions can be:  * `admin` * `create-repo` * `write` * `read` * `none`
         * @summary Get an explicit user permission for a project
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} selectedUserId This can either be the username, the user\&#39;s UUID surrounded by curly-braces, for example: {account UUID}, or the user\&#39;s Atlassian ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGet: async (projectKey: string, selectedUserId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGet', 'projectKey', projectKey)
            // verify required parameter 'selectedUserId' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGet', 'selectedUserId', selectedUserId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/permissions-config/users/{selected_user_id}`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"selected_user_id"}}`, encodeURIComponent(String(selectedUserId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the explicit user permission for a given user and project. The selected user must be a member of the workspace, and cannot be the workspace owner.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.  Permissions can be:  * `admin` * `create-repo` * `write` * `read`
         * @summary Update an explicit user permission for a project
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} selectedUserId This can either be the username, the user\&#39;s UUID surrounded by curly-braces, for example: {account UUID}, or the user\&#39;s Atlassian ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema} body The permission to grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPut: async (projectKey: string, selectedUserId: string, workspace: string, body: BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPut', 'projectKey', projectKey)
            // verify required parameter 'selectedUserId' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPut', 'selectedUserId', selectedUserId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPut', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPut', 'body', body)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}/permissions-config/users/{selected_user_id}`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"selected_user_id"}}`, encodeURIComponent(String(selectedUserId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since this endpoint can be used to both update and to create a project, the request body depends on the intent.  #### Creation  See the POST documentation for the project collection for an example of the request body.  Note: The `key` should not be specified in the body of request (since it is already present in the URL). The `name` is required, everything else is optional.  #### Update  See the POST documentation for the project collection for an example of the request body.  Note: The key is not required in the body (since it is already in the URL). The key may be specified in the body, if the intent is to change the key itself. In such a scenario, the location of the project is changed and is returned in the `Location` header of the response.
         * @summary Update a project for a workspace
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Project} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPut: async (projectKey: string, workspace: string, body: Project, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPut', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPut', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyPut', 'body', body)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new project.  Note that the avatar has to be embedded as either a data-url or a URL to an external image as shown in the examples below:  ``` $ body=$(cat << EOF {     \"name\": \"Mars Project\",     \"key\": \"MARS\",     \"description\": \"Software for colonizing mars.\",     \"links\": {         \"avatar\": {             \"href\": \"data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/...\"         }     },     \"is_private\": false } EOF ) $ curl -H \"Content-Type: application/json\" \\        -X POST \\        -d \"$body\" \\        https://api.bitbucket.org/2.0/workspaces/teams-in-space/projects/ | jq . {   // Serialized project document } ```  or even:  ``` $ body=$(cat << EOF {     \"name\": \"Mars Project\",     \"key\": \"MARS\",     \"description\": \"Software for colonizing mars.\",     \"links\": {         \"avatar\": {             \"href\": \"http://i.imgur.com/72tRx4w.gif\"         }     },     \"is_private\": false } EOF ) $ curl -H \"Content-Type: application/json\" \\        -X POST \\        -d \"$body\" \\        https://api.bitbucket.org/2.0/workspaces/teams-in-space/projects/ | jq . {   // Serialized project document } ```
         * @summary Create a project in a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Project} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsPost(workspace: string, body: Project, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsPost(workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of all default reviewers for a project. This is a list of users that will be added as default reviewers to pull requests for any repository within the project.
         * @summary List the default reviewers in a project
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyDefaultReviewersGet(projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDefaultReviewerAndType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyDefaultReviewersGet(projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyDefaultReviewersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a default reviewer from the project.  Example: ``` $ curl https://api.bitbucket.org/2.0/.../default-reviewers/%7Bf0e0e8e9-66c1-4b85-a784-44a9eb9ef1a6%7D  HTTP/1.1 204 ```
         * @summary Remove the specific user from the project\'s default reviewers
         * @param {string} projectKey The project in question. This can either be the actual &#x60;key&#x60; assigned to the project or the &#x60;UUID&#x60; (surrounded by curly-braces (&#x60;{}&#x60;)). 
         * @param {string} selectedUser This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDelete(projectKey: string, selectedUser: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDelete(projectKey, selectedUser, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specified default reviewer.
         * @summary Get a default reviewer
         * @param {string} projectKey The project in question. This can either be the actual &#x60;key&#x60; assigned to the project or the &#x60;UUID&#x60; (surrounded by curly-braces (&#x60;{}&#x60;)). 
         * @param {string} selectedUser This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGet(projectKey: string, selectedUser: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGet(projectKey, selectedUser, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds the specified user to the project\'s list of default reviewers. The method is idempotent. Accepts an optional body containing the `uuid` of the user to be added.
         * @summary Add the specific user as a default reviewer for the project
         * @param {string} projectKey The project in question. This can either be the actual &#x60;key&#x60; assigned to the project or the &#x60;UUID&#x60; (surrounded by curly-braces (&#x60;{}&#x60;)). 
         * @param {string} selectedUser This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPut(projectKey: string, selectedUser: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPut(projectKey, selectedUser, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes this project. This is an irreversible operation.  You cannot delete a project that still contains repositories. To delete the project, [delete](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-repo-slug-delete) or transfer the repositories first.  Example: ``` $ curl -X DELETE https://api.bitbucket.org/2.0/workspaces/bbworkspace1/projects/PROJ ```
         * @summary Delete a project for a workspace
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyDelete(projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyDelete(projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the requested project.
         * @summary Get a project for a workspace
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyGet(projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyGet(projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of explicit group permissions for the given project. This endpoint does not support BBQL features.
         * @summary List explicit group permissions for a project
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGet(projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProjectGroupPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGet(projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the project group permission between the requested project and group, if one exists.  Only users with admin permission for the project may access this resource.
         * @summary Delete an explicit group permission for a project
         * @param {string} groupSlug Slug of the requested group.
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDelete(groupSlug: string, projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDelete(groupSlug, projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the group permission for a given group and project.  Only users with admin permission for the project may access this resource.  Permissions can be:  * `admin` * `create-repo` * `write` * `read` * `none`
         * @summary Get an explicit group permission for a project
         * @param {string} groupSlug Slug of the requested group.
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGet(groupSlug: string, projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectGroupPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGet(groupSlug, projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the group permission, or grants a new permission if one does not already exist.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.  Permissions can be:  * `admin` * `create-repo` * `write` * `read`
         * @summary Update an explicit group permission for a project
         * @param {string} groupSlug Slug of the requested group.
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema} body The permission to grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPut(groupSlug: string, projectKey: string, workspace: string, body: BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectGroupPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPut(groupSlug, projectKey, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of explicit user permissions for the given project. This endpoint does not support BBQL features.
         * @summary List explicit user permissions for a project
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGet(projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProjectUserPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGet(projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the project user permission between the requested project and user, if one exists.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.
         * @summary Delete an explicit user permission for a project
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} selectedUserId This can either be the username, the user\&#39;s UUID surrounded by curly-braces, for example: {account UUID}, or the user\&#39;s Atlassian ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDelete(projectKey: string, selectedUserId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDelete(projectKey, selectedUserId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the explicit user permission for a given user and project.  Only users with admin permission for the project may access this resource.  Permissions can be:  * `admin` * `create-repo` * `write` * `read` * `none`
         * @summary Get an explicit user permission for a project
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} selectedUserId This can either be the username, the user\&#39;s UUID surrounded by curly-braces, for example: {account UUID}, or the user\&#39;s Atlassian ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGet(projectKey: string, selectedUserId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectUserPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGet(projectKey, selectedUserId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the explicit user permission for a given user and project. The selected user must be a member of the workspace, and cannot be the workspace owner.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.  Permissions can be:  * `admin` * `create-repo` * `write` * `read`
         * @summary Update an explicit user permission for a project
         * @param {string} projectKey The project in question. This is the actual key assigned to the project. 
         * @param {string} selectedUserId This can either be the username, the user\&#39;s UUID surrounded by curly-braces, for example: {account UUID}, or the user\&#39;s Atlassian ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema} body The permission to grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPut(projectKey: string, selectedUserId: string, workspace: string, body: BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectUserPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPut(projectKey, selectedUserId, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Since this endpoint can be used to both update and to create a project, the request body depends on the intent.  #### Creation  See the POST documentation for the project collection for an example of the request body.  Note: The `key` should not be specified in the body of request (since it is already present in the URL). The `name` is required, everything else is optional.  #### Update  See the POST documentation for the project collection for an example of the request body.  Note: The key is not required in the body (since it is already in the URL). The key may be specified in the body, if the intent is to change the key itself. In such a scenario, the location of the project is changed and is returned in the `Location` header of the response.
         * @summary Update a project for a workspace
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Project} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyPut(projectKey: string, workspace: string, body: Project, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyPut(projectKey, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.workspacesWorkspaceProjectsProjectKeyPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Creates a new project.  Note that the avatar has to be embedded as either a data-url or a URL to an external image as shown in the examples below:  ``` $ body=$(cat << EOF {     \"name\": \"Mars Project\",     \"key\": \"MARS\",     \"description\": \"Software for colonizing mars.\",     \"links\": {         \"avatar\": {             \"href\": \"data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/...\"         }     },     \"is_private\": false } EOF ) $ curl -H \"Content-Type: application/json\" \\        -X POST \\        -d \"$body\" \\        https://api.bitbucket.org/2.0/workspaces/teams-in-space/projects/ | jq . {   // Serialized project document } ```  or even:  ``` $ body=$(cat << EOF {     \"name\": \"Mars Project\",     \"key\": \"MARS\",     \"description\": \"Software for colonizing mars.\",     \"links\": {         \"avatar\": {             \"href\": \"http://i.imgur.com/72tRx4w.gif\"         }     },     \"is_private\": false } EOF ) $ curl -H \"Content-Type: application/json\" \\        -X POST \\        -d \"$body\" \\        https://api.bitbucket.org/2.0/workspaces/teams-in-space/projects/ | jq . {   // Serialized project document } ```
         * @summary Create a project in a workspace
         * @param {ProjectsApiWorkspacesWorkspaceProjectsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsPost(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.workspacesWorkspaceProjectsPost(requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of all default reviewers for a project. This is a list of users that will be added as default reviewers to pull requests for any repository within the project.
         * @summary List the default reviewers in a project
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDefaultReviewersGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDefaultReviewerAndType> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyDefaultReviewersGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a default reviewer from the project.  Example: ``` $ curl https://api.bitbucket.org/2.0/.../default-reviewers/%7Bf0e0e8e9-66c1-4b85-a784-44a9eb9ef1a6%7D  HTTP/1.1 204 ```
         * @summary Remove the specific user from the project\'s default reviewers
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDelete(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDelete(requestParameters.projectKey, requestParameters.selectedUser, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified default reviewer.
         * @summary Get a default reviewer
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGet(requestParameters.projectKey, requestParameters.selectedUser, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds the specified user to the project\'s list of default reviewers. The method is idempotent. Accepts an optional body containing the `uuid` of the user to be added.
         * @summary Add the specific user as a default reviewer for the project
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPut(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPut(requestParameters.projectKey, requestParameters.selectedUser, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes this project. This is an irreversible operation.  You cannot delete a project that still contains repositories. To delete the project, [delete](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-repo-slug-delete) or transfer the repositories first.  Example: ``` $ curl -X DELETE https://api.bitbucket.org/2.0/workspaces/bbworkspace1/projects/PROJ ```
         * @summary Delete a project for a workspace
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyDelete(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyDelete(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the requested project.
         * @summary Get a project for a workspace
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of explicit group permissions for the given project. This endpoint does not support BBQL features.
         * @summary List explicit group permissions for a project
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProjectGroupPermissions> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the project group permission between the requested project and group, if one exists.  Only users with admin permission for the project may access this resource.
         * @summary Delete an explicit group permission for a project
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDelete(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDelete(requestParameters.groupSlug, requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the group permission for a given group and project.  Only users with admin permission for the project may access this resource.  Permissions can be:  * `admin` * `create-repo` * `write` * `read` * `none`
         * @summary Get an explicit group permission for a project
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectGroupPermission> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGet(requestParameters.groupSlug, requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the group permission, or grants a new permission if one does not already exist.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.  Permissions can be:  * `admin` * `create-repo` * `write` * `read`
         * @summary Update an explicit group permission for a project
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPut(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectGroupPermission> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPut(requestParameters.groupSlug, requestParameters.projectKey, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of explicit user permissions for the given project. This endpoint does not support BBQL features.
         * @summary List explicit user permissions for a project
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProjectUserPermissions> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the project user permission between the requested project and user, if one exists.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.
         * @summary Delete an explicit user permission for a project
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDelete(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDelete(requestParameters.projectKey, requestParameters.selectedUserId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the explicit user permission for a given user and project.  Only users with admin permission for the project may access this resource.  Permissions can be:  * `admin` * `create-repo` * `write` * `read` * `none`
         * @summary Get an explicit user permission for a project
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectUserPermission> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGet(requestParameters.projectKey, requestParameters.selectedUserId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the explicit user permission for a given user and project. The selected user must be a member of the workspace, and cannot be the workspace owner.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.  Permissions can be:  * `admin` * `create-repo` * `write` * `read`
         * @summary Update an explicit user permission for a project
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPut(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectUserPermission> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPut(requestParameters.projectKey, requestParameters.selectedUserId, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Since this endpoint can be used to both update and to create a project, the request body depends on the intent.  #### Creation  See the POST documentation for the project collection for an example of the request body.  Note: The `key` should not be specified in the body of request (since it is already present in the URL). The `name` is required, everything else is optional.  #### Update  See the POST documentation for the project collection for an example of the request body.  Note: The key is not required in the body (since it is already in the URL). The key may be specified in the body, if the intent is to change the key itself. In such a scenario, the location of the project is changed and is returned in the `Location` header of the response.
         * @summary Update a project for a workspace
         * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyPut(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyPut(requestParameters.projectKey, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - interface
 */
export interface ProjectsApiInterface {
    /**
     * Creates a new project.  Note that the avatar has to be embedded as either a data-url or a URL to an external image as shown in the examples below:  ``` $ body=$(cat << EOF {     \"name\": \"Mars Project\",     \"key\": \"MARS\",     \"description\": \"Software for colonizing mars.\",     \"links\": {         \"avatar\": {             \"href\": \"data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/...\"         }     },     \"is_private\": false } EOF ) $ curl -H \"Content-Type: application/json\" \\        -X POST \\        -d \"$body\" \\        https://api.bitbucket.org/2.0/workspaces/teams-in-space/projects/ | jq . {   // Serialized project document } ```  or even:  ``` $ body=$(cat << EOF {     \"name\": \"Mars Project\",     \"key\": \"MARS\",     \"description\": \"Software for colonizing mars.\",     \"links\": {         \"avatar\": {             \"href\": \"http://i.imgur.com/72tRx4w.gif\"         }     },     \"is_private\": false } EOF ) $ curl -H \"Content-Type: application/json\" \\        -X POST \\        -d \"$body\" \\        https://api.bitbucket.org/2.0/workspaces/teams-in-space/projects/ | jq . {   // Serialized project document } ```
     * @summary Create a project in a workspace
     * @param {ProjectsApiWorkspacesWorkspaceProjectsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsPost(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Project>;

    /**
     * Return a list of all default reviewers for a project. This is a list of users that will be added as default reviewers to pull requests for any repository within the project.
     * @summary List the default reviewers in a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyDefaultReviewersGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDefaultReviewerAndType>;

    /**
     * Removes a default reviewer from the project.  Example: ``` $ curl https://api.bitbucket.org/2.0/.../default-reviewers/%7Bf0e0e8e9-66c1-4b85-a784-44a9eb9ef1a6%7D  HTTP/1.1 204 ```
     * @summary Remove the specific user from the project\'s default reviewers
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDelete(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the specified default reviewer.
     * @summary Get a default reviewer
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<User>;

    /**
     * Adds the specified user to the project\'s list of default reviewers. The method is idempotent. Accepts an optional body containing the `uuid` of the user to be added.
     * @summary Add the specific user as a default reviewer for the project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPut(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<User>;

    /**
     * Deletes this project. This is an irreversible operation.  You cannot delete a project that still contains repositories. To delete the project, [delete](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-repo-slug-delete) or transfer the repositories first.  Example: ``` $ curl -X DELETE https://api.bitbucket.org/2.0/workspaces/bbworkspace1/projects/PROJ ```
     * @summary Delete a project for a workspace
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyDelete(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the requested project.
     * @summary Get a project for a workspace
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Project>;

    /**
     * Returns a paginated list of explicit group permissions for the given project. This endpoint does not support BBQL features.
     * @summary List explicit group permissions for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProjectGroupPermissions>;

    /**
     * Deletes the project group permission between the requested project and group, if one exists.  Only users with admin permission for the project may access this resource.
     * @summary Delete an explicit group permission for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDelete(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the group permission for a given group and project.  Only users with admin permission for the project may access this resource.  Permissions can be:  * `admin` * `create-repo` * `write` * `read` * `none`
     * @summary Get an explicit group permission for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectGroupPermission>;

    /**
     * Updates the group permission, or grants a new permission if one does not already exist.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.  Permissions can be:  * `admin` * `create-repo` * `write` * `read`
     * @summary Update an explicit group permission for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPut(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectGroupPermission>;

    /**
     * Returns a paginated list of explicit user permissions for the given project. This endpoint does not support BBQL features.
     * @summary List explicit user permissions for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProjectUserPermissions>;

    /**
     * Deletes the project user permission between the requested project and user, if one exists.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.
     * @summary Delete an explicit user permission for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDelete(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the explicit user permission for a given user and project.  Only users with admin permission for the project may access this resource.  Permissions can be:  * `admin` * `create-repo` * `write` * `read` * `none`
     * @summary Get an explicit user permission for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectUserPermission>;

    /**
     * Updates the explicit user permission for a given user and project. The selected user must be a member of the workspace, and cannot be the workspace owner.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.  Permissions can be:  * `admin` * `create-repo` * `write` * `read`
     * @summary Update an explicit user permission for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPut(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectUserPermission>;

    /**
     * Since this endpoint can be used to both update and to create a project, the request body depends on the intent.  #### Creation  See the POST documentation for the project collection for an example of the request body.  Note: The `key` should not be specified in the body of request (since it is already present in the URL). The `name` is required, everything else is optional.  #### Update  See the POST documentation for the project collection for an example of the request body.  Note: The key is not required in the body (since it is already in the URL). The key may be specified in the body, if the intent is to change the key itself. In such a scenario, the location of the project is changed and is returned in the `Location` header of the response.
     * @summary Update a project for a workspace
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyPut(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Project>;

}

/**
 * Request parameters for workspacesWorkspaceProjectsPost operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsPostRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    readonly body: Project
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyDefaultReviewersGet operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersGetRequest {
    /**
     * The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDelete operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDeleteRequest {
    /**
     * The project in question. This can either be the actual &#x60;key&#x60; assigned to the project or the &#x60;UUID&#x60; (surrounded by curly-braces (&#x60;{}&#x60;)). 
     */
    readonly projectKey: string

    /**
     * This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly selectedUser: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGet operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGetRequest {
    /**
     * The project in question. This can either be the actual &#x60;key&#x60; assigned to the project or the &#x60;UUID&#x60; (surrounded by curly-braces (&#x60;{}&#x60;)). 
     */
    readonly projectKey: string

    /**
     * This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly selectedUser: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPut operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPutRequest {
    /**
     * The project in question. This can either be the actual &#x60;key&#x60; assigned to the project or the &#x60;UUID&#x60; (surrounded by curly-braces (&#x60;{}&#x60;)). 
     */
    readonly projectKey: string

    /**
     * This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly selectedUser: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyDelete operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDeleteRequest {
    /**
     * The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyGet operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyGetRequest {
    /**
     * The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGet operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGetRequest {
    /**
     * The project in question. This is the actual key assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDelete operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDeleteRequest {
    /**
     * Slug of the requested group.
     */
    readonly groupSlug: string

    /**
     * The project in question. This is the actual key assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGet operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGetRequest {
    /**
     * Slug of the requested group.
     */
    readonly groupSlug: string

    /**
     * The project in question. This is the actual key assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPut operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPutRequest {
    /**
     * Slug of the requested group.
     */
    readonly groupSlug: string

    /**
     * The project in question. This is the actual key assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The permission to grant
     */
    readonly body: BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGet operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGetRequest {
    /**
     * The project in question. This is the actual key assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDelete operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDeleteRequest {
    /**
     * The project in question. This is the actual key assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the username, the user\&#39;s UUID surrounded by curly-braces, for example: {account UUID}, or the user\&#39;s Atlassian ID. 
     */
    readonly selectedUserId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGet operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGetRequest {
    /**
     * The project in question. This is the actual key assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the username, the user\&#39;s UUID surrounded by curly-braces, for example: {account UUID}, or the user\&#39;s Atlassian ID. 
     */
    readonly selectedUserId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPut operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPutRequest {
    /**
     * The project in question. This is the actual key assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the username, the user\&#39;s UUID surrounded by curly-braces, for example: {account UUID}, or the user\&#39;s Atlassian ID. 
     */
    readonly selectedUserId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The permission to grant
     */
    readonly body: BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyPut operation in ProjectsApi.
 */
export interface ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPutRequest {
    /**
     * The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    readonly body: Project
}

/**
 * ProjectsApi - object-oriented interface
 */
export class ProjectsApi extends BaseAPI implements ProjectsApiInterface {
    /**
     * Creates a new project.  Note that the avatar has to be embedded as either a data-url or a URL to an external image as shown in the examples below:  ``` $ body=$(cat << EOF {     \"name\": \"Mars Project\",     \"key\": \"MARS\",     \"description\": \"Software for colonizing mars.\",     \"links\": {         \"avatar\": {             \"href\": \"data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/...\"         }     },     \"is_private\": false } EOF ) $ curl -H \"Content-Type: application/json\" \\        -X POST \\        -d \"$body\" \\        https://api.bitbucket.org/2.0/workspaces/teams-in-space/projects/ | jq . {   // Serialized project document } ```  or even:  ``` $ body=$(cat << EOF {     \"name\": \"Mars Project\",     \"key\": \"MARS\",     \"description\": \"Software for colonizing mars.\",     \"links\": {         \"avatar\": {             \"href\": \"http://i.imgur.com/72tRx4w.gif\"         }     },     \"is_private\": false } EOF ) $ curl -H \"Content-Type: application/json\" \\        -X POST \\        -d \"$body\" \\        https://api.bitbucket.org/2.0/workspaces/teams-in-space/projects/ | jq . {   // Serialized project document } ```
     * @summary Create a project in a workspace
     * @param {ProjectsApiWorkspacesWorkspaceProjectsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsPost(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsPostRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsPost(requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of all default reviewers for a project. This is a list of users that will be added as default reviewers to pull requests for any repository within the project.
     * @summary List the default reviewers in a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyDefaultReviewersGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersGetRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyDefaultReviewersGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a default reviewer from the project.  Example: ``` $ curl https://api.bitbucket.org/2.0/.../default-reviewers/%7Bf0e0e8e9-66c1-4b85-a784-44a9eb9ef1a6%7D  HTTP/1.1 204 ```
     * @summary Remove the specific user from the project\'s default reviewers
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDelete(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDeleteRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDelete(requestParameters.projectKey, requestParameters.selectedUser, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified default reviewer.
     * @summary Get a default reviewer
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGetRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGet(requestParameters.projectKey, requestParameters.selectedUser, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds the specified user to the project\'s list of default reviewers. The method is idempotent. Accepts an optional body containing the `uuid` of the user to be added.
     * @summary Add the specific user as a default reviewer for the project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPut(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPutRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPut(requestParameters.projectKey, requestParameters.selectedUser, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes this project. This is an irreversible operation.  You cannot delete a project that still contains repositories. To delete the project, [delete](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-repo-slug-delete) or transfer the repositories first.  Example: ``` $ curl -X DELETE https://api.bitbucket.org/2.0/workspaces/bbworkspace1/projects/PROJ ```
     * @summary Delete a project for a workspace
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyDelete(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyDeleteRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyDelete(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the requested project.
     * @summary Get a project for a workspace
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyGetRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of explicit group permissions for the given project. This endpoint does not support BBQL features.
     * @summary List explicit group permissions for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGetRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the project group permission between the requested project and group, if one exists.  Only users with admin permission for the project may access this resource.
     * @summary Delete an explicit group permission for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDelete(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDeleteRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDelete(requestParameters.groupSlug, requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the group permission for a given group and project.  Only users with admin permission for the project may access this resource.  Permissions can be:  * `admin` * `create-repo` * `write` * `read` * `none`
     * @summary Get an explicit group permission for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGetRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGet(requestParameters.groupSlug, requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the group permission, or grants a new permission if one does not already exist.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.  Permissions can be:  * `admin` * `create-repo` * `write` * `read`
     * @summary Update an explicit group permission for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPut(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPutRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPut(requestParameters.groupSlug, requestParameters.projectKey, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of explicit user permissions for the given project. This endpoint does not support BBQL features.
     * @summary List explicit user permissions for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGetRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the project user permission between the requested project and user, if one exists.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.
     * @summary Delete an explicit user permission for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDelete(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDelete(requestParameters.projectKey, requestParameters.selectedUserId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the explicit user permission for a given user and project.  Only users with admin permission for the project may access this resource.  Permissions can be:  * `admin` * `create-repo` * `write` * `read` * `none`
     * @summary Get an explicit user permission for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGet(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGetRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGet(requestParameters.projectKey, requestParameters.selectedUserId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the explicit user permission for a given user and project. The selected user must be a member of the workspace, and cannot be the workspace owner.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.  Permissions can be:  * `admin` * `create-repo` * `write` * `read`
     * @summary Update an explicit user permission for a project
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPut(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPutRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPut(requestParameters.projectKey, requestParameters.selectedUserId, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since this endpoint can be used to both update and to create a project, the request body depends on the intent.  #### Creation  See the POST documentation for the project collection for an example of the request body.  Note: The `key` should not be specified in the body of request (since it is already present in the URL). The `name` is required, everything else is optional.  #### Update  See the POST documentation for the project collection for an example of the request body.  Note: The key is not required in the body (since it is already in the URL). The key may be specified in the body, if the intent is to change the key itself. In such a scenario, the location of the project is changed and is returned in the `Location` header of the response.
     * @summary Update a project for a workspace
     * @param {ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyPut(requestParameters: ProjectsApiWorkspacesWorkspaceProjectsProjectKeyPutRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyPut(requestParameters.projectKey, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertiesApi - axios parameter creator
 */
export const PropertiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
         * @summary Delete a commit application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommitHostedPropertyValue: async (workspace: string, repoSlug: string, commit: string, appKey: string, propertyName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteCommitHostedPropertyValue', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deleteCommitHostedPropertyValue', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('deleteCommitHostedPropertyValue', 'commit', commit)
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('deleteCommitHostedPropertyValue', 'appKey', appKey)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('deleteCommitHostedPropertyValue', 'propertyName', propertyName)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/properties/{app_key}/{property_name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"app_key"}}`, encodeURIComponent(String(appKey)))
                .replace(`{${"property_name"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
         * @summary Delete a pull request application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} pullrequestId The pull request ID.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePullRequestHostedPropertyValue: async (workspace: string, repoSlug: string, pullrequestId: string, appKey: string, propertyName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deletePullRequestHostedPropertyValue', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deletePullRequestHostedPropertyValue', 'repoSlug', repoSlug)
            // verify required parameter 'pullrequestId' is not null or undefined
            assertParamExists('deletePullRequestHostedPropertyValue', 'pullrequestId', pullrequestId)
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('deletePullRequestHostedPropertyValue', 'appKey', appKey)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('deletePullRequestHostedPropertyValue', 'propertyName', propertyName)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pullrequest_id}/properties/{app_key}/{property_name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"pullrequest_id"}}`, encodeURIComponent(String(pullrequestId)))
                .replace(`{${"app_key"}}`, encodeURIComponent(String(appKey)))
                .replace(`{${"property_name"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
         * @summary Delete a repository application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryHostedPropertyValue: async (workspace: string, repoSlug: string, appKey: string, propertyName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteRepositoryHostedPropertyValue', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deleteRepositoryHostedPropertyValue', 'repoSlug', repoSlug)
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('deleteRepositoryHostedPropertyValue', 'appKey', appKey)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('deleteRepositoryHostedPropertyValue', 'propertyName', propertyName)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/properties/{app_key}/{property_name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"app_key"}}`, encodeURIComponent(String(appKey)))
                .replace(`{${"property_name"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
         * @summary Delete a user application property
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserHostedPropertyValue: async (selectedUser: string, appKey: string, propertyName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('deleteUserHostedPropertyValue', 'selectedUser', selectedUser)
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('deleteUserHostedPropertyValue', 'appKey', appKey)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('deleteUserHostedPropertyValue', 'propertyName', propertyName)
            const localVarPath = `/users/{selected_user}/properties/{app_key}/{property_name}`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)))
                .replace(`{${"app_key"}}`, encodeURIComponent(String(appKey)))
                .replace(`{${"property_name"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
         * @summary Get a commit application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitHostedPropertyValue: async (workspace: string, repoSlug: string, commit: string, appKey: string, propertyName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getCommitHostedPropertyValue', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getCommitHostedPropertyValue', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('getCommitHostedPropertyValue', 'commit', commit)
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('getCommitHostedPropertyValue', 'appKey', appKey)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('getCommitHostedPropertyValue', 'propertyName', propertyName)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/properties/{app_key}/{property_name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"app_key"}}`, encodeURIComponent(String(appKey)))
                .replace(`{${"property_name"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
         * @summary Get a pull request application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} pullrequestId The pull request ID.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullRequestHostedPropertyValue: async (workspace: string, repoSlug: string, pullrequestId: string, appKey: string, propertyName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getPullRequestHostedPropertyValue', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getPullRequestHostedPropertyValue', 'repoSlug', repoSlug)
            // verify required parameter 'pullrequestId' is not null or undefined
            assertParamExists('getPullRequestHostedPropertyValue', 'pullrequestId', pullrequestId)
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('getPullRequestHostedPropertyValue', 'appKey', appKey)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('getPullRequestHostedPropertyValue', 'propertyName', propertyName)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pullrequest_id}/properties/{app_key}/{property_name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"pullrequest_id"}}`, encodeURIComponent(String(pullrequestId)))
                .replace(`{${"app_key"}}`, encodeURIComponent(String(appKey)))
                .replace(`{${"property_name"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
         * @summary Get a repository application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryHostedPropertyValue: async (workspace: string, repoSlug: string, appKey: string, propertyName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getRepositoryHostedPropertyValue', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getRepositoryHostedPropertyValue', 'repoSlug', repoSlug)
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('getRepositoryHostedPropertyValue', 'appKey', appKey)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('getRepositoryHostedPropertyValue', 'propertyName', propertyName)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/properties/{app_key}/{property_name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"app_key"}}`, encodeURIComponent(String(appKey)))
                .replace(`{${"property_name"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
         * @summary Get a user application property
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserHostedPropertyValue: async (selectedUser: string, appKey: string, propertyName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('retrieveUserHostedPropertyValue', 'selectedUser', selectedUser)
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('retrieveUserHostedPropertyValue', 'appKey', appKey)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('retrieveUserHostedPropertyValue', 'propertyName', propertyName)
            const localVarPath = `/users/{selected_user}/properties/{app_key}/{property_name}`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)))
                .replace(`{${"app_key"}}`, encodeURIComponent(String(appKey)))
                .replace(`{${"property_name"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
         * @summary Update a commit application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {ApplicationProperty} body The application property to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCommitHostedPropertyValue: async (workspace: string, repoSlug: string, commit: string, appKey: string, propertyName: string, body: ApplicationProperty, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateCommitHostedPropertyValue', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('updateCommitHostedPropertyValue', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('updateCommitHostedPropertyValue', 'commit', commit)
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('updateCommitHostedPropertyValue', 'appKey', appKey)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('updateCommitHostedPropertyValue', 'propertyName', propertyName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateCommitHostedPropertyValue', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/properties/{app_key}/{property_name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"app_key"}}`, encodeURIComponent(String(appKey)))
                .replace(`{${"property_name"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
         * @summary Update a pull request application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} pullrequestId The pull request ID.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {ApplicationProperty} body The application property to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePullRequestHostedPropertyValue: async (workspace: string, repoSlug: string, pullrequestId: string, appKey: string, propertyName: string, body: ApplicationProperty, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updatePullRequestHostedPropertyValue', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('updatePullRequestHostedPropertyValue', 'repoSlug', repoSlug)
            // verify required parameter 'pullrequestId' is not null or undefined
            assertParamExists('updatePullRequestHostedPropertyValue', 'pullrequestId', pullrequestId)
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('updatePullRequestHostedPropertyValue', 'appKey', appKey)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('updatePullRequestHostedPropertyValue', 'propertyName', propertyName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updatePullRequestHostedPropertyValue', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pullrequest_id}/properties/{app_key}/{property_name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"pullrequest_id"}}`, encodeURIComponent(String(pullrequestId)))
                .replace(`{${"app_key"}}`, encodeURIComponent(String(appKey)))
                .replace(`{${"property_name"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
         * @summary Update a repository application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {ApplicationProperty} body The application property to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepositoryHostedPropertyValue: async (workspace: string, repoSlug: string, appKey: string, propertyName: string, body: ApplicationProperty, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateRepositoryHostedPropertyValue', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('updateRepositoryHostedPropertyValue', 'repoSlug', repoSlug)
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('updateRepositoryHostedPropertyValue', 'appKey', appKey)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('updateRepositoryHostedPropertyValue', 'propertyName', propertyName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateRepositoryHostedPropertyValue', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/properties/{app_key}/{property_name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"app_key"}}`, encodeURIComponent(String(appKey)))
                .replace(`{${"property_name"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
         * @summary Update a user application property
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {ApplicationProperty} body The application property to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserHostedPropertyValue: async (selectedUser: string, appKey: string, propertyName: string, body: ApplicationProperty, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('updateUserHostedPropertyValue', 'selectedUser', selectedUser)
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('updateUserHostedPropertyValue', 'appKey', appKey)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('updateUserHostedPropertyValue', 'propertyName', propertyName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateUserHostedPropertyValue', 'body', body)
            const localVarPath = `/users/{selected_user}/properties/{app_key}/{property_name}`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)))
                .replace(`{${"app_key"}}`, encodeURIComponent(String(appKey)))
                .replace(`{${"property_name"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertiesApi - functional programming interface
 */
export const PropertiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
         * @summary Delete a commit application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCommitHostedPropertyValue(workspace: string, repoSlug: string, commit: string, appKey: string, propertyName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCommitHostedPropertyValue(workspace, repoSlug, commit, appKey, propertyName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.deleteCommitHostedPropertyValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
         * @summary Delete a pull request application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} pullrequestId The pull request ID.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePullRequestHostedPropertyValue(workspace: string, repoSlug: string, pullrequestId: string, appKey: string, propertyName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePullRequestHostedPropertyValue(workspace, repoSlug, pullrequestId, appKey, propertyName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.deletePullRequestHostedPropertyValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
         * @summary Delete a repository application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepositoryHostedPropertyValue(workspace: string, repoSlug: string, appKey: string, propertyName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepositoryHostedPropertyValue(workspace, repoSlug, appKey, propertyName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.deleteRepositoryHostedPropertyValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
         * @summary Delete a user application property
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserHostedPropertyValue(selectedUser: string, appKey: string, propertyName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserHostedPropertyValue(selectedUser, appKey, propertyName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.deleteUserHostedPropertyValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
         * @summary Get a commit application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommitHostedPropertyValue(workspace: string, repoSlug: string, commit: string, appKey: string, propertyName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationProperty>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommitHostedPropertyValue(workspace, repoSlug, commit, appKey, propertyName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.getCommitHostedPropertyValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
         * @summary Get a pull request application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} pullrequestId The pull request ID.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPullRequestHostedPropertyValue(workspace: string, repoSlug: string, pullrequestId: string, appKey: string, propertyName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationProperty>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPullRequestHostedPropertyValue(workspace, repoSlug, pullrequestId, appKey, propertyName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.getPullRequestHostedPropertyValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
         * @summary Get a repository application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryHostedPropertyValue(workspace: string, repoSlug: string, appKey: string, propertyName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationProperty>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryHostedPropertyValue(workspace, repoSlug, appKey, propertyName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.getRepositoryHostedPropertyValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
         * @summary Get a user application property
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserHostedPropertyValue(selectedUser: string, appKey: string, propertyName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationProperty>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserHostedPropertyValue(selectedUser, appKey, propertyName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.retrieveUserHostedPropertyValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
         * @summary Update a commit application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {ApplicationProperty} body The application property to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCommitHostedPropertyValue(workspace: string, repoSlug: string, commit: string, appKey: string, propertyName: string, body: ApplicationProperty, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCommitHostedPropertyValue(workspace, repoSlug, commit, appKey, propertyName, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.updateCommitHostedPropertyValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
         * @summary Update a pull request application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} pullrequestId The pull request ID.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {ApplicationProperty} body The application property to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePullRequestHostedPropertyValue(workspace: string, repoSlug: string, pullrequestId: string, appKey: string, propertyName: string, body: ApplicationProperty, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePullRequestHostedPropertyValue(workspace, repoSlug, pullrequestId, appKey, propertyName, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.updatePullRequestHostedPropertyValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
         * @summary Update a repository application property
         * @param {string} workspace The repository container; either the workspace slug or the UUID in curly braces.
         * @param {string} repoSlug The repository.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {ApplicationProperty} body The application property to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepositoryHostedPropertyValue(workspace: string, repoSlug: string, appKey: string, propertyName: string, body: ApplicationProperty, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepositoryHostedPropertyValue(workspace, repoSlug, appKey, propertyName, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.updateRepositoryHostedPropertyValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
         * @summary Update a user application property
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {string} appKey The key of the Connect app.
         * @param {string} propertyName The name of the property.
         * @param {ApplicationProperty} body The application property to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserHostedPropertyValue(selectedUser: string, appKey: string, propertyName: string, body: ApplicationProperty, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserHostedPropertyValue(selectedUser, appKey, propertyName, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.updateUserHostedPropertyValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertiesApi - factory interface
 */
export const PropertiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertiesApiFp(configuration)
    return {
        /**
         * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
         * @summary Delete a commit application property
         * @param {PropertiesApiDeleteCommitHostedPropertyValueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommitHostedPropertyValue(requestParameters: PropertiesApiDeleteCommitHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCommitHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
         * @summary Delete a pull request application property
         * @param {PropertiesApiDeletePullRequestHostedPropertyValueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePullRequestHostedPropertyValue(requestParameters: PropertiesApiDeletePullRequestHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePullRequestHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pullrequestId, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
         * @summary Delete a repository application property
         * @param {PropertiesApiDeleteRepositoryHostedPropertyValueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryHostedPropertyValue(requestParameters: PropertiesApiDeleteRepositoryHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRepositoryHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
         * @summary Delete a user application property
         * @param {PropertiesApiDeleteUserHostedPropertyValueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserHostedPropertyValue(requestParameters: PropertiesApiDeleteUserHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserHostedPropertyValue(requestParameters.selectedUser, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
         * @summary Get a commit application property
         * @param {PropertiesApiGetCommitHostedPropertyValueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitHostedPropertyValue(requestParameters: PropertiesApiGetCommitHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationProperty> {
            return localVarFp.getCommitHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
         * @summary Get a pull request application property
         * @param {PropertiesApiGetPullRequestHostedPropertyValueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullRequestHostedPropertyValue(requestParameters: PropertiesApiGetPullRequestHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationProperty> {
            return localVarFp.getPullRequestHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pullrequestId, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
         * @summary Get a repository application property
         * @param {PropertiesApiGetRepositoryHostedPropertyValueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryHostedPropertyValue(requestParameters: PropertiesApiGetRepositoryHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationProperty> {
            return localVarFp.getRepositoryHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
         * @summary Get a user application property
         * @param {PropertiesApiRetrieveUserHostedPropertyValueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserHostedPropertyValue(requestParameters: PropertiesApiRetrieveUserHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationProperty> {
            return localVarFp.retrieveUserHostedPropertyValue(requestParameters.selectedUser, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
         * @summary Update a commit application property
         * @param {PropertiesApiUpdateCommitHostedPropertyValueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCommitHostedPropertyValue(requestParameters: PropertiesApiUpdateCommitHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCommitHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.appKey, requestParameters.propertyName, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
         * @summary Update a pull request application property
         * @param {PropertiesApiUpdatePullRequestHostedPropertyValueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePullRequestHostedPropertyValue(requestParameters: PropertiesApiUpdatePullRequestHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updatePullRequestHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pullrequestId, requestParameters.appKey, requestParameters.propertyName, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
         * @summary Update a repository application property
         * @param {PropertiesApiUpdateRepositoryHostedPropertyValueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepositoryHostedPropertyValue(requestParameters: PropertiesApiUpdateRepositoryHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateRepositoryHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.appKey, requestParameters.propertyName, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
         * @summary Update a user application property
         * @param {PropertiesApiUpdateUserHostedPropertyValueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserHostedPropertyValue(requestParameters: PropertiesApiUpdateUserHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUserHostedPropertyValue(requestParameters.selectedUser, requestParameters.appKey, requestParameters.propertyName, requestParameters.body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertiesApi - interface
 */
export interface PropertiesApiInterface {
    /**
     * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
     * @summary Delete a commit application property
     * @param {PropertiesApiDeleteCommitHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCommitHostedPropertyValue(requestParameters: PropertiesApiDeleteCommitHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
     * @summary Delete a pull request application property
     * @param {PropertiesApiDeletePullRequestHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePullRequestHostedPropertyValue(requestParameters: PropertiesApiDeletePullRequestHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
     * @summary Delete a repository application property
     * @param {PropertiesApiDeleteRepositoryHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRepositoryHostedPropertyValue(requestParameters: PropertiesApiDeleteRepositoryHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
     * @summary Delete a user application property
     * @param {PropertiesApiDeleteUserHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserHostedPropertyValue(requestParameters: PropertiesApiDeleteUserHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
     * @summary Get a commit application property
     * @param {PropertiesApiGetCommitHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommitHostedPropertyValue(requestParameters: PropertiesApiGetCommitHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationProperty>;

    /**
     * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
     * @summary Get a pull request application property
     * @param {PropertiesApiGetPullRequestHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPullRequestHostedPropertyValue(requestParameters: PropertiesApiGetPullRequestHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationProperty>;

    /**
     * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
     * @summary Get a repository application property
     * @param {PropertiesApiGetRepositoryHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositoryHostedPropertyValue(requestParameters: PropertiesApiGetRepositoryHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationProperty>;

    /**
     * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
     * @summary Get a user application property
     * @param {PropertiesApiRetrieveUserHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveUserHostedPropertyValue(requestParameters: PropertiesApiRetrieveUserHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationProperty>;

    /**
     * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
     * @summary Update a commit application property
     * @param {PropertiesApiUpdateCommitHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCommitHostedPropertyValue(requestParameters: PropertiesApiUpdateCommitHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
     * @summary Update a pull request application property
     * @param {PropertiesApiUpdatePullRequestHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePullRequestHostedPropertyValue(requestParameters: PropertiesApiUpdatePullRequestHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
     * @summary Update a repository application property
     * @param {PropertiesApiUpdateRepositoryHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepositoryHostedPropertyValue(requestParameters: PropertiesApiUpdateRepositoryHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
     * @summary Update a user application property
     * @param {PropertiesApiUpdateUserHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserHostedPropertyValue(requestParameters: PropertiesApiUpdateUserHostedPropertyValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for deleteCommitHostedPropertyValue operation in PropertiesApi.
 */
export interface PropertiesApiDeleteCommitHostedPropertyValueRequest {
    /**
     * The repository container; either the workspace slug or the UUID in curly braces.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit.
     */
    readonly commit: string

    /**
     * The key of the Connect app.
     */
    readonly appKey: string

    /**
     * The name of the property.
     */
    readonly propertyName: string
}

/**
 * Request parameters for deletePullRequestHostedPropertyValue operation in PropertiesApi.
 */
export interface PropertiesApiDeletePullRequestHostedPropertyValueRequest {
    /**
     * The repository container; either the workspace slug or the UUID in curly braces.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The pull request ID.
     */
    readonly pullrequestId: string

    /**
     * The key of the Connect app.
     */
    readonly appKey: string

    /**
     * The name of the property.
     */
    readonly propertyName: string
}

/**
 * Request parameters for deleteRepositoryHostedPropertyValue operation in PropertiesApi.
 */
export interface PropertiesApiDeleteRepositoryHostedPropertyValueRequest {
    /**
     * The repository container; either the workspace slug or the UUID in curly braces.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The key of the Connect app.
     */
    readonly appKey: string

    /**
     * The name of the property.
     */
    readonly propertyName: string
}

/**
 * Request parameters for deleteUserHostedPropertyValue operation in PropertiesApi.
 */
export interface PropertiesApiDeleteUserHostedPropertyValueRequest {
    /**
     * Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
     */
    readonly selectedUser: string

    /**
     * The key of the Connect app.
     */
    readonly appKey: string

    /**
     * The name of the property.
     */
    readonly propertyName: string
}

/**
 * Request parameters for getCommitHostedPropertyValue operation in PropertiesApi.
 */
export interface PropertiesApiGetCommitHostedPropertyValueRequest {
    /**
     * The repository container; either the workspace slug or the UUID in curly braces.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit.
     */
    readonly commit: string

    /**
     * The key of the Connect app.
     */
    readonly appKey: string

    /**
     * The name of the property.
     */
    readonly propertyName: string
}

/**
 * Request parameters for getPullRequestHostedPropertyValue operation in PropertiesApi.
 */
export interface PropertiesApiGetPullRequestHostedPropertyValueRequest {
    /**
     * The repository container; either the workspace slug or the UUID in curly braces.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The pull request ID.
     */
    readonly pullrequestId: string

    /**
     * The key of the Connect app.
     */
    readonly appKey: string

    /**
     * The name of the property.
     */
    readonly propertyName: string
}

/**
 * Request parameters for getRepositoryHostedPropertyValue operation in PropertiesApi.
 */
export interface PropertiesApiGetRepositoryHostedPropertyValueRequest {
    /**
     * The repository container; either the workspace slug or the UUID in curly braces.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The key of the Connect app.
     */
    readonly appKey: string

    /**
     * The name of the property.
     */
    readonly propertyName: string
}

/**
 * Request parameters for retrieveUserHostedPropertyValue operation in PropertiesApi.
 */
export interface PropertiesApiRetrieveUserHostedPropertyValueRequest {
    /**
     * Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
     */
    readonly selectedUser: string

    /**
     * The key of the Connect app.
     */
    readonly appKey: string

    /**
     * The name of the property.
     */
    readonly propertyName: string
}

/**
 * Request parameters for updateCommitHostedPropertyValue operation in PropertiesApi.
 */
export interface PropertiesApiUpdateCommitHostedPropertyValueRequest {
    /**
     * The repository container; either the workspace slug or the UUID in curly braces.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit.
     */
    readonly commit: string

    /**
     * The key of the Connect app.
     */
    readonly appKey: string

    /**
     * The name of the property.
     */
    readonly propertyName: string

    /**
     * The application property to create or update.
     */
    readonly body: ApplicationProperty
}

/**
 * Request parameters for updatePullRequestHostedPropertyValue operation in PropertiesApi.
 */
export interface PropertiesApiUpdatePullRequestHostedPropertyValueRequest {
    /**
     * The repository container; either the workspace slug or the UUID in curly braces.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The pull request ID.
     */
    readonly pullrequestId: string

    /**
     * The key of the Connect app.
     */
    readonly appKey: string

    /**
     * The name of the property.
     */
    readonly propertyName: string

    /**
     * The application property to create or update.
     */
    readonly body: ApplicationProperty
}

/**
 * Request parameters for updateRepositoryHostedPropertyValue operation in PropertiesApi.
 */
export interface PropertiesApiUpdateRepositoryHostedPropertyValueRequest {
    /**
     * The repository container; either the workspace slug or the UUID in curly braces.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The key of the Connect app.
     */
    readonly appKey: string

    /**
     * The name of the property.
     */
    readonly propertyName: string

    /**
     * The application property to create or update.
     */
    readonly body: ApplicationProperty
}

/**
 * Request parameters for updateUserHostedPropertyValue operation in PropertiesApi.
 */
export interface PropertiesApiUpdateUserHostedPropertyValueRequest {
    /**
     * Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
     */
    readonly selectedUser: string

    /**
     * The key of the Connect app.
     */
    readonly appKey: string

    /**
     * The name of the property.
     */
    readonly propertyName: string

    /**
     * The application property to create or update.
     */
    readonly body: ApplicationProperty
}

/**
 * PropertiesApi - object-oriented interface
 */
export class PropertiesApi extends BaseAPI implements PropertiesApiInterface {
    /**
     * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
     * @summary Delete a commit application property
     * @param {PropertiesApiDeleteCommitHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCommitHostedPropertyValue(requestParameters: PropertiesApiDeleteCommitHostedPropertyValueRequest, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).deleteCommitHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
     * @summary Delete a pull request application property
     * @param {PropertiesApiDeletePullRequestHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePullRequestHostedPropertyValue(requestParameters: PropertiesApiDeletePullRequestHostedPropertyValueRequest, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).deletePullRequestHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pullrequestId, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
     * @summary Delete a repository application property
     * @param {PropertiesApiDeleteRepositoryHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRepositoryHostedPropertyValue(requestParameters: PropertiesApiDeleteRepositoryHostedPropertyValueRequest, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).deleteRepositoryHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
     * @summary Delete a user application property
     * @param {PropertiesApiDeleteUserHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUserHostedPropertyValue(requestParameters: PropertiesApiDeleteUserHostedPropertyValueRequest, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).deleteUserHostedPropertyValue(requestParameters.selectedUser, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
     * @summary Get a commit application property
     * @param {PropertiesApiGetCommitHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCommitHostedPropertyValue(requestParameters: PropertiesApiGetCommitHostedPropertyValueRequest, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).getCommitHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
     * @summary Get a pull request application property
     * @param {PropertiesApiGetPullRequestHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPullRequestHostedPropertyValue(requestParameters: PropertiesApiGetPullRequestHostedPropertyValueRequest, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).getPullRequestHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pullrequestId, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
     * @summary Get a repository application property
     * @param {PropertiesApiGetRepositoryHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryHostedPropertyValue(requestParameters: PropertiesApiGetRepositoryHostedPropertyValueRequest, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).getRepositoryHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
     * @summary Get a user application property
     * @param {PropertiesApiRetrieveUserHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveUserHostedPropertyValue(requestParameters: PropertiesApiRetrieveUserHostedPropertyValueRequest, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).retrieveUserHostedPropertyValue(requestParameters.selectedUser, requestParameters.appKey, requestParameters.propertyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
     * @summary Update a commit application property
     * @param {PropertiesApiUpdateCommitHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateCommitHostedPropertyValue(requestParameters: PropertiesApiUpdateCommitHostedPropertyValueRequest, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).updateCommitHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.appKey, requestParameters.propertyName, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
     * @summary Update a pull request application property
     * @param {PropertiesApiUpdatePullRequestHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePullRequestHostedPropertyValue(requestParameters: PropertiesApiUpdatePullRequestHostedPropertyValueRequest, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).updatePullRequestHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.pullrequestId, requestParameters.appKey, requestParameters.propertyName, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
     * @summary Update a repository application property
     * @param {PropertiesApiUpdateRepositoryHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRepositoryHostedPropertyValue(requestParameters: PropertiesApiUpdateRepositoryHostedPropertyValueRequest, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).updateRepositoryHostedPropertyValue(requestParameters.workspace, requestParameters.repoSlug, requestParameters.appKey, requestParameters.propertyName, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
     * @summary Update a user application property
     * @param {PropertiesApiUpdateUserHostedPropertyValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUserHostedPropertyValue(requestParameters: PropertiesApiUpdateUserHostedPropertyValueRequest, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).updateUserHostedPropertyValue(requestParameters.selectedUser, requestParameters.appKey, requestParameters.propertyName, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PullrequestsApi - axios parameter creator
 */
export const PullrequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a paginated list of all pull requests as part of which this commit was reviewed. Pull Request Commit Links app must be installed first before using this API; installation automatically occurs when \'Go to pull request\' is clicked from the web interface for a commit\'s details.
         * @summary List pull requests that contain a commit
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces
         * @param {string} repoSlug The repository; either the UUID in curly braces, or the slug
         * @param {string} commit The SHA1 of the commit
         * @param {number} [page] Which page to retrieve
         * @param {number} [pagelen] How many pull requests to retrieve per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullrequestsForCommit: async (workspace: string, repoSlug: string, commit: string, page?: number, pagelen?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getPullrequestsForCommit', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getPullrequestsForCommit', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('getPullrequestsForCommit', 'commit', commit)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/pullrequests`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pagelen !== undefined) {
                localVarQueryParameter['pagelen'] = pagelen;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the repository\'s default reviewers.  These are the users that are automatically added as reviewers on every new pull request that is created. To obtain the repository\'s default reviewers as well as the default reviewers inherited from the project, use the [effective-default-reveiwers](#api-repositories-workspace-repo-slug-effective-default-reviewers-get) endpoint.
         * @summary List default reviewers
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDefaultReviewersGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDefaultReviewersGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDefaultReviewersGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/default-reviewers`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a default reviewer from the repository.
         * @summary Remove a user from the default reviewers
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} targetUsername This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete: async (repoSlug: string, targetUsername: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete', 'repoSlug', repoSlug)
            // verify required parameter 'targetUsername' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete', 'targetUsername', targetUsername)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/default-reviewers/{target_username}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"target_username"}}`, encodeURIComponent(String(targetUsername)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified reviewer.  This can be used to test whether a user is among the repository\'s default reviewers list. A 404 indicates that that specified user is not a default reviewer.
         * @summary Get a default reviewer
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} targetUsername This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet: async (repoSlug: string, targetUsername: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet', 'repoSlug', repoSlug)
            // verify required parameter 'targetUsername' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet', 'targetUsername', targetUsername)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/default-reviewers/{target_username}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"target_username"}}`, encodeURIComponent(String(targetUsername)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds the specified user to the repository\'s list of default reviewers.  This method is idempotent. Adding a user a second time has no effect.
         * @summary Add a user to the default reviewers
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} targetUsername This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut: async (repoSlug: string, targetUsername: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut', 'repoSlug', repoSlug)
            // verify required parameter 'targetUsername' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut', 'targetUsername', targetUsername)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/default-reviewers/{target_username}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"target_username"}}`, encodeURIComponent(String(targetUsername)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the repository\'s effective default reviewers. This includes both default reviewers defined at the repository level as well as those inherited from its project.  These are the users that are automatically added as reviewers on every new pull request that is created.
         * @summary List effective default reviewers
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/effective-default-reviewers`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of the pull request\'s activity log.  This handler serves both a v20 and internal endpoint. The v20 endpoint returns reviewer comments, updates, approvals and request changes. The internal endpoint includes those plus tasks and attachments.  Comments created on a file or a line of code have an inline property.  Comment example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"comment\": {                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\"                     }                 },                 \"deleted\": false,                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"content\": {                     \"raw\": \"inline with to a dn from lines\",                     \"markup\": \"markdown\",                     \"html\": \"<p>inline with to a dn from lines</p>\",                     \"type\": \"rendered\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"updated_on\": \"2019-09-27T00:33:46.055384+00:00\",                 \"inline\": {                     \"context_lines\": \"\",                     \"to\": null,                     \"path\": \"\",                     \"outdated\": false,                     \"from\": 211                 },                 \"type\": \"pullrequest_comment\",                 \"id\": 118571088             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Updates include a state property of OPEN, MERGED, or DECLINED.  Update example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"update\": {                 \"description\": \"\",                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\",                 \"destination\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"6a2c16e4a152\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\"                             }                         }                     },                     \"branch\": {                         \"name\": \"master\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"reason\": \"\",                 \"source\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"728c8bad1813\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\"                             }                         }                     },                     \"branch\": {                         \"name\": \"username/NONE-add-onClick-prop-for-accessibility\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"state\": \"OPEN\",                 \"author\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"date\": \"2019-05-10T06:48:25.305565+00:00\"             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Approval example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"approval\": {                 \"date\": \"2019-09-27T00:37:19.849534+00:00\",                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 }             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```
         * @summary List a pull request activity log
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsActivityGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsActivityGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsActivityGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/activity`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all pull requests on the specified repository.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List pull requests
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {RepositoriesWorkspaceRepoSlugPullrequestsGetStateEnum} [state] Only return pull requests that are in this state. This parameter can be repeated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsGet: async (repoSlug: string, workspace: string, state?: RepositoriesWorkspaceRepoSlugPullrequestsGetStateEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new pull request where the destination repository is this repository and the author is the authenticated user.  The minimum required fields to create a pull request are `title` and `source`, specified by a branch name.  ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repository/pullrequests \\     -u my-username:my-password \\     --request POST \\     --header \'Content-Type: application/json\' \\     --data \'{         \"title\": \"My Title\",         \"source\": {             \"branch\": {                 \"name\": \"staging\"             }         }     }\' ```  If the pull request\'s `destination` is not specified, it will default to the `repository.mainbranch`. To open a pull request to a different branch, say from a feature branch to a staging branch, specify a `destination` (same format as the `source`):  ``` {     \"title\": \"My Title\",     \"source\": {         \"branch\": {             \"name\": \"my-feature-branch\"         }     },     \"destination\": {         \"branch\": {             \"name\": \"staging\"         }     } } ```  Reviewers can be specified by adding an array of user objects as the `reviewers` property.  ``` {     \"title\": \"My Title\",     \"source\": {         \"branch\": {             \"name\": \"my-feature-branch\"         }     },     \"reviewers\": [         {             \"uuid\": \"{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\"         }     ] } ```  Other fields:  * `description` - a string * `close_source_branch` - boolean that specifies if the source branch should be closed upon merging * `draft` - boolean that specifies whether the pull request is a draft
         * @summary Create a pull request
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Pullrequest} [body] The new pull request.  The request URL you POST to becomes the destination repository URL. For this reason, you must specify an explicit source repository in the request object if you want to pull from a different repository (fork).  Since not all elements are required or even mutable, you only need to include the elements you want to initialize, such as the source branch and the title.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPost: async (repoSlug: string, workspace: string, body?: Pullrequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of the pull request\'s activity log.  This handler serves both a v20 and internal endpoint. The v20 endpoint returns reviewer comments, updates, approvals and request changes. The internal endpoint includes those plus tasks and attachments.  Comments created on a file or a line of code have an inline property.  Comment example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"comment\": {                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\"                     }                 },                 \"deleted\": false,                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"content\": {                     \"raw\": \"inline with to a dn from lines\",                     \"markup\": \"markdown\",                     \"html\": \"<p>inline with to a dn from lines</p>\",                     \"type\": \"rendered\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"updated_on\": \"2019-09-27T00:33:46.055384+00:00\",                 \"inline\": {                     \"context_lines\": \"\",                     \"to\": null,                     \"path\": \"\",                     \"outdated\": false,                     \"from\": 211                 },                 \"type\": \"pullrequest_comment\",                 \"id\": 118571088             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Updates include a state property of OPEN, MERGED, or DECLINED.  Update example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"update\": {                 \"description\": \"\",                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\",                 \"destination\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"6a2c16e4a152\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\"                             }                         }                     },                     \"branch\": {                         \"name\": \"master\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"reason\": \"\",                 \"source\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"728c8bad1813\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\"                             }                         }                     },                     \"branch\": {                         \"name\": \"username/NONE-add-onClick-prop-for-accessibility\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"state\": \"OPEN\",                 \"author\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"date\": \"2019-05-10T06:48:25.305565+00:00\"             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Approval example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"approval\": {                 \"date\": \"2019-09-27T00:37:19.849534+00:00\",                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 }             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```
         * @summary List a pull request activity log
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet: async (pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/activity`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redact the authenticated user\'s approval of the specified pull request.
         * @summary Unapprove a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete: async (pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/approve`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Approve the specified pull request as the authenticated user.
         * @summary Approve a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost: async (pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/approve`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific pull request comment.
         * @summary Delete a comment on a pull request
         * @param {number} commentId The id of the comment.
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete: async (commentId: number, pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete', 'commentId', commentId)
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific pull request comment.
         * @summary Get a comment on a pull request
         * @param {number} commentId The id of the comment.
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet: async (commentId: number, pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet', 'commentId', commentId)
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a specific pull request comment.
         * @summary Update a comment on a pull request
         * @param {number} commentId The id of the comment.
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {PullrequestComment} body The contents of the updated comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut: async (commentId: number, pullRequestId: number, repoSlug: string, workspace: string, body: PullrequestComment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut', 'commentId', commentId)
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reopen a comment thread
         * @param {number} commentId The id of the comment.
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDelete: async (commentId: number, pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDelete', 'commentId', commentId)
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDelete', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}/resolve`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resolve a comment thread
         * @param {number} commentId The id of the comment.
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePost: async (commentId: number, pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePost', 'commentId', commentId)
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePost', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}/resolve`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of the pull request\'s comments.  This includes both global, inline comments and replies.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List comments on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet: async (pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new pull request comment.  Returns the newly created pull request comment.
         * @summary Create a comment on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {PullrequestComment} body The comment object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost: async (pullRequestId: number, repoSlug: string, workspace: string, body: PullrequestComment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of the pull request\'s commits.  These are the commits that are being merged into the destination branch when the pull requests gets accepted.
         * @summary List commits on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet: async (pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/commits`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Declines the pull request.
         * @summary Decline a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost: async (pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/decline`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to the [repository diff](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diff-spec-get) with the revspec that corresponds to the pull request.
         * @summary List changes in a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet: async (pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/diff`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to the [repository diffstat](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diffstat-spec-get) with the revspec that corresponds to the pull request.
         * @summary Get the diff stat for a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet: async (pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/diffstat`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified pull request.
         * @summary Get a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet: async (pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merges the pull request.
         * @summary Merge a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {boolean} [async] Default value is false.   When set to true, runs merge asynchronously and immediately returns a 202 with polling link to the task-status API in the Location header.   When set to false, runs merge and waits for it to complete, returning 200 when it succeeds. If the duration of the merge exceeds a timeout threshold, the API returns a 202 with polling link to the task-status API in the Location header.
         * @param {PullrequestMergeParameters} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost: async (pullRequestId: number, repoSlug: string, workspace: string, async?: boolean, body?: PullrequestMergeParameters, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/merge`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When merging a pull request takes too long, the client receives a task ID along with a 202 status code. The task ID can be used in a call to this endpoint to check the status of a merge task.  ``` curl -X GET https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id> ```  If the merge task is not yet finished, a PENDING status will be returned.  ``` HTTP/2 200 {     \"task_status\": \"PENDING\",     \"links\": {         \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>\"         }     } } ```  If the merge was successful, a SUCCESS status will be returned.  ``` HTTP/2 200 {     \"task_status\": \"SUCCESS\",     \"links\": {         \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>\"         }     },     \"merge_result\": <the merged pull request object> } ```  If the merge task failed, an error will be returned.  ``` {     \"type\": \"error\",     \"error\": {         \"message\": \"<error message>\"     } } ```
         * @summary Get the merge task status for a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} taskId ID of the merge task
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet: async (pullRequestId: number, repoSlug: string, taskId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet', 'repoSlug', repoSlug)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet', 'taskId', taskId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/merge/task-status/{task_id}`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to the [repository patch](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-patch-spec-get) with the revspec that corresponds to pull request.
         * @summary Get the patch for a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet: async (pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/patch`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mutates the specified pull request.  This can be used to change the pull request\'s branches or description.  Only open pull requests can be mutated.
         * @summary Update a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Pullrequest} [body] The pull request that is to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut: async (pullRequestId: number, repoSlug: string, workspace: string, body?: Pullrequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove change request for a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete: async (pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/request-changes`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request changes for a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost: async (pullRequestId: number, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/request-changes`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all statuses (e.g. build results) for the given pull request.
         * @summary List commit statuses for a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q] Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {string} [sort] Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). Defaults to &#x60;created_on&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet: async (pullRequestId: number, repoSlug: string, workspace: string, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/statuses`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of the pull request\'s tasks.  This endpoint supports filtering and sorting of the results by the \'task\' field. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List tasks on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details.
         * @param {string} [sort]  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). Defaults to &#x60;created_on&#x60;. 
         * @param {number} [pagelen]  Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGet: async (pullRequestId: number, repoSlug: string, workspace: string, q?: string, sort?: string, pagelen?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGet', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/tasks`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (pagelen !== undefined) {
                localVarQueryParameter['pagelen'] = pagelen;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new pull request task.  Returns the newly created pull request task.  Tasks can optionally be created in relation to a comment specified by the comment\'s ID which will cause the task to appear below the comment on a pull request when viewed in Bitbucket.
         * @summary Create a task on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {PullrequestTaskCreate} body The contents of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPost: async (pullRequestId: number, repoSlug: string, workspace: string, body: PullrequestTaskCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPost', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPost', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPost', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/tasks`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific pull request task.
         * @summary Delete a task on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {number} taskId The ID of the task.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDelete: async (pullRequestId: number, repoSlug: string, taskId: number, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDelete', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDelete', 'repoSlug', repoSlug)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDelete', 'taskId', taskId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/tasks/{task_id}`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific pull request task.
         * @summary Get a task on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {number} taskId The ID of the task.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGet: async (pullRequestId: number, repoSlug: string, taskId: number, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGet', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGet', 'repoSlug', repoSlug)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGet', 'taskId', taskId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/tasks/{task_id}`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a specific pull request task.
         * @summary Update a task on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {number} taskId The ID of the task.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {PullrequestTaskUpdate} body The updated state and content of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut: async (pullRequestId: number, repoSlug: string, taskId: number, workspace: string, body: PullrequestTaskUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pullRequestId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut', 'pullRequestId', pullRequestId)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut', 'repoSlug', repoSlug)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut', 'taskId', taskId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/tasks/{task_id}`
                .replace(`{${"pull_request_id"}}`, encodeURIComponent(String(pullRequestId)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all workspace pull requests authored by the specified user.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List workspace pull requests for a user
         * @param {string} selectedUser This can either be the username of the pull request author, the author\&#39;s UUID surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, or the author\&#39;s Atlassian ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {WorkspacesWorkspacePullrequestsSelectedUserGetStateEnum} [state] Only return pull requests that are in this state. This parameter can be repeated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspacePullrequestsSelectedUserGet: async (selectedUser: string, workspace: string, state?: WorkspacesWorkspacePullrequestsSelectedUserGetStateEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('workspacesWorkspacePullrequestsSelectedUserGet', 'selectedUser', selectedUser)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspacePullrequestsSelectedUserGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/pullrequests/{selected_user}`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PullrequestsApi - functional programming interface
 */
export const PullrequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PullrequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a paginated list of all pull requests as part of which this commit was reviewed. Pull Request Commit Links app must be installed first before using this API; installation automatically occurs when \'Go to pull request\' is clicked from the web interface for a commit\'s details.
         * @summary List pull requests that contain a commit
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces
         * @param {string} repoSlug The repository; either the UUID in curly braces, or the slug
         * @param {string} commit The SHA1 of the commit
         * @param {number} [page] Which page to retrieve
         * @param {number} [pagelen] How many pull requests to retrieve per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPullrequestsForCommit(workspace: string, repoSlug: string, commit: string, page?: number, pagelen?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPullrequests>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPullrequestsForCommit(workspace, repoSlug, commit, page, pagelen, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.getPullrequestsForCommit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the repository\'s default reviewers.  These are the users that are automatically added as reviewers on every new pull request that is created. To obtain the repository\'s default reviewers as well as the default reviewers inherited from the project, use the [effective-default-reveiwers](#api-repositories-workspace-repo-slug-effective-default-reviewers-get) endpoint.
         * @summary List default reviewers
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDefaultReviewersGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAccounts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDefaultReviewersGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugDefaultReviewersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a default reviewer from the repository.
         * @summary Remove a user from the default reviewers
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} targetUsername This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete(repoSlug: string, targetUsername: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete(repoSlug, targetUsername, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specified reviewer.  This can be used to test whether a user is among the repository\'s default reviewers list. A 404 indicates that that specified user is not a default reviewer.
         * @summary Get a default reviewer
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} targetUsername This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet(repoSlug: string, targetUsername: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet(repoSlug, targetUsername, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds the specified user to the repository\'s list of default reviewers.  This method is idempotent. Adding a user a second time has no effect.
         * @summary Add a user to the default reviewers
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} targetUsername This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut(repoSlug: string, targetUsername: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut(repoSlug, targetUsername, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the repository\'s effective default reviewers. This includes both default reviewers defined at the repository level as well as those inherited from its project.  These are the users that are automatically added as reviewers on every new pull request that is created.
         * @summary List effective default reviewers
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDefaultReviewerAndType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of the pull request\'s activity log.  This handler serves both a v20 and internal endpoint. The v20 endpoint returns reviewer comments, updates, approvals and request changes. The internal endpoint includes those plus tasks and attachments.  Comments created on a file or a line of code have an inline property.  Comment example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"comment\": {                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\"                     }                 },                 \"deleted\": false,                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"content\": {                     \"raw\": \"inline with to a dn from lines\",                     \"markup\": \"markdown\",                     \"html\": \"<p>inline with to a dn from lines</p>\",                     \"type\": \"rendered\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"updated_on\": \"2019-09-27T00:33:46.055384+00:00\",                 \"inline\": {                     \"context_lines\": \"\",                     \"to\": null,                     \"path\": \"\",                     \"outdated\": false,                     \"from\": 211                 },                 \"type\": \"pullrequest_comment\",                 \"id\": 118571088             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Updates include a state property of OPEN, MERGED, or DECLINED.  Update example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"update\": {                 \"description\": \"\",                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\",                 \"destination\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"6a2c16e4a152\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\"                             }                         }                     },                     \"branch\": {                         \"name\": \"master\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"reason\": \"\",                 \"source\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"728c8bad1813\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\"                             }                         }                     },                     \"branch\": {                         \"name\": \"username/NONE-add-onClick-prop-for-accessibility\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"state\": \"OPEN\",                 \"author\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"date\": \"2019-05-10T06:48:25.305565+00:00\"             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Approval example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"approval\": {                 \"date\": \"2019-09-27T00:37:19.849534+00:00\",                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 }             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```
         * @summary List a pull request activity log
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsActivityGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsActivityGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsActivityGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all pull requests on the specified repository.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List pull requests
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {RepositoriesWorkspaceRepoSlugPullrequestsGetStateEnum} [state] Only return pull requests that are in this state. This parameter can be repeated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsGet(repoSlug: string, workspace: string, state?: RepositoriesWorkspaceRepoSlugPullrequestsGetStateEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPullrequests>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsGet(repoSlug, workspace, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new pull request where the destination repository is this repository and the author is the authenticated user.  The minimum required fields to create a pull request are `title` and `source`, specified by a branch name.  ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repository/pullrequests \\     -u my-username:my-password \\     --request POST \\     --header \'Content-Type: application/json\' \\     --data \'{         \"title\": \"My Title\",         \"source\": {             \"branch\": {                 \"name\": \"staging\"             }         }     }\' ```  If the pull request\'s `destination` is not specified, it will default to the `repository.mainbranch`. To open a pull request to a different branch, say from a feature branch to a staging branch, specify a `destination` (same format as the `source`):  ``` {     \"title\": \"My Title\",     \"source\": {         \"branch\": {             \"name\": \"my-feature-branch\"         }     },     \"destination\": {         \"branch\": {             \"name\": \"staging\"         }     } } ```  Reviewers can be specified by adding an array of user objects as the `reviewers` property.  ``` {     \"title\": \"My Title\",     \"source\": {         \"branch\": {             \"name\": \"my-feature-branch\"         }     },     \"reviewers\": [         {             \"uuid\": \"{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\"         }     ] } ```  Other fields:  * `description` - a string * `close_source_branch` - boolean that specifies if the source branch should be closed upon merging * `draft` - boolean that specifies whether the pull request is a draft
         * @summary Create a pull request
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Pullrequest} [body] The new pull request.  The request URL you POST to becomes the destination repository URL. For this reason, you must specify an explicit source repository in the request object if you want to pull from a different repository (fork).  Since not all elements are required or even mutable, you only need to include the elements you want to initialize, such as the source branch and the title.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPost(repoSlug: string, workspace: string, body?: Pullrequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pullrequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPost(repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of the pull request\'s activity log.  This handler serves both a v20 and internal endpoint. The v20 endpoint returns reviewer comments, updates, approvals and request changes. The internal endpoint includes those plus tasks and attachments.  Comments created on a file or a line of code have an inline property.  Comment example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"comment\": {                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\"                     }                 },                 \"deleted\": false,                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"content\": {                     \"raw\": \"inline with to a dn from lines\",                     \"markup\": \"markdown\",                     \"html\": \"<p>inline with to a dn from lines</p>\",                     \"type\": \"rendered\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"updated_on\": \"2019-09-27T00:33:46.055384+00:00\",                 \"inline\": {                     \"context_lines\": \"\",                     \"to\": null,                     \"path\": \"\",                     \"outdated\": false,                     \"from\": 211                 },                 \"type\": \"pullrequest_comment\",                 \"id\": 118571088             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Updates include a state property of OPEN, MERGED, or DECLINED.  Update example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"update\": {                 \"description\": \"\",                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\",                 \"destination\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"6a2c16e4a152\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\"                             }                         }                     },                     \"branch\": {                         \"name\": \"master\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"reason\": \"\",                 \"source\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"728c8bad1813\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\"                             }                         }                     },                     \"branch\": {                         \"name\": \"username/NONE-add-onClick-prop-for-accessibility\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"state\": \"OPEN\",                 \"author\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"date\": \"2019-05-10T06:48:25.305565+00:00\"             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Approval example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"approval\": {                 \"date\": \"2019-09-27T00:37:19.849534+00:00\",                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 }             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```
         * @summary List a pull request activity log
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet(pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet(pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Redact the authenticated user\'s approval of the specified pull request.
         * @summary Unapprove a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete(pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete(pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Approve the specified pull request as the authenticated user.
         * @summary Approve a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost(pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Participant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost(pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a specific pull request comment.
         * @summary Delete a comment on a pull request
         * @param {number} commentId The id of the comment.
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete(commentId: number, pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete(commentId, pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a specific pull request comment.
         * @summary Get a comment on a pull request
         * @param {number} commentId The id of the comment.
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet(commentId: number, pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullrequestComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet(commentId, pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a specific pull request comment.
         * @summary Update a comment on a pull request
         * @param {number} commentId The id of the comment.
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {PullrequestComment} body The contents of the updated comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut(commentId: number, pullRequestId: number, repoSlug: string, workspace: string, body: PullrequestComment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullrequestComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut(commentId, pullRequestId, repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reopen a comment thread
         * @param {number} commentId The id of the comment.
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDelete(commentId: number, pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDelete(commentId, pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Resolve a comment thread
         * @param {number} commentId The id of the comment.
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePost(commentId: number, pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentResolution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePost(commentId, pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of the pull request\'s comments.  This includes both global, inline comments and replies.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List comments on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet(pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPullrequestComments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet(pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new pull request comment.  Returns the newly created pull request comment.
         * @summary Create a comment on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {PullrequestComment} body The comment object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost(pullRequestId: number, repoSlug: string, workspace: string, body: PullrequestComment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullrequestComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost(pullRequestId, repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of the pull request\'s commits.  These are the commits that are being merged into the destination branch when the pull requests gets accepted.
         * @summary List commits on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet(pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet(pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Declines the pull request.
         * @summary Decline a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost(pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pullrequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost(pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Redirects to the [repository diff](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diff-spec-get) with the revspec that corresponds to the pull request.
         * @summary List changes in a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet(pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet(pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Redirects to the [repository diffstat](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diffstat-spec-get) with the revspec that corresponds to the pull request.
         * @summary Get the diff stat for a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet(pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet(pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specified pull request.
         * @summary Get a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet(pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pullrequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet(pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Merges the pull request.
         * @summary Merge a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {boolean} [async] Default value is false.   When set to true, runs merge asynchronously and immediately returns a 202 with polling link to the task-status API in the Location header.   When set to false, runs merge and waits for it to complete, returning 200 when it succeeds. If the duration of the merge exceeds a timeout threshold, the API returns a 202 with polling link to the task-status API in the Location header.
         * @param {PullrequestMergeParameters} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost(pullRequestId: number, repoSlug: string, workspace: string, async?: boolean, body?: PullrequestMergeParameters, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pullrequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost(pullRequestId, repoSlug, workspace, async, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * When merging a pull request takes too long, the client receives a task ID along with a 202 status code. The task ID can be used in a call to this endpoint to check the status of a merge task.  ``` curl -X GET https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id> ```  If the merge task is not yet finished, a PENDING status will be returned.  ``` HTTP/2 200 {     \"task_status\": \"PENDING\",     \"links\": {         \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>\"         }     } } ```  If the merge was successful, a SUCCESS status will be returned.  ``` HTTP/2 200 {     \"task_status\": \"SUCCESS\",     \"links\": {         \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>\"         }     },     \"merge_result\": <the merged pull request object> } ```  If the merge task failed, an error will be returned.  ``` {     \"type\": \"error\",     \"error\": {         \"message\": \"<error message>\"     } } ```
         * @summary Get the merge task status for a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} taskId ID of the merge task
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet(pullRequestId: number, repoSlug: string, taskId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet(pullRequestId, repoSlug, taskId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Redirects to the [repository patch](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-patch-spec-get) with the revspec that corresponds to pull request.
         * @summary Get the patch for a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet(pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet(pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mutates the specified pull request.  This can be used to change the pull request\'s branches or description.  Only open pull requests can be mutated.
         * @summary Update a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Pullrequest} [body] The pull request that is to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut(pullRequestId: number, repoSlug: string, workspace: string, body?: Pullrequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pullrequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut(pullRequestId, repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove change request for a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete(pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete(pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request changes for a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost(pullRequestId: number, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Participant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost(pullRequestId, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all statuses (e.g. build results) for the given pull request.
         * @summary List commit statuses for a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q] Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {string} [sort] Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). Defaults to &#x60;created_on&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(pullRequestId: number, repoSlug: string, workspace: string, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCommitstatuses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(pullRequestId, repoSlug, workspace, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of the pull request\'s tasks.  This endpoint supports filtering and sorting of the results by the \'task\' field. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List tasks on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details.
         * @param {string} [sort]  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). Defaults to &#x60;created_on&#x60;. 
         * @param {number} [pagelen]  Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGet(pullRequestId: number, repoSlug: string, workspace: string, q?: string, sort?: string, pagelen?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTasks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGet(pullRequestId, repoSlug, workspace, q, sort, pagelen, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new pull request task.  Returns the newly created pull request task.  Tasks can optionally be created in relation to a comment specified by the comment\'s ID which will cause the task to appear below the comment on a pull request when viewed in Bitbucket.
         * @summary Create a task on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {PullrequestTaskCreate} body The contents of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPost(pullRequestId: number, repoSlug: string, workspace: string, body: PullrequestTaskCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullrequestCommentTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPost(pullRequestId, repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a specific pull request task.
         * @summary Delete a task on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {number} taskId The ID of the task.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDelete(pullRequestId: number, repoSlug: string, taskId: number, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDelete(pullRequestId, repoSlug, taskId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a specific pull request task.
         * @summary Get a task on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {number} taskId The ID of the task.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGet(pullRequestId: number, repoSlug: string, taskId: number, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullrequestCommentTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGet(pullRequestId, repoSlug, taskId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a specific pull request task.
         * @summary Update a task on a pull request
         * @param {number} pullRequestId The id of the pull request.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {number} taskId The ID of the task.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {PullrequestTaskUpdate} body The updated state and content of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut(pullRequestId: number, repoSlug: string, taskId: number, workspace: string, body: PullrequestTaskUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullrequestCommentTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut(pullRequestId, repoSlug, taskId, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all workspace pull requests authored by the specified user.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List workspace pull requests for a user
         * @param {string} selectedUser This can either be the username of the pull request author, the author\&#39;s UUID surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, or the author\&#39;s Atlassian ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {WorkspacesWorkspacePullrequestsSelectedUserGetStateEnum} [state] Only return pull requests that are in this state. This parameter can be repeated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspacePullrequestsSelectedUserGet(selectedUser: string, workspace: string, state?: WorkspacesWorkspacePullrequestsSelectedUserGetStateEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPullrequests>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspacePullrequestsSelectedUserGet(selectedUser, workspace, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullrequestsApi.workspacesWorkspacePullrequestsSelectedUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PullrequestsApi - factory interface
 */
export const PullrequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PullrequestsApiFp(configuration)
    return {
        /**
         * Returns a paginated list of all pull requests as part of which this commit was reviewed. Pull Request Commit Links app must be installed first before using this API; installation automatically occurs when \'Go to pull request\' is clicked from the web interface for a commit\'s details.
         * @summary List pull requests that contain a commit
         * @param {PullrequestsApiGetPullrequestsForCommitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullrequestsForCommit(requestParameters: PullrequestsApiGetPullrequestsForCommitRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPullrequests> {
            return localVarFp.getPullrequestsForCommit(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.page, requestParameters.pagelen, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the repository\'s default reviewers.  These are the users that are automatically added as reviewers on every new pull request that is created. To obtain the repository\'s default reviewers as well as the default reviewers inherited from the project, use the [effective-default-reveiwers](#api-repositories-workspace-repo-slug-effective-default-reviewers-get) endpoint.
         * @summary List default reviewers
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDefaultReviewersGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAccounts> {
            return localVarFp.repositoriesWorkspaceRepoSlugDefaultReviewersGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a default reviewer from the repository.
         * @summary Remove a user from the default reviewers
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete(requestParameters.repoSlug, requestParameters.targetUsername, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified reviewer.  This can be used to test whether a user is among the repository\'s default reviewers list. A 404 indicates that that specified user is not a default reviewer.
         * @summary Get a default reviewer
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet(requestParameters.repoSlug, requestParameters.targetUsername, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds the specified user to the repository\'s list of default reviewers.  This method is idempotent. Adding a user a second time has no effect.
         * @summary Add a user to the default reviewers
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut(requestParameters.repoSlug, requestParameters.targetUsername, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the repository\'s effective default reviewers. This includes both default reviewers defined at the repository level as well as those inherited from its project.  These are the users that are automatically added as reviewers on every new pull request that is created.
         * @summary List effective default reviewers
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDefaultReviewerAndType> {
            return localVarFp.repositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of the pull request\'s activity log.  This handler serves both a v20 and internal endpoint. The v20 endpoint returns reviewer comments, updates, approvals and request changes. The internal endpoint includes those plus tasks and attachments.  Comments created on a file or a line of code have an inline property.  Comment example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"comment\": {                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\"                     }                 },                 \"deleted\": false,                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"content\": {                     \"raw\": \"inline with to a dn from lines\",                     \"markup\": \"markdown\",                     \"html\": \"<p>inline with to a dn from lines</p>\",                     \"type\": \"rendered\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"updated_on\": \"2019-09-27T00:33:46.055384+00:00\",                 \"inline\": {                     \"context_lines\": \"\",                     \"to\": null,                     \"path\": \"\",                     \"outdated\": false,                     \"from\": 211                 },                 \"type\": \"pullrequest_comment\",                 \"id\": 118571088             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Updates include a state property of OPEN, MERGED, or DECLINED.  Update example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"update\": {                 \"description\": \"\",                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\",                 \"destination\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"6a2c16e4a152\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\"                             }                         }                     },                     \"branch\": {                         \"name\": \"master\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"reason\": \"\",                 \"source\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"728c8bad1813\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\"                             }                         }                     },                     \"branch\": {                         \"name\": \"username/NONE-add-onClick-prop-for-accessibility\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"state\": \"OPEN\",                 \"author\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"date\": \"2019-05-10T06:48:25.305565+00:00\"             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Approval example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"approval\": {                 \"date\": \"2019-09-27T00:37:19.849534+00:00\",                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 }             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```
         * @summary List a pull request activity log
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsActivityGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsActivityGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all pull requests on the specified repository.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List pull requests
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPullrequests> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.state, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new pull request where the destination repository is this repository and the author is the authenticated user.  The minimum required fields to create a pull request are `title` and `source`, specified by a branch name.  ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repository/pullrequests \\     -u my-username:my-password \\     --request POST \\     --header \'Content-Type: application/json\' \\     --data \'{         \"title\": \"My Title\",         \"source\": {             \"branch\": {                 \"name\": \"staging\"             }         }     }\' ```  If the pull request\'s `destination` is not specified, it will default to the `repository.mainbranch`. To open a pull request to a different branch, say from a feature branch to a staging branch, specify a `destination` (same format as the `source`):  ``` {     \"title\": \"My Title\",     \"source\": {         \"branch\": {             \"name\": \"my-feature-branch\"         }     },     \"destination\": {         \"branch\": {             \"name\": \"staging\"         }     } } ```  Reviewers can be specified by adding an array of user objects as the `reviewers` property.  ``` {     \"title\": \"My Title\",     \"source\": {         \"branch\": {             \"name\": \"my-feature-branch\"         }     },     \"reviewers\": [         {             \"uuid\": \"{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\"         }     ] } ```  Other fields:  * `description` - a string * `close_source_branch` - boolean that specifies if the source branch should be closed upon merging * `draft` - boolean that specifies whether the pull request is a draft
         * @summary Create a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pullrequest> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of the pull request\'s activity log.  This handler serves both a v20 and internal endpoint. The v20 endpoint returns reviewer comments, updates, approvals and request changes. The internal endpoint includes those plus tasks and attachments.  Comments created on a file or a line of code have an inline property.  Comment example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"comment\": {                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\"                     }                 },                 \"deleted\": false,                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"content\": {                     \"raw\": \"inline with to a dn from lines\",                     \"markup\": \"markdown\",                     \"html\": \"<p>inline with to a dn from lines</p>\",                     \"type\": \"rendered\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"updated_on\": \"2019-09-27T00:33:46.055384+00:00\",                 \"inline\": {                     \"context_lines\": \"\",                     \"to\": null,                     \"path\": \"\",                     \"outdated\": false,                     \"from\": 211                 },                 \"type\": \"pullrequest_comment\",                 \"id\": 118571088             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Updates include a state property of OPEN, MERGED, or DECLINED.  Update example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"update\": {                 \"description\": \"\",                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\",                 \"destination\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"6a2c16e4a152\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\"                             }                         }                     },                     \"branch\": {                         \"name\": \"master\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"reason\": \"\",                 \"source\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"728c8bad1813\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\"                             }                         }                     },                     \"branch\": {                         \"name\": \"username/NONE-add-onClick-prop-for-accessibility\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"state\": \"OPEN\",                 \"author\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"date\": \"2019-05-10T06:48:25.305565+00:00\"             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Approval example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"approval\": {                 \"date\": \"2019-09-27T00:37:19.849534+00:00\",                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 }             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```
         * @summary List a pull request activity log
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Redact the authenticated user\'s approval of the specified pull request.
         * @summary Unapprove a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Approve the specified pull request as the authenticated user.
         * @summary Approve a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Participant> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific pull request comment.
         * @summary Delete a comment on a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete(requestParameters.commentId, requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific pull request comment.
         * @summary Get a comment on a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PullrequestComment> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet(requestParameters.commentId, requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a specific pull request comment.
         * @summary Update a comment on a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<PullrequestComment> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut(requestParameters.commentId, requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reopen a comment thread
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDelete(requestParameters.commentId, requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resolve a comment thread
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommentResolution> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePost(requestParameters.commentId, requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of the pull request\'s comments.  This includes both global, inline comments and replies.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List comments on a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPullrequestComments> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new pull request comment.  Returns the newly created pull request comment.
         * @summary Create a comment on a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PullrequestComment> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of the pull request\'s commits.  These are the commits that are being merged into the destination branch when the pull requests gets accepted.
         * @summary List commits on a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Declines the pull request.
         * @summary Decline a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pullrequest> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects to the [repository diff](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diff-spec-get) with the revspec that corresponds to the pull request.
         * @summary List changes in a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects to the [repository diffstat](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diffstat-spec-get) with the revspec that corresponds to the pull request.
         * @summary Get the diff stat for a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified pull request.
         * @summary Get a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pullrequest> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Merges the pull request.
         * @summary Merge a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pullrequest> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.async, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * When merging a pull request takes too long, the client receives a task ID along with a 202 status code. The task ID can be used in a call to this endpoint to check the status of a merge task.  ``` curl -X GET https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id> ```  If the merge task is not yet finished, a PENDING status will be returned.  ``` HTTP/2 200 {     \"task_status\": \"PENDING\",     \"links\": {         \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>\"         }     } } ```  If the merge was successful, a SUCCESS status will be returned.  ``` HTTP/2 200 {     \"task_status\": \"SUCCESS\",     \"links\": {         \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>\"         }     },     \"merge_result\": <the merged pull request object> } ```  If the merge task failed, an error will be returned.  ``` {     \"type\": \"error\",     \"error\": {         \"message\": \"<error message>\"     } } ```
         * @summary Get the merge task status for a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.taskId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects to the [repository patch](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-patch-spec-get) with the revspec that corresponds to pull request.
         * @summary Get the patch for a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Mutates the specified pull request.  This can be used to change the pull request\'s branches or description.  Only open pull requests can be mutated.
         * @summary Update a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pullrequest> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove change request for a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request changes for a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Participant> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all statuses (e.g. build results) for the given pull request.
         * @summary List commit statuses for a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedCommitstatuses> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of the pull request\'s tasks.  This endpoint supports filtering and sorting of the results by the \'task\' field. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List tasks on a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTasks> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, requestParameters.pagelen, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new pull request task.  Returns the newly created pull request task.  Tasks can optionally be created in relation to a comment specified by the comment\'s ID which will cause the task to appear below the comment on a pull request when viewed in Bitbucket.
         * @summary Create a task on a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PullrequestCommentTask> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPost(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific pull request task.
         * @summary Delete a task on a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDelete(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.taskId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific pull request task.
         * @summary Get a task on a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PullrequestCommentTask> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.taskId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a specific pull request task.
         * @summary Update a task on a pull request
         * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<PullrequestCommentTask> {
            return localVarFp.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.taskId, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all workspace pull requests authored by the specified user.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List workspace pull requests for a user
         * @param {PullrequestsApiWorkspacesWorkspacePullrequestsSelectedUserGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspacePullrequestsSelectedUserGet(requestParameters: PullrequestsApiWorkspacesWorkspacePullrequestsSelectedUserGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPullrequests> {
            return localVarFp.workspacesWorkspacePullrequestsSelectedUserGet(requestParameters.selectedUser, requestParameters.workspace, requestParameters.state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PullrequestsApi - interface
 */
export interface PullrequestsApiInterface {
    /**
     * Returns a paginated list of all pull requests as part of which this commit was reviewed. Pull Request Commit Links app must be installed first before using this API; installation automatically occurs when \'Go to pull request\' is clicked from the web interface for a commit\'s details.
     * @summary List pull requests that contain a commit
     * @param {PullrequestsApiGetPullrequestsForCommitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPullrequestsForCommit(requestParameters: PullrequestsApiGetPullrequestsForCommitRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPullrequests>;

    /**
     * Returns the repository\'s default reviewers.  These are the users that are automatically added as reviewers on every new pull request that is created. To obtain the repository\'s default reviewers as well as the default reviewers inherited from the project, use the [effective-default-reveiwers](#api-repositories-workspace-repo-slug-effective-default-reviewers-get) endpoint.
     * @summary List default reviewers
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDefaultReviewersGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAccounts>;

    /**
     * Removes a default reviewer from the repository.
     * @summary Remove a user from the default reviewers
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the specified reviewer.  This can be used to test whether a user is among the repository\'s default reviewers list. A 404 indicates that that specified user is not a default reviewer.
     * @summary Get a default reviewer
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Account>;

    /**
     * Adds the specified user to the repository\'s list of default reviewers.  This method is idempotent. Adding a user a second time has no effect.
     * @summary Add a user to the default reviewers
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Account>;

    /**
     * Returns the repository\'s effective default reviewers. This includes both default reviewers defined at the repository level as well as those inherited from its project.  These are the users that are automatically added as reviewers on every new pull request that is created.
     * @summary List effective default reviewers
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDefaultReviewerAndType>;

    /**
     * Returns a paginated list of the pull request\'s activity log.  This handler serves both a v20 and internal endpoint. The v20 endpoint returns reviewer comments, updates, approvals and request changes. The internal endpoint includes those plus tasks and attachments.  Comments created on a file or a line of code have an inline property.  Comment example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"comment\": {                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\"                     }                 },                 \"deleted\": false,                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"content\": {                     \"raw\": \"inline with to a dn from lines\",                     \"markup\": \"markdown\",                     \"html\": \"<p>inline with to a dn from lines</p>\",                     \"type\": \"rendered\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"updated_on\": \"2019-09-27T00:33:46.055384+00:00\",                 \"inline\": {                     \"context_lines\": \"\",                     \"to\": null,                     \"path\": \"\",                     \"outdated\": false,                     \"from\": 211                 },                 \"type\": \"pullrequest_comment\",                 \"id\": 118571088             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Updates include a state property of OPEN, MERGED, or DECLINED.  Update example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"update\": {                 \"description\": \"\",                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\",                 \"destination\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"6a2c16e4a152\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\"                             }                         }                     },                     \"branch\": {                         \"name\": \"master\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"reason\": \"\",                 \"source\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"728c8bad1813\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\"                             }                         }                     },                     \"branch\": {                         \"name\": \"username/NONE-add-onClick-prop-for-accessibility\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"state\": \"OPEN\",                 \"author\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"date\": \"2019-05-10T06:48:25.305565+00:00\"             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Approval example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"approval\": {                 \"date\": \"2019-09-27T00:37:19.849534+00:00\",                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 }             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```
     * @summary List a pull request activity log
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsActivityGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns all pull requests on the specified repository.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary List pull requests
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPullrequests>;

    /**
     * Creates a new pull request where the destination repository is this repository and the author is the authenticated user.  The minimum required fields to create a pull request are `title` and `source`, specified by a branch name.  ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repository/pullrequests \\     -u my-username:my-password \\     --request POST \\     --header \'Content-Type: application/json\' \\     --data \'{         \"title\": \"My Title\",         \"source\": {             \"branch\": {                 \"name\": \"staging\"             }         }     }\' ```  If the pull request\'s `destination` is not specified, it will default to the `repository.mainbranch`. To open a pull request to a different branch, say from a feature branch to a staging branch, specify a `destination` (same format as the `source`):  ``` {     \"title\": \"My Title\",     \"source\": {         \"branch\": {             \"name\": \"my-feature-branch\"         }     },     \"destination\": {         \"branch\": {             \"name\": \"staging\"         }     } } ```  Reviewers can be specified by adding an array of user objects as the `reviewers` property.  ``` {     \"title\": \"My Title\",     \"source\": {         \"branch\": {             \"name\": \"my-feature-branch\"         }     },     \"reviewers\": [         {             \"uuid\": \"{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\"         }     ] } ```  Other fields:  * `description` - a string * `close_source_branch` - boolean that specifies if the source branch should be closed upon merging * `draft` - boolean that specifies whether the pull request is a draft
     * @summary Create a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pullrequest>;

    /**
     * Returns a paginated list of the pull request\'s activity log.  This handler serves both a v20 and internal endpoint. The v20 endpoint returns reviewer comments, updates, approvals and request changes. The internal endpoint includes those plus tasks and attachments.  Comments created on a file or a line of code have an inline property.  Comment example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"comment\": {                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\"                     }                 },                 \"deleted\": false,                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"content\": {                     \"raw\": \"inline with to a dn from lines\",                     \"markup\": \"markdown\",                     \"html\": \"<p>inline with to a dn from lines</p>\",                     \"type\": \"rendered\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"updated_on\": \"2019-09-27T00:33:46.055384+00:00\",                 \"inline\": {                     \"context_lines\": \"\",                     \"to\": null,                     \"path\": \"\",                     \"outdated\": false,                     \"from\": 211                 },                 \"type\": \"pullrequest_comment\",                 \"id\": 118571088             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Updates include a state property of OPEN, MERGED, or DECLINED.  Update example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"update\": {                 \"description\": \"\",                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\",                 \"destination\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"6a2c16e4a152\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\"                             }                         }                     },                     \"branch\": {                         \"name\": \"master\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"reason\": \"\",                 \"source\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"728c8bad1813\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\"                             }                         }                     },                     \"branch\": {                         \"name\": \"username/NONE-add-onClick-prop-for-accessibility\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"state\": \"OPEN\",                 \"author\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"date\": \"2019-05-10T06:48:25.305565+00:00\"             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Approval example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"approval\": {                 \"date\": \"2019-09-27T00:37:19.849534+00:00\",                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 }             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```
     * @summary List a pull request activity log
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Redact the authenticated user\'s approval of the specified pull request.
     * @summary Unapprove a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Approve the specified pull request as the authenticated user.
     * @summary Approve a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Participant>;

    /**
     * Deletes a specific pull request comment.
     * @summary Delete a comment on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a specific pull request comment.
     * @summary Get a comment on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PullrequestComment>;

    /**
     * Updates a specific pull request comment.
     * @summary Update a comment on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<PullrequestComment>;

    /**
     * 
     * @summary Reopen a comment thread
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Resolve a comment thread
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommentResolution>;

    /**
     * Returns a paginated list of the pull request\'s comments.  This includes both global, inline comments and replies.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary List comments on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPullrequestComments>;

    /**
     * Creates a new pull request comment.  Returns the newly created pull request comment.
     * @summary Create a comment on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PullrequestComment>;

    /**
     * Returns a paginated list of the pull request\'s commits.  These are the commits that are being merged into the destination branch when the pull requests gets accepted.
     * @summary List commits on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Declines the pull request.
     * @summary Decline a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pullrequest>;

    /**
     * Redirects to the [repository diff](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diff-spec-get) with the revspec that corresponds to the pull request.
     * @summary List changes in a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Redirects to the [repository diffstat](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diffstat-spec-get) with the revspec that corresponds to the pull request.
     * @summary Get the diff stat for a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the specified pull request.
     * @summary Get a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pullrequest>;

    /**
     * Merges the pull request.
     * @summary Merge a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pullrequest>;

    /**
     * When merging a pull request takes too long, the client receives a task ID along with a 202 status code. The task ID can be used in a call to this endpoint to check the status of a merge task.  ``` curl -X GET https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id> ```  If the merge task is not yet finished, a PENDING status will be returned.  ``` HTTP/2 200 {     \"task_status\": \"PENDING\",     \"links\": {         \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>\"         }     } } ```  If the merge was successful, a SUCCESS status will be returned.  ``` HTTP/2 200 {     \"task_status\": \"SUCCESS\",     \"links\": {         \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>\"         }     },     \"merge_result\": <the merged pull request object> } ```  If the merge task failed, an error will be returned.  ``` {     \"type\": \"error\",     \"error\": {         \"message\": \"<error message>\"     } } ```
     * @summary Get the merge task status for a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Redirects to the [repository patch](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-patch-spec-get) with the revspec that corresponds to pull request.
     * @summary Get the patch for a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Mutates the specified pull request.  This can be used to change the pull request\'s branches or description.  Only open pull requests can be mutated.
     * @summary Update a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pullrequest>;

    /**
     * 
     * @summary Remove change request for a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Request changes for a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Participant>;

    /**
     * Returns all statuses (e.g. build results) for the given pull request.
     * @summary List commit statuses for a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedCommitstatuses>;

    /**
     * Returns a paginated list of the pull request\'s tasks.  This endpoint supports filtering and sorting of the results by the \'task\' field. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary List tasks on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTasks>;

    /**
     * Creates a new pull request task.  Returns the newly created pull request task.  Tasks can optionally be created in relation to a comment specified by the comment\'s ID which will cause the task to appear below the comment on a pull request when viewed in Bitbucket.
     * @summary Create a task on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PullrequestCommentTask>;

    /**
     * Deletes a specific pull request task.
     * @summary Delete a task on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a specific pull request task.
     * @summary Get a task on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PullrequestCommentTask>;

    /**
     * Updates a specific pull request task.
     * @summary Update a task on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<PullrequestCommentTask>;

    /**
     * Returns all workspace pull requests authored by the specified user.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary List workspace pull requests for a user
     * @param {PullrequestsApiWorkspacesWorkspacePullrequestsSelectedUserGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspacePullrequestsSelectedUserGet(requestParameters: PullrequestsApiWorkspacesWorkspacePullrequestsSelectedUserGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPullrequests>;

}

/**
 * Request parameters for getPullrequestsForCommit operation in PullrequestsApi.
 */
export interface PullrequestsApiGetPullrequestsForCommitRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces
     */
    readonly workspace: string

    /**
     * The repository; either the UUID in curly braces, or the slug
     */
    readonly repoSlug: string

    /**
     * The SHA1 of the commit
     */
    readonly commit: string

    /**
     * Which page to retrieve
     */
    readonly page?: number

    /**
     * How many pull requests to retrieve per page
     */
    readonly pagelen?: number
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDefaultReviewersGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly targetUsername: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly targetUsername: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly targetUsername: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsActivityGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * Only return pull requests that are in this state. This parameter can be repeated.
     */
    readonly state?: RepositoriesWorkspaceRepoSlugPullrequestsGetStateEnum
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPost operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The new pull request.  The request URL you POST to becomes the destination repository URL. For this reason, you must specify an explicit source repository in the request object if you want to pull from a different repository (fork).  Since not all elements are required or even mutable, you only need to include the elements you want to initialize, such as the source branch and the title.
     */
    readonly body?: Pullrequest
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest {
    /**
     * The id of the comment.
     */
    readonly commentId: number

    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest {
    /**
     * The id of the comment.
     */
    readonly commentId: number

    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest {
    /**
     * The id of the comment.
     */
    readonly commentId: number

    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The contents of the updated comment.
     */
    readonly body: PullrequestComment
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDelete operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDeleteRequest {
    /**
     * The id of the comment.
     */
    readonly commentId: number

    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePost operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePostRequest {
    /**
     * The id of the comment.
     */
    readonly commentId: number

    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The comment object.
     */
    readonly body: PullrequestComment
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * Default value is false.   When set to true, runs merge asynchronously and immediately returns a 202 with polling link to the task-status API in the Location header.   When set to false, runs merge and waits for it to complete, returning 200 when it succeeds. If the duration of the merge exceeds a timeout threshold, the API returns a 202 with polling link to the task-status API in the Location header.
     */
    readonly async?: boolean

    readonly body?: PullrequestMergeParameters
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * ID of the merge task
     */
    readonly taskId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The pull request that is to be updated.
     */
    readonly body?: Pullrequest
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
     */
    readonly q?: string

    /**
     * Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). Defaults to &#x60;created_on&#x60;. 
     */
    readonly sort?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGetRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     *  Query string to narrow down the response. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details.
     */
    readonly q?: string

    /**
     *  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). Defaults to &#x60;created_on&#x60;. 
     */
    readonly sort?: string

    /**
     *  Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. 
     */
    readonly pagelen?: number
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPost operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPostRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The contents of the task
     */
    readonly body: PullrequestTaskCreate
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDelete operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDeleteRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * The ID of the task.
     */
    readonly taskId: number

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGet operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGetRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * The ID of the task.
     */
    readonly taskId: number

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut operation in PullrequestsApi.
 */
export interface PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPutRequest {
    /**
     * The id of the pull request.
     */
    readonly pullRequestId: number

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * The ID of the task.
     */
    readonly taskId: number

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The updated state and content of the task.
     */
    readonly body: PullrequestTaskUpdate
}

/**
 * Request parameters for workspacesWorkspacePullrequestsSelectedUserGet operation in PullrequestsApi.
 */
export interface PullrequestsApiWorkspacesWorkspacePullrequestsSelectedUserGetRequest {
    /**
     * This can either be the username of the pull request author, the author\&#39;s UUID surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, or the author\&#39;s Atlassian ID. 
     */
    readonly selectedUser: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * Only return pull requests that are in this state. This parameter can be repeated.
     */
    readonly state?: WorkspacesWorkspacePullrequestsSelectedUserGetStateEnum
}

/**
 * PullrequestsApi - object-oriented interface
 */
export class PullrequestsApi extends BaseAPI implements PullrequestsApiInterface {
    /**
     * Returns a paginated list of all pull requests as part of which this commit was reviewed. Pull Request Commit Links app must be installed first before using this API; installation automatically occurs when \'Go to pull request\' is clicked from the web interface for a commit\'s details.
     * @summary List pull requests that contain a commit
     * @param {PullrequestsApiGetPullrequestsForCommitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPullrequestsForCommit(requestParameters: PullrequestsApiGetPullrequestsForCommitRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).getPullrequestsForCommit(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.page, requestParameters.pagelen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the repository\'s default reviewers.  These are the users that are automatically added as reviewers on every new pull request that is created. To obtain the repository\'s default reviewers as well as the default reviewers inherited from the project, use the [effective-default-reveiwers](#api-repositories-workspace-repo-slug-effective-default-reviewers-get) endpoint.
     * @summary List default reviewers
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDefaultReviewersGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDefaultReviewersGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a default reviewer from the repository.
     * @summary Remove a user from the default reviewers
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete(requestParameters.repoSlug, requestParameters.targetUsername, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified reviewer.  This can be used to test whether a user is among the repository\'s default reviewers list. A 404 indicates that that specified user is not a default reviewer.
     * @summary Get a default reviewer
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet(requestParameters.repoSlug, requestParameters.targetUsername, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds the specified user to the repository\'s list of default reviewers.  This method is idempotent. Adding a user a second time has no effect.
     * @summary Add a user to the default reviewers
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut(requestParameters.repoSlug, requestParameters.targetUsername, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the repository\'s effective default reviewers. This includes both default reviewers defined at the repository level as well as those inherited from its project.  These are the users that are automatically added as reviewers on every new pull request that is created.
     * @summary List effective default reviewers
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugEffectiveDefaultReviewersGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of the pull request\'s activity log.  This handler serves both a v20 and internal endpoint. The v20 endpoint returns reviewer comments, updates, approvals and request changes. The internal endpoint includes those plus tasks and attachments.  Comments created on a file or a line of code have an inline property.  Comment example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"comment\": {                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\"                     }                 },                 \"deleted\": false,                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"content\": {                     \"raw\": \"inline with to a dn from lines\",                     \"markup\": \"markdown\",                     \"html\": \"<p>inline with to a dn from lines</p>\",                     \"type\": \"rendered\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"updated_on\": \"2019-09-27T00:33:46.055384+00:00\",                 \"inline\": {                     \"context_lines\": \"\",                     \"to\": null,                     \"path\": \"\",                     \"outdated\": false,                     \"from\": 211                 },                 \"type\": \"pullrequest_comment\",                 \"id\": 118571088             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Updates include a state property of OPEN, MERGED, or DECLINED.  Update example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"update\": {                 \"description\": \"\",                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\",                 \"destination\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"6a2c16e4a152\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\"                             }                         }                     },                     \"branch\": {                         \"name\": \"master\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"reason\": \"\",                 \"source\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"728c8bad1813\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\"                             }                         }                     },                     \"branch\": {                         \"name\": \"username/NONE-add-onClick-prop-for-accessibility\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"state\": \"OPEN\",                 \"author\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"date\": \"2019-05-10T06:48:25.305565+00:00\"             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Approval example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"approval\": {                 \"date\": \"2019-09-27T00:37:19.849534+00:00\",                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 }             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```
     * @summary List a pull request activity log
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsActivityGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsActivityGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all pull requests on the specified repository.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary List pull requests
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new pull request where the destination repository is this repository and the author is the authenticated user.  The minimum required fields to create a pull request are `title` and `source`, specified by a branch name.  ``` curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repository/pullrequests \\     -u my-username:my-password \\     --request POST \\     --header \'Content-Type: application/json\' \\     --data \'{         \"title\": \"My Title\",         \"source\": {             \"branch\": {                 \"name\": \"staging\"             }         }     }\' ```  If the pull request\'s `destination` is not specified, it will default to the `repository.mainbranch`. To open a pull request to a different branch, say from a feature branch to a staging branch, specify a `destination` (same format as the `source`):  ``` {     \"title\": \"My Title\",     \"source\": {         \"branch\": {             \"name\": \"my-feature-branch\"         }     },     \"destination\": {         \"branch\": {             \"name\": \"staging\"         }     } } ```  Reviewers can be specified by adding an array of user objects as the `reviewers` property.  ``` {     \"title\": \"My Title\",     \"source\": {         \"branch\": {             \"name\": \"my-feature-branch\"         }     },     \"reviewers\": [         {             \"uuid\": \"{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\"         }     ] } ```  Other fields:  * `description` - a string * `close_source_branch` - boolean that specifies if the source branch should be closed upon merging * `draft` - boolean that specifies whether the pull request is a draft
     * @summary Create a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of the pull request\'s activity log.  This handler serves both a v20 and internal endpoint. The v20 endpoint returns reviewer comments, updates, approvals and request changes. The internal endpoint includes those plus tasks and attachments.  Comments created on a file or a line of code have an inline property.  Comment example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"comment\": {                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\"                     }                 },                 \"deleted\": false,                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"content\": {                     \"raw\": \"inline with to a dn from lines\",                     \"markup\": \"markdown\",                     \"html\": \"<p>inline with to a dn from lines</p>\",                     \"type\": \"rendered\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"created_on\": \"2019-09-27T00:33:46.039178+00:00\",                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"updated_on\": \"2019-09-27T00:33:46.055384+00:00\",                 \"inline\": {                     \"context_lines\": \"\",                     \"to\": null,                     \"path\": \"\",                     \"outdated\": false,                     \"from\": 211                 },                 \"type\": \"pullrequest_comment\",                 \"id\": 118571088             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Updates include a state property of OPEN, MERGED, or DECLINED.  Update example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"update\": {                 \"description\": \"\",                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\",                 \"destination\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"6a2c16e4a152\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\"                             }                         }                     },                     \"branch\": {                         \"name\": \"master\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"reason\": \"\",                 \"source\": {                     \"commit\": {                         \"type\": \"commit\",                         \"hash\": \"728c8bad1813\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\"                             }                         }                     },                     \"branch\": {                         \"name\": \"username/NONE-add-onClick-prop-for-accessibility\"                     },                     \"repository\": {                         \"name\": \"Atlaskit-MK-2\",                         \"type\": \"repository\",                         \"full_name\": \"atlassian/atlaskit-mk-2\",                         \"links\": {                             \"self\": {                                 \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2\"                             },                             \"html\": {                                 \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2\"                             },                             \"avatar\": {                                 \"href\": \"https://bytebucket.org/ravatar/%7B%7D?ts=js\"                             }                         },                         \"uuid\": \"{}\"                     }                 },                 \"state\": \"OPEN\",                 \"author\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 },                 \"date\": \"2019-05-10T06:48:25.305565+00:00\"             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```  Approval example: ``` {     \"pagelen\": 20,     \"values\": [         {             \"approval\": {                 \"date\": \"2019-09-27T00:37:19.849534+00:00\",                 \"pullrequest\": {                     \"type\": \"pullrequest\",                     \"id\": 5695,                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                         }                     },                     \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"                 },                 \"user\": {                     \"display_name\": \"Name Lastname\",                     \"uuid\": \"{}\",                     \"links\": {                         \"self\": {                             \"href\": \"https://api.bitbucket.org/2.0/users/%7B%7D\"                         },                         \"html\": {                             \"href\": \"https://bitbucket.org/%7B%7D/\"                         },                         \"avatar\": {                             \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\"                         }                     },                     \"type\": \"user\",                     \"nickname\": \"Name\",                     \"account_id\": \"\"                 }             },             \"pull_request\": {                 \"type\": \"pullrequest\",                 \"id\": 5695,                 \"links\": {                     \"self\": {                         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\"                     },                     \"html\": {                         \"href\": \"https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\"                     }                 },                 \"title\": \"username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\"             }         }     ] } ```
     * @summary List a pull request activity log
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redact the authenticated user\'s approval of the specified pull request.
     * @summary Unapprove a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Approve the specified pull request as the authenticated user.
     * @summary Approve a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific pull request comment.
     * @summary Delete a comment on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete(requestParameters.commentId, requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific pull request comment.
     * @summary Get a comment on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet(requestParameters.commentId, requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a specific pull request comment.
     * @summary Update a comment on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut(requestParameters.commentId, requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reopen a comment thread
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDeleteRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveDelete(requestParameters.commentId, requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resolve a comment thread
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePostRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolvePost(requestParameters.commentId, requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of the pull request\'s comments.  This includes both global, inline comments and replies.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary List comments on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new pull request comment.  Returns the newly created pull request comment.
     * @summary Create a comment on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of the pull request\'s commits.  These are the commits that are being merged into the destination branch when the pull requests gets accepted.
     * @summary List commits on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Declines the pull request.
     * @summary Decline a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redirects to the [repository diff](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diff-spec-get) with the revspec that corresponds to the pull request.
     * @summary List changes in a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redirects to the [repository diffstat](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diffstat-spec-get) with the revspec that corresponds to the pull request.
     * @summary Get the diff stat for a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified pull request.
     * @summary Get a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Merges the pull request.
     * @summary Merge a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.async, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When merging a pull request takes too long, the client receives a task ID along with a 202 status code. The task ID can be used in a call to this endpoint to check the status of a merge task.  ``` curl -X GET https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id> ```  If the merge task is not yet finished, a PENDING status will be returned.  ``` HTTP/2 200 {     \"task_status\": \"PENDING\",     \"links\": {         \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>\"         }     } } ```  If the merge was successful, a SUCCESS status will be returned.  ``` HTTP/2 200 {     \"task_status\": \"SUCCESS\",     \"links\": {         \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>\"         }     },     \"merge_result\": <the merged pull request object> } ```  If the merge task failed, an error will be returned.  ``` {     \"type\": \"error\",     \"error\": {         \"message\": \"<error message>\"     } } ```
     * @summary Get the merge task status for a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.taskId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redirects to the [repository patch](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-patch-spec-get) with the revspec that corresponds to pull request.
     * @summary Get the patch for a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mutates the specified pull request.  This can be used to change the pull request\'s branches or description.  Only open pull requests can be mutated.
     * @summary Update a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove change request for a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request changes for a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all statuses (e.g. build results) for the given pull request.
     * @summary List commit statuses for a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of the pull request\'s tasks.  This endpoint supports filtering and sorting of the results by the \'task\' field. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary List tasks on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, requestParameters.pagelen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new pull request task.  Returns the newly created pull request task.  Tasks can optionally be created in relation to a comment specified by the comment\'s ID which will cause the task to appear below the comment on a pull request when viewed in Bitbucket.
     * @summary Create a task on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPost(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPostRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksPost(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific pull request task.
     * @summary Delete a task on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDelete(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdDelete(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.taskId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific pull request task.
     * @summary Get a task on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGet(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdGet(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.taskId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a specific pull request task.
     * @summary Update a task on a pull request
     * @param {PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut(requestParameters: PullrequestsApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPutRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdTasksTaskIdPut(requestParameters.pullRequestId, requestParameters.repoSlug, requestParameters.taskId, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all workspace pull requests authored by the specified user.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary List workspace pull requests for a user
     * @param {PullrequestsApiWorkspacesWorkspacePullrequestsSelectedUserGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspacePullrequestsSelectedUserGet(requestParameters: PullrequestsApiWorkspacesWorkspacePullrequestsSelectedUserGetRequest, options?: RawAxiosRequestConfig) {
        return PullrequestsApiFp(this.configuration).workspacesWorkspacePullrequestsSelectedUserGet(requestParameters.selectedUser, requestParameters.workspace, requestParameters.state, options).then((request) => request(this.axios, this.basePath));
    }
}

export const RepositoriesWorkspaceRepoSlugPullrequestsGetStateEnum = {
    Open: 'OPEN',
    Merged: 'MERGED',
    Declined: 'DECLINED',
    Superseded: 'SUPERSEDED'
} as const;
export type RepositoriesWorkspaceRepoSlugPullrequestsGetStateEnum = typeof RepositoriesWorkspaceRepoSlugPullrequestsGetStateEnum[keyof typeof RepositoriesWorkspaceRepoSlugPullrequestsGetStateEnum];
export const WorkspacesWorkspacePullrequestsSelectedUserGetStateEnum = {
    Open: 'OPEN',
    Merged: 'MERGED',
    Declined: 'DECLINED',
    Superseded: 'SUPERSEDED'
} as const;
export type WorkspacesWorkspacePullrequestsSelectedUserGetStateEnum = typeof WorkspacesWorkspacePullrequestsSelectedUserGetStateEnum[keyof typeof WorkspacesWorkspacePullrequestsSelectedUserGetStateEnum];


/**
 * RefsApi - axios parameter creator
 */
export const RefsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all open branches within the specified repository. Results will be in the order the source control manager returns them.  Branches support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that can be used to search for specific branches. For instance, to find all branches that have \"stab\" in their name:  ``` curl -s https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches -G --data-urlencode \'q=name ~ \"stab\"\' ```  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git branch --list\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are sorted [\"v10\", \"v11\", \"v9\"] instead of [\"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?q= query parameter. When using ?q=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
         * @summary List open branches
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). The &#x60;name&#x60; field is handled specially for branches in that, if specified as the sort field, it uses a natural sort order instead of the default lexicographical sort order. For example, it will return [\&#39;branch1\&#39;, \&#39;branch2\&#39;, \&#39;branch10\&#39;] instead of [\&#39;branch1\&#39;, \&#39;branch10\&#39;, \&#39;branch2\&#39;].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsBranchesGet: async (repoSlug: string, workspace: string, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsBranchesGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsBranchesGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/refs/branches`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a branch in the specified repository.  The main branch is not allowed to be deleted and will return a 400 response.  The branch name should not include any prefixes (e.g. refs/heads).
         * @summary Delete a branch
         * @param {string} name The name of the branch.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsBranchesNameDelete: async (name: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsBranchesNameDelete', 'name', name)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsBranchesNameDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsBranchesNameDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/refs/branches/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a branch object within the specified repository.  This call requires authentication. Private repositories require the caller to authenticate with an account that has appropriate authorization.  For Git, the branch name should not include any prefixes (e.g. refs/heads).
         * @summary Get a branch
         * @param {string} name The name of the branch.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsBranchesNameGet: async (name: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsBranchesNameGet', 'name', name)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsBranchesNameGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsBranchesNameGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/refs/branches/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new branch in the specified repository.  The payload of the POST should consist of a JSON document that contains the name of the tag and the target hash.  ``` curl https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/branches \\ -s -u seanfarley -X POST -H \"Content-Type: application/json\" \\ -d \'{     \"name\" : \"smf/create-feature\",     \"target\" : {         \"hash\" : \"default\",     } }\' ```  This call requires authentication. Private repositories require the caller to authenticate with an account that has appropriate authorization.  The branch name should not include any prefixes (e.g. refs/heads). This endpoint does support using short hash prefixes for the commit hash, but it may return a 400 response if the provided prefix is ambiguous. Using a full commit hash is the preferred approach.
         * @summary Create a branch
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsBranchesPost: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsBranchesPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsBranchesPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/refs/branches`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the branches and tags in the repository.  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git show-ref\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that refs are sorted [\"branch1\", \"branch10\", \"branch2\", \"v10\", \"v11\", \"v9\"] instead of [\"branch1\", \"branch2\", \"branch10\", \"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
         * @summary List branches and tags
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). The &#x60;name&#x60; field is handled specially for refs in that, if specified as the sort field, it uses a natural sort order instead of the default lexicographical sort order. For example, it will return [\&#39;1.1\&#39;, \&#39;1.2\&#39;, \&#39;1.10\&#39;] instead of [\&#39;1.1\&#39;, \&#39;1.10\&#39;, \&#39;1.2\&#39;].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsGet: async (repoSlug: string, workspace: string, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/refs`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the tags in the repository.  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git tag --list\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are sorted [\"v10\", \"v11\", \"v9\"] instead of [\"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
         * @summary List tags
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). The &#x60;name&#x60; field is handled specially for tags in that, if specified as the sort field, it uses a natural sort order instead of the default lexicographical sort order. For example, it will return [\&#39;1.1\&#39;, \&#39;1.2\&#39;, \&#39;1.10\&#39;] instead of [\&#39;1.1\&#39;, \&#39;1.10\&#39;, \&#39;1.2\&#39;].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsTagsGet: async (repoSlug: string, workspace: string, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsTagsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsTagsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/refs/tags`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag in the specified repository.  The tag name should not include any prefixes (e.g. refs/tags).
         * @summary Delete a tag
         * @param {string} name The name of the tag.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsTagsNameDelete: async (name: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsTagsNameDelete', 'name', name)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsTagsNameDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsTagsNameDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/refs/tags/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified tag.  ``` $ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8 -G | jq . {   \"name\": \"3.8\",   \"links\": {     \"commits\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commits/3.8\"     },     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8\"     },     \"html\": {       \"href\": \"https://bitbucket.org/seanfarley/hg/commits/tag/3.8\"     }   },   \"tagger\": {     \"raw\": \"Matt Mackall <mpm@selenic.com>\",     \"type\": \"author\",     \"user\": {       \"username\": \"mpmselenic\",       \"nickname\": \"mpmselenic\",       \"display_name\": \"Matt Mackall\",       \"type\": \"user\",       \"uuid\": \"{a4934530-db4c-419c-a478-9ab4964c2ee7}\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/users/mpmselenic\"         },         \"html\": {           \"href\": \"https://bitbucket.org/mpmselenic/\"         },         \"avatar\": {           \"href\": \"https://bitbucket.org/account/mpmselenic/avatar/32/\"         }       }     }   },   \"date\": \"2016-05-01T18:52:25+00:00\",   \"message\": \"Added tag 3.8 for changeset f85de28eae32\",   \"type\": \"tag\",   \"target\": {     \"hash\": \"f85de28eae32e7d3064b1a1321309071bbaaa069\",     \"repository\": {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg\"         },         \"html\": {           \"href\": \"https://bitbucket.org/seanfarley/hg\"         },         \"avatar\": {           \"href\": \"https://bitbucket.org/seanfarley/hg/avatar/32/\"         }       },       \"type\": \"repository\",       \"name\": \"hg\",       \"full_name\": \"seanfarley/hg\",       \"uuid\": \"{c75687fb-e99d-4579-9087-190dbd406d30}\"     },     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"comments\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/comments\"       },       \"patch\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/patch/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"html\": {         \"href\": \"https://bitbucket.org/seanfarley/hg/commits/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"diff\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/diff/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"approve\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/approve\"       },       \"statuses\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/statuses\"       }     },     \"author\": {       \"raw\": \"Sean Farley <sean@farley.io>\",       \"type\": \"author\",       \"user\": {         \"username\": \"seanfarley\",         \"nickname\": \"seanfarley\",         \"display_name\": \"Sean Farley\",         \"type\": \"user\",         \"uuid\": \"{a295f8a8-5876-4d43-89b5-3ad8c6c3c51d}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/seanfarley\"           },           \"html\": {             \"href\": \"https://bitbucket.org/seanfarley/\"           },           \"avatar\": {             \"href\": \"https://bitbucket.org/account/seanfarley/avatar/32/\"           }         }       }     },     \"parents\": [       {         \"hash\": \"9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\",         \"type\": \"commit\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\"           },           \"html\": {             \"href\": \"https://bitbucket.org/seanfarley/hg/commits/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\"           }         }       }     ],     \"date\": \"2016-05-01T04:21:17+00:00\",     \"message\": \"debian: alphabetize build deps\",     \"type\": \"commit\"   } } ```
         * @summary Get a tag
         * @param {string} name The name of the tag.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsTagsNameGet: async (name: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsTagsNameGet', 'name', name)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsTagsNameGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsTagsNameGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/refs/tags/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new tag in the specified repository.  The payload of the POST should consist of a JSON document that contains the name of the tag and the target hash.  ``` curl https://api.bitbucket.org/2.0/repositories/jdoe/myrepo/refs/tags \\ -s -u jdoe -X POST -H \"Content-Type: application/json\" \\ -d \'{     \"name\" : \"new-tag-name\",     \"target\" : {         \"hash\" : \"a1b2c3d4e5f6\",     } }\' ```  This endpoint does support using short hash prefixes for the commit hash, but it may return a 400 response if the provided prefix is ambiguous. Using a full commit hash is the preferred approach.
         * @summary Create a tag
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Tag} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsTagsPost: async (repoSlug: string, workspace: string, body: Tag, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsTagsPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsTagsPost', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugRefsTagsPost', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/refs/tags`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefsApi - functional programming interface
 */
export const RefsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RefsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all open branches within the specified repository. Results will be in the order the source control manager returns them.  Branches support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that can be used to search for specific branches. For instance, to find all branches that have \"stab\" in their name:  ``` curl -s https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches -G --data-urlencode \'q=name ~ \"stab\"\' ```  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git branch --list\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are sorted [\"v10\", \"v11\", \"v9\"] instead of [\"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?q= query parameter. When using ?q=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
         * @summary List open branches
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). The &#x60;name&#x60; field is handled specially for branches in that, if specified as the sort field, it uses a natural sort order instead of the default lexicographical sort order. For example, it will return [\&#39;branch1\&#39;, \&#39;branch2\&#39;, \&#39;branch10\&#39;] instead of [\&#39;branch1\&#39;, \&#39;branch10\&#39;, \&#39;branch2\&#39;].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugRefsBranchesGet(repoSlug: string, workspace: string, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBranches>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugRefsBranchesGet(repoSlug, workspace, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefsApi.repositoriesWorkspaceRepoSlugRefsBranchesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a branch in the specified repository.  The main branch is not allowed to be deleted and will return a 400 response.  The branch name should not include any prefixes (e.g. refs/heads).
         * @summary Delete a branch
         * @param {string} name The name of the branch.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugRefsBranchesNameDelete(name: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugRefsBranchesNameDelete(name, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefsApi.repositoriesWorkspaceRepoSlugRefsBranchesNameDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a branch object within the specified repository.  This call requires authentication. Private repositories require the caller to authenticate with an account that has appropriate authorization.  For Git, the branch name should not include any prefixes (e.g. refs/heads).
         * @summary Get a branch
         * @param {string} name The name of the branch.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugRefsBranchesNameGet(name: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugRefsBranchesNameGet(name, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefsApi.repositoriesWorkspaceRepoSlugRefsBranchesNameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new branch in the specified repository.  The payload of the POST should consist of a JSON document that contains the name of the tag and the target hash.  ``` curl https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/branches \\ -s -u seanfarley -X POST -H \"Content-Type: application/json\" \\ -d \'{     \"name\" : \"smf/create-feature\",     \"target\" : {         \"hash\" : \"default\",     } }\' ```  This call requires authentication. Private repositories require the caller to authenticate with an account that has appropriate authorization.  The branch name should not include any prefixes (e.g. refs/heads). This endpoint does support using short hash prefixes for the commit hash, but it may return a 400 response if the provided prefix is ambiguous. Using a full commit hash is the preferred approach.
         * @summary Create a branch
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugRefsBranchesPost(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugRefsBranchesPost(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefsApi.repositoriesWorkspaceRepoSlugRefsBranchesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the branches and tags in the repository.  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git show-ref\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that refs are sorted [\"branch1\", \"branch10\", \"branch2\", \"v10\", \"v11\", \"v9\"] instead of [\"branch1\", \"branch2\", \"branch10\", \"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
         * @summary List branches and tags
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). The &#x60;name&#x60; field is handled specially for refs in that, if specified as the sort field, it uses a natural sort order instead of the default lexicographical sort order. For example, it will return [\&#39;1.1\&#39;, \&#39;1.2\&#39;, \&#39;1.10\&#39;] instead of [\&#39;1.1\&#39;, \&#39;1.10\&#39;, \&#39;1.2\&#39;].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugRefsGet(repoSlug: string, workspace: string, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRefs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugRefsGet(repoSlug, workspace, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefsApi.repositoriesWorkspaceRepoSlugRefsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the tags in the repository.  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git tag --list\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are sorted [\"v10\", \"v11\", \"v9\"] instead of [\"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
         * @summary List tags
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). The &#x60;name&#x60; field is handled specially for tags in that, if specified as the sort field, it uses a natural sort order instead of the default lexicographical sort order. For example, it will return [\&#39;1.1\&#39;, \&#39;1.2\&#39;, \&#39;1.10\&#39;] instead of [\&#39;1.1\&#39;, \&#39;1.10\&#39;, \&#39;1.2\&#39;].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugRefsTagsGet(repoSlug: string, workspace: string, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugRefsTagsGet(repoSlug, workspace, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefsApi.repositoriesWorkspaceRepoSlugRefsTagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a tag in the specified repository.  The tag name should not include any prefixes (e.g. refs/tags).
         * @summary Delete a tag
         * @param {string} name The name of the tag.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugRefsTagsNameDelete(name: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugRefsTagsNameDelete(name, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefsApi.repositoriesWorkspaceRepoSlugRefsTagsNameDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specified tag.  ``` $ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8 -G | jq . {   \"name\": \"3.8\",   \"links\": {     \"commits\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commits/3.8\"     },     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8\"     },     \"html\": {       \"href\": \"https://bitbucket.org/seanfarley/hg/commits/tag/3.8\"     }   },   \"tagger\": {     \"raw\": \"Matt Mackall <mpm@selenic.com>\",     \"type\": \"author\",     \"user\": {       \"username\": \"mpmselenic\",       \"nickname\": \"mpmselenic\",       \"display_name\": \"Matt Mackall\",       \"type\": \"user\",       \"uuid\": \"{a4934530-db4c-419c-a478-9ab4964c2ee7}\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/users/mpmselenic\"         },         \"html\": {           \"href\": \"https://bitbucket.org/mpmselenic/\"         },         \"avatar\": {           \"href\": \"https://bitbucket.org/account/mpmselenic/avatar/32/\"         }       }     }   },   \"date\": \"2016-05-01T18:52:25+00:00\",   \"message\": \"Added tag 3.8 for changeset f85de28eae32\",   \"type\": \"tag\",   \"target\": {     \"hash\": \"f85de28eae32e7d3064b1a1321309071bbaaa069\",     \"repository\": {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg\"         },         \"html\": {           \"href\": \"https://bitbucket.org/seanfarley/hg\"         },         \"avatar\": {           \"href\": \"https://bitbucket.org/seanfarley/hg/avatar/32/\"         }       },       \"type\": \"repository\",       \"name\": \"hg\",       \"full_name\": \"seanfarley/hg\",       \"uuid\": \"{c75687fb-e99d-4579-9087-190dbd406d30}\"     },     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"comments\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/comments\"       },       \"patch\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/patch/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"html\": {         \"href\": \"https://bitbucket.org/seanfarley/hg/commits/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"diff\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/diff/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"approve\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/approve\"       },       \"statuses\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/statuses\"       }     },     \"author\": {       \"raw\": \"Sean Farley <sean@farley.io>\",       \"type\": \"author\",       \"user\": {         \"username\": \"seanfarley\",         \"nickname\": \"seanfarley\",         \"display_name\": \"Sean Farley\",         \"type\": \"user\",         \"uuid\": \"{a295f8a8-5876-4d43-89b5-3ad8c6c3c51d}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/seanfarley\"           },           \"html\": {             \"href\": \"https://bitbucket.org/seanfarley/\"           },           \"avatar\": {             \"href\": \"https://bitbucket.org/account/seanfarley/avatar/32/\"           }         }       }     },     \"parents\": [       {         \"hash\": \"9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\",         \"type\": \"commit\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\"           },           \"html\": {             \"href\": \"https://bitbucket.org/seanfarley/hg/commits/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\"           }         }       }     ],     \"date\": \"2016-05-01T04:21:17+00:00\",     \"message\": \"debian: alphabetize build deps\",     \"type\": \"commit\"   } } ```
         * @summary Get a tag
         * @param {string} name The name of the tag.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugRefsTagsNameGet(name: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugRefsTagsNameGet(name, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefsApi.repositoriesWorkspaceRepoSlugRefsTagsNameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new tag in the specified repository.  The payload of the POST should consist of a JSON document that contains the name of the tag and the target hash.  ``` curl https://api.bitbucket.org/2.0/repositories/jdoe/myrepo/refs/tags \\ -s -u jdoe -X POST -H \"Content-Type: application/json\" \\ -d \'{     \"name\" : \"new-tag-name\",     \"target\" : {         \"hash\" : \"a1b2c3d4e5f6\",     } }\' ```  This endpoint does support using short hash prefixes for the commit hash, but it may return a 400 response if the provided prefix is ambiguous. Using a full commit hash is the preferred approach.
         * @summary Create a tag
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Tag} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugRefsTagsPost(repoSlug: string, workspace: string, body: Tag, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugRefsTagsPost(repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefsApi.repositoriesWorkspaceRepoSlugRefsTagsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RefsApi - factory interface
 */
export const RefsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RefsApiFp(configuration)
    return {
        /**
         * Returns a list of all open branches within the specified repository. Results will be in the order the source control manager returns them.  Branches support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that can be used to search for specific branches. For instance, to find all branches that have \"stab\" in their name:  ``` curl -s https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches -G --data-urlencode \'q=name ~ \"stab\"\' ```  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git branch --list\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are sorted [\"v10\", \"v11\", \"v9\"] instead of [\"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?q= query parameter. When using ?q=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
         * @summary List open branches
         * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsBranchesGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedBranches> {
            return localVarFp.repositoriesWorkspaceRepoSlugRefsBranchesGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a branch in the specified repository.  The main branch is not allowed to be deleted and will return a 400 response.  The branch name should not include any prefixes (e.g. refs/heads).
         * @summary Delete a branch
         * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsBranchesNameDelete(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugRefsBranchesNameDelete(requestParameters.name, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a branch object within the specified repository.  This call requires authentication. Private repositories require the caller to authenticate with an account that has appropriate authorization.  For Git, the branch name should not include any prefixes (e.g. refs/heads).
         * @summary Get a branch
         * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesNameGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsBranchesNameGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesNameGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Branch> {
            return localVarFp.repositoriesWorkspaceRepoSlugRefsBranchesNameGet(requestParameters.name, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new branch in the specified repository.  The payload of the POST should consist of a JSON document that contains the name of the tag and the target hash.  ``` curl https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/branches \\ -s -u seanfarley -X POST -H \"Content-Type: application/json\" \\ -d \'{     \"name\" : \"smf/create-feature\",     \"target\" : {         \"hash\" : \"default\",     } }\' ```  This call requires authentication. Private repositories require the caller to authenticate with an account that has appropriate authorization.  The branch name should not include any prefixes (e.g. refs/heads). This endpoint does support using short hash prefixes for the commit hash, but it may return a 400 response if the provided prefix is ambiguous. Using a full commit hash is the preferred approach.
         * @summary Create a branch
         * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsBranchesPost(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Branch> {
            return localVarFp.repositoriesWorkspaceRepoSlugRefsBranchesPost(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the branches and tags in the repository.  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git show-ref\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that refs are sorted [\"branch1\", \"branch10\", \"branch2\", \"v10\", \"v11\", \"v9\"] instead of [\"branch1\", \"branch2\", \"branch10\", \"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
         * @summary List branches and tags
         * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRefs> {
            return localVarFp.repositoriesWorkspaceRepoSlugRefsGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the tags in the repository.  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git tag --list\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are sorted [\"v10\", \"v11\", \"v9\"] instead of [\"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
         * @summary List tags
         * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsTagsGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTags> {
            return localVarFp.repositoriesWorkspaceRepoSlugRefsTagsGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tag in the specified repository.  The tag name should not include any prefixes (e.g. refs/tags).
         * @summary Delete a tag
         * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsTagsNameDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsTagsNameDelete(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsTagsNameDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugRefsTagsNameDelete(requestParameters.name, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified tag.  ``` $ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8 -G | jq . {   \"name\": \"3.8\",   \"links\": {     \"commits\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commits/3.8\"     },     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8\"     },     \"html\": {       \"href\": \"https://bitbucket.org/seanfarley/hg/commits/tag/3.8\"     }   },   \"tagger\": {     \"raw\": \"Matt Mackall <mpm@selenic.com>\",     \"type\": \"author\",     \"user\": {       \"username\": \"mpmselenic\",       \"nickname\": \"mpmselenic\",       \"display_name\": \"Matt Mackall\",       \"type\": \"user\",       \"uuid\": \"{a4934530-db4c-419c-a478-9ab4964c2ee7}\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/users/mpmselenic\"         },         \"html\": {           \"href\": \"https://bitbucket.org/mpmselenic/\"         },         \"avatar\": {           \"href\": \"https://bitbucket.org/account/mpmselenic/avatar/32/\"         }       }     }   },   \"date\": \"2016-05-01T18:52:25+00:00\",   \"message\": \"Added tag 3.8 for changeset f85de28eae32\",   \"type\": \"tag\",   \"target\": {     \"hash\": \"f85de28eae32e7d3064b1a1321309071bbaaa069\",     \"repository\": {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg\"         },         \"html\": {           \"href\": \"https://bitbucket.org/seanfarley/hg\"         },         \"avatar\": {           \"href\": \"https://bitbucket.org/seanfarley/hg/avatar/32/\"         }       },       \"type\": \"repository\",       \"name\": \"hg\",       \"full_name\": \"seanfarley/hg\",       \"uuid\": \"{c75687fb-e99d-4579-9087-190dbd406d30}\"     },     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"comments\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/comments\"       },       \"patch\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/patch/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"html\": {         \"href\": \"https://bitbucket.org/seanfarley/hg/commits/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"diff\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/diff/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"approve\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/approve\"       },       \"statuses\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/statuses\"       }     },     \"author\": {       \"raw\": \"Sean Farley <sean@farley.io>\",       \"type\": \"author\",       \"user\": {         \"username\": \"seanfarley\",         \"nickname\": \"seanfarley\",         \"display_name\": \"Sean Farley\",         \"type\": \"user\",         \"uuid\": \"{a295f8a8-5876-4d43-89b5-3ad8c6c3c51d}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/seanfarley\"           },           \"html\": {             \"href\": \"https://bitbucket.org/seanfarley/\"           },           \"avatar\": {             \"href\": \"https://bitbucket.org/account/seanfarley/avatar/32/\"           }         }       }     },     \"parents\": [       {         \"hash\": \"9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\",         \"type\": \"commit\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\"           },           \"html\": {             \"href\": \"https://bitbucket.org/seanfarley/hg/commits/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\"           }         }       }     ],     \"date\": \"2016-05-01T04:21:17+00:00\",     \"message\": \"debian: alphabetize build deps\",     \"type\": \"commit\"   } } ```
         * @summary Get a tag
         * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsTagsNameGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsTagsNameGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsTagsNameGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.repositoriesWorkspaceRepoSlugRefsTagsNameGet(requestParameters.name, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new tag in the specified repository.  The payload of the POST should consist of a JSON document that contains the name of the tag and the target hash.  ``` curl https://api.bitbucket.org/2.0/repositories/jdoe/myrepo/refs/tags \\ -s -u jdoe -X POST -H \"Content-Type: application/json\" \\ -d \'{     \"name\" : \"new-tag-name\",     \"target\" : {         \"hash\" : \"a1b2c3d4e5f6\",     } }\' ```  This endpoint does support using short hash prefixes for the commit hash, but it may return a 400 response if the provided prefix is ambiguous. Using a full commit hash is the preferred approach.
         * @summary Create a tag
         * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugRefsTagsPost(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.repositoriesWorkspaceRepoSlugRefsTagsPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RefsApi - interface
 */
export interface RefsApiInterface {
    /**
     * Returns a list of all open branches within the specified repository. Results will be in the order the source control manager returns them.  Branches support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that can be used to search for specific branches. For instance, to find all branches that have \"stab\" in their name:  ``` curl -s https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches -G --data-urlencode \'q=name ~ \"stab\"\' ```  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git branch --list\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are sorted [\"v10\", \"v11\", \"v9\"] instead of [\"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?q= query parameter. When using ?q=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
     * @summary List open branches
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugRefsBranchesGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedBranches>;

    /**
     * Delete a branch in the specified repository.  The main branch is not allowed to be deleted and will return a 400 response.  The branch name should not include any prefixes (e.g. refs/heads).
     * @summary Delete a branch
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugRefsBranchesNameDelete(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a branch object within the specified repository.  This call requires authentication. Private repositories require the caller to authenticate with an account that has appropriate authorization.  For Git, the branch name should not include any prefixes (e.g. refs/heads).
     * @summary Get a branch
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugRefsBranchesNameGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesNameGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Branch>;

    /**
     * Creates a new branch in the specified repository.  The payload of the POST should consist of a JSON document that contains the name of the tag and the target hash.  ``` curl https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/branches \\ -s -u seanfarley -X POST -H \"Content-Type: application/json\" \\ -d \'{     \"name\" : \"smf/create-feature\",     \"target\" : {         \"hash\" : \"default\",     } }\' ```  This call requires authentication. Private repositories require the caller to authenticate with an account that has appropriate authorization.  The branch name should not include any prefixes (e.g. refs/heads). This endpoint does support using short hash prefixes for the commit hash, but it may return a 400 response if the provided prefix is ambiguous. Using a full commit hash is the preferred approach.
     * @summary Create a branch
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugRefsBranchesPost(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Branch>;

    /**
     * Returns the branches and tags in the repository.  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git show-ref\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that refs are sorted [\"branch1\", \"branch10\", \"branch2\", \"v10\", \"v11\", \"v9\"] instead of [\"branch1\", \"branch2\", \"branch10\", \"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
     * @summary List branches and tags
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugRefsGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRefs>;

    /**
     * Returns the tags in the repository.  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git tag --list\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are sorted [\"v10\", \"v11\", \"v9\"] instead of [\"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
     * @summary List tags
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugRefsTagsGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTags>;

    /**
     * Delete a tag in the specified repository.  The tag name should not include any prefixes (e.g. refs/tags).
     * @summary Delete a tag
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsTagsNameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugRefsTagsNameDelete(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsTagsNameDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the specified tag.  ``` $ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8 -G | jq . {   \"name\": \"3.8\",   \"links\": {     \"commits\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commits/3.8\"     },     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8\"     },     \"html\": {       \"href\": \"https://bitbucket.org/seanfarley/hg/commits/tag/3.8\"     }   },   \"tagger\": {     \"raw\": \"Matt Mackall <mpm@selenic.com>\",     \"type\": \"author\",     \"user\": {       \"username\": \"mpmselenic\",       \"nickname\": \"mpmselenic\",       \"display_name\": \"Matt Mackall\",       \"type\": \"user\",       \"uuid\": \"{a4934530-db4c-419c-a478-9ab4964c2ee7}\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/users/mpmselenic\"         },         \"html\": {           \"href\": \"https://bitbucket.org/mpmselenic/\"         },         \"avatar\": {           \"href\": \"https://bitbucket.org/account/mpmselenic/avatar/32/\"         }       }     }   },   \"date\": \"2016-05-01T18:52:25+00:00\",   \"message\": \"Added tag 3.8 for changeset f85de28eae32\",   \"type\": \"tag\",   \"target\": {     \"hash\": \"f85de28eae32e7d3064b1a1321309071bbaaa069\",     \"repository\": {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg\"         },         \"html\": {           \"href\": \"https://bitbucket.org/seanfarley/hg\"         },         \"avatar\": {           \"href\": \"https://bitbucket.org/seanfarley/hg/avatar/32/\"         }       },       \"type\": \"repository\",       \"name\": \"hg\",       \"full_name\": \"seanfarley/hg\",       \"uuid\": \"{c75687fb-e99d-4579-9087-190dbd406d30}\"     },     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"comments\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/comments\"       },       \"patch\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/patch/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"html\": {         \"href\": \"https://bitbucket.org/seanfarley/hg/commits/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"diff\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/diff/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"approve\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/approve\"       },       \"statuses\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/statuses\"       }     },     \"author\": {       \"raw\": \"Sean Farley <sean@farley.io>\",       \"type\": \"author\",       \"user\": {         \"username\": \"seanfarley\",         \"nickname\": \"seanfarley\",         \"display_name\": \"Sean Farley\",         \"type\": \"user\",         \"uuid\": \"{a295f8a8-5876-4d43-89b5-3ad8c6c3c51d}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/seanfarley\"           },           \"html\": {             \"href\": \"https://bitbucket.org/seanfarley/\"           },           \"avatar\": {             \"href\": \"https://bitbucket.org/account/seanfarley/avatar/32/\"           }         }       }     },     \"parents\": [       {         \"hash\": \"9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\",         \"type\": \"commit\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\"           },           \"html\": {             \"href\": \"https://bitbucket.org/seanfarley/hg/commits/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\"           }         }       }     ],     \"date\": \"2016-05-01T04:21:17+00:00\",     \"message\": \"debian: alphabetize build deps\",     \"type\": \"commit\"   } } ```
     * @summary Get a tag
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsTagsNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugRefsTagsNameGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsTagsNameGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag>;

    /**
     * Creates a new tag in the specified repository.  The payload of the POST should consist of a JSON document that contains the name of the tag and the target hash.  ``` curl https://api.bitbucket.org/2.0/repositories/jdoe/myrepo/refs/tags \\ -s -u jdoe -X POST -H \"Content-Type: application/json\" \\ -d \'{     \"name\" : \"new-tag-name\",     \"target\" : {         \"hash\" : \"a1b2c3d4e5f6\",     } }\' ```  This endpoint does support using short hash prefixes for the commit hash, but it may return a 400 response if the provided prefix is ambiguous. Using a full commit hash is the preferred approach.
     * @summary Create a tag
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugRefsTagsPost(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag>;

}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugRefsBranchesGet operation in RefsApi.
 */
export interface RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     *  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
     */
    readonly q?: string

    /**
     *  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). The &#x60;name&#x60; field is handled specially for branches in that, if specified as the sort field, it uses a natural sort order instead of the default lexicographical sort order. For example, it will return [\&#39;branch1\&#39;, \&#39;branch2\&#39;, \&#39;branch10\&#39;] instead of [\&#39;branch1\&#39;, \&#39;branch10\&#39;, \&#39;branch2\&#39;].
     */
    readonly sort?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugRefsBranchesNameDelete operation in RefsApi.
 */
export interface RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteRequest {
    /**
     * The name of the branch.
     */
    readonly name: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugRefsBranchesNameGet operation in RefsApi.
 */
export interface RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesNameGetRequest {
    /**
     * The name of the branch.
     */
    readonly name: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugRefsBranchesPost operation in RefsApi.
 */
export interface RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugRefsGet operation in RefsApi.
 */
export interface RefsApiRepositoriesWorkspaceRepoSlugRefsGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     *  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
     */
    readonly q?: string

    /**
     *  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). The &#x60;name&#x60; field is handled specially for refs in that, if specified as the sort field, it uses a natural sort order instead of the default lexicographical sort order. For example, it will return [\&#39;1.1\&#39;, \&#39;1.2\&#39;, \&#39;1.10\&#39;] instead of [\&#39;1.1\&#39;, \&#39;1.10\&#39;, \&#39;1.2\&#39;].
     */
    readonly sort?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugRefsTagsGet operation in RefsApi.
 */
export interface RefsApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     *  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
     */
    readonly q?: string

    /**
     *  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). The &#x60;name&#x60; field is handled specially for tags in that, if specified as the sort field, it uses a natural sort order instead of the default lexicographical sort order. For example, it will return [\&#39;1.1\&#39;, \&#39;1.2\&#39;, \&#39;1.10\&#39;] instead of [\&#39;1.1\&#39;, \&#39;1.10\&#39;, \&#39;1.2\&#39;].
     */
    readonly sort?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugRefsTagsNameDelete operation in RefsApi.
 */
export interface RefsApiRepositoriesWorkspaceRepoSlugRefsTagsNameDeleteRequest {
    /**
     * The name of the tag.
     */
    readonly name: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugRefsTagsNameGet operation in RefsApi.
 */
export interface RefsApiRepositoriesWorkspaceRepoSlugRefsTagsNameGetRequest {
    /**
     * The name of the tag.
     */
    readonly name: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugRefsTagsPost operation in RefsApi.
 */
export interface RefsApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    readonly body: Tag
}

/**
 * RefsApi - object-oriented interface
 */
export class RefsApi extends BaseAPI implements RefsApiInterface {
    /**
     * Returns a list of all open branches within the specified repository. Results will be in the order the source control manager returns them.  Branches support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that can be used to search for specific branches. For instance, to find all branches that have \"stab\" in their name:  ``` curl -s https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches -G --data-urlencode \'q=name ~ \"stab\"\' ```  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git branch --list\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are sorted [\"v10\", \"v11\", \"v9\"] instead of [\"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?q= query parameter. When using ?q=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
     * @summary List open branches
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugRefsBranchesGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest, options?: RawAxiosRequestConfig) {
        return RefsApiFp(this.configuration).repositoriesWorkspaceRepoSlugRefsBranchesGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a branch in the specified repository.  The main branch is not allowed to be deleted and will return a 400 response.  The branch name should not include any prefixes (e.g. refs/heads).
     * @summary Delete a branch
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugRefsBranchesNameDelete(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteRequest, options?: RawAxiosRequestConfig) {
        return RefsApiFp(this.configuration).repositoriesWorkspaceRepoSlugRefsBranchesNameDelete(requestParameters.name, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a branch object within the specified repository.  This call requires authentication. Private repositories require the caller to authenticate with an account that has appropriate authorization.  For Git, the branch name should not include any prefixes (e.g. refs/heads).
     * @summary Get a branch
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugRefsBranchesNameGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesNameGetRequest, options?: RawAxiosRequestConfig) {
        return RefsApiFp(this.configuration).repositoriesWorkspaceRepoSlugRefsBranchesNameGet(requestParameters.name, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new branch in the specified repository.  The payload of the POST should consist of a JSON document that contains the name of the tag and the target hash.  ``` curl https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/branches \\ -s -u seanfarley -X POST -H \"Content-Type: application/json\" \\ -d \'{     \"name\" : \"smf/create-feature\",     \"target\" : {         \"hash\" : \"default\",     } }\' ```  This call requires authentication. Private repositories require the caller to authenticate with an account that has appropriate authorization.  The branch name should not include any prefixes (e.g. refs/heads). This endpoint does support using short hash prefixes for the commit hash, but it may return a 400 response if the provided prefix is ambiguous. Using a full commit hash is the preferred approach.
     * @summary Create a branch
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugRefsBranchesPost(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsBranchesPostRequest, options?: RawAxiosRequestConfig) {
        return RefsApiFp(this.configuration).repositoriesWorkspaceRepoSlugRefsBranchesPost(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the branches and tags in the repository.  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git show-ref\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that refs are sorted [\"branch1\", \"branch10\", \"branch2\", \"v10\", \"v11\", \"v9\"] instead of [\"branch1\", \"branch2\", \"branch10\", \"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
     * @summary List branches and tags
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugRefsGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsGetRequest, options?: RawAxiosRequestConfig) {
        return RefsApiFp(this.configuration).repositoriesWorkspaceRepoSlugRefsGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the tags in the repository.  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \"$ git tag --list\". Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are sorted [\"v10\", \"v11\", \"v9\"] instead of [\"v9\", \"v10\", \"v11\"].  Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
     * @summary List tags
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugRefsTagsGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest, options?: RawAxiosRequestConfig) {
        return RefsApiFp(this.configuration).repositoriesWorkspaceRepoSlugRefsTagsGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a tag in the specified repository.  The tag name should not include any prefixes (e.g. refs/tags).
     * @summary Delete a tag
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsTagsNameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugRefsTagsNameDelete(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsTagsNameDeleteRequest, options?: RawAxiosRequestConfig) {
        return RefsApiFp(this.configuration).repositoriesWorkspaceRepoSlugRefsTagsNameDelete(requestParameters.name, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified tag.  ``` $ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8 -G | jq . {   \"name\": \"3.8\",   \"links\": {     \"commits\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commits/3.8\"     },     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8\"     },     \"html\": {       \"href\": \"https://bitbucket.org/seanfarley/hg/commits/tag/3.8\"     }   },   \"tagger\": {     \"raw\": \"Matt Mackall <mpm@selenic.com>\",     \"type\": \"author\",     \"user\": {       \"username\": \"mpmselenic\",       \"nickname\": \"mpmselenic\",       \"display_name\": \"Matt Mackall\",       \"type\": \"user\",       \"uuid\": \"{a4934530-db4c-419c-a478-9ab4964c2ee7}\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/users/mpmselenic\"         },         \"html\": {           \"href\": \"https://bitbucket.org/mpmselenic/\"         },         \"avatar\": {           \"href\": \"https://bitbucket.org/account/mpmselenic/avatar/32/\"         }       }     }   },   \"date\": \"2016-05-01T18:52:25+00:00\",   \"message\": \"Added tag 3.8 for changeset f85de28eae32\",   \"type\": \"tag\",   \"target\": {     \"hash\": \"f85de28eae32e7d3064b1a1321309071bbaaa069\",     \"repository\": {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg\"         },         \"html\": {           \"href\": \"https://bitbucket.org/seanfarley/hg\"         },         \"avatar\": {           \"href\": \"https://bitbucket.org/seanfarley/hg/avatar/32/\"         }       },       \"type\": \"repository\",       \"name\": \"hg\",       \"full_name\": \"seanfarley/hg\",       \"uuid\": \"{c75687fb-e99d-4579-9087-190dbd406d30}\"     },     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"comments\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/comments\"       },       \"patch\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/patch/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"html\": {         \"href\": \"https://bitbucket.org/seanfarley/hg/commits/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"diff\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/diff/f85de28eae32e7d3064b1a1321309071bbaaa069\"       },       \"approve\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/approve\"       },       \"statuses\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/statuses\"       }     },     \"author\": {       \"raw\": \"Sean Farley <sean@farley.io>\",       \"type\": \"author\",       \"user\": {         \"username\": \"seanfarley\",         \"nickname\": \"seanfarley\",         \"display_name\": \"Sean Farley\",         \"type\": \"user\",         \"uuid\": \"{a295f8a8-5876-4d43-89b5-3ad8c6c3c51d}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/seanfarley\"           },           \"html\": {             \"href\": \"https://bitbucket.org/seanfarley/\"           },           \"avatar\": {             \"href\": \"https://bitbucket.org/account/seanfarley/avatar/32/\"           }         }       }     },     \"parents\": [       {         \"hash\": \"9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\",         \"type\": \"commit\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\"           },           \"html\": {             \"href\": \"https://bitbucket.org/seanfarley/hg/commits/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\"           }         }       }     ],     \"date\": \"2016-05-01T04:21:17+00:00\",     \"message\": \"debian: alphabetize build deps\",     \"type\": \"commit\"   } } ```
     * @summary Get a tag
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsTagsNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugRefsTagsNameGet(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsTagsNameGetRequest, options?: RawAxiosRequestConfig) {
        return RefsApiFp(this.configuration).repositoriesWorkspaceRepoSlugRefsTagsNameGet(requestParameters.name, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new tag in the specified repository.  The payload of the POST should consist of a JSON document that contains the name of the tag and the target hash.  ``` curl https://api.bitbucket.org/2.0/repositories/jdoe/myrepo/refs/tags \\ -s -u jdoe -X POST -H \"Content-Type: application/json\" \\ -d \'{     \"name\" : \"new-tag-name\",     \"target\" : {         \"hash\" : \"a1b2c3d4e5f6\",     } }\' ```  This endpoint does support using short hash prefixes for the commit hash, but it may return a 400 response if the provided prefix is ambiguous. Using a full commit hash is the preferred approach.
     * @summary Create a tag
     * @param {RefsApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugRefsTagsPost(requestParameters: RefsApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest, options?: RawAxiosRequestConfig) {
        return RefsApiFp(this.configuration).repositoriesWorkspaceRepoSlugRefsTagsPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportsApi - axios parameter creator
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: ``` curl --location \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001/annotations\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'[   {         \"external_id\": \"mysystem-annotation001\",         \"title\": \"Security scan report\",         \"annotation_type\": \"VULNERABILITY\",         \"summary\": \"This line represents a security threat.\",         \"severity\": \"HIGH\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",         \"line\": 42   },   {         \"external_id\": \"mySystem-annotation002\",         \"title\": \"Bug report\",         \"annotation_type\": \"BUG\",         \"result\": \"FAILED\",         \"summary\": \"This line might introduce a bug.\",         \"severity\": \"MEDIUM\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\",         \"line\": 13   } ]\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Bulk create or update annotations
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit for which to retrieve reports.
         * @param {string} reportId Uuid or external-if of the report for which to get annotations for.
         * @param {Array<ReportAnnotation>} body The annotations to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateOrUpdateAnnotations: async (workspace: string, repoSlug: string, commit: string, reportId: string, body: Array<ReportAnnotation>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('bulkCreateOrUpdateAnnotations', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('bulkCreateOrUpdateAnnotations', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('bulkCreateOrUpdateAnnotations', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('bulkCreateOrUpdateAnnotations', 'reportId', reportId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('bulkCreateOrUpdateAnnotations', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mySystem-001/annotations/mysystem-annotation001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"annotation_type\": \"VULNERABILITY\",     \"summary\": \"This line represents a security thread.\",     \"severity\": \"HIGH\",     \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",     \"line\": 42 }\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Create or update an annotation
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {string} annotationId Either the uuid or external-id of the annotation.
         * @param {ReportAnnotation} body The annotation to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateAnnotation: async (workspace: string, repoSlug: string, commit: string, reportId: string, annotationId: string, body: ReportAnnotation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createOrUpdateAnnotation', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('createOrUpdateAnnotation', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('createOrUpdateAnnotation', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('createOrUpdateAnnotation', 'reportId', reportId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('createOrUpdateAnnotation', 'annotationId', annotationId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateAnnotation', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)))
                .replace(`{${"annotationId"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"details\": \"This pull request introduces 10 new dependency vulnerabilities.\",     \"report_type\": \"SECURITY\",     \"reporter\": \"mySystem\",     \"link\": \"http://www.mysystem.com/reports/001\",     \"result\": \"FAILED\",     \"data\": [         {             \"title\": \"Duration (seconds)\",             \"type\": \"DURATION\",             \"value\": 14         },         {             \"title\": \"Safe to merge?\",             \"type\": \"BOOLEAN\",             \"value\": false         }     ] }\' ```  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as \'Yes\' or \'No\'. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: `{\"text\": \"Link text here\", \"href\": \"https://link.to.annotation/in/external/tool\"}` | The value will be read as a JSON object containing the fields \"text\" and \"href\" and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Create or update a report
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {Report} body The report to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateReport: async (workspace: string, repoSlug: string, commit: string, reportId: string, body: Report, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createOrUpdateReport', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('createOrUpdateReport', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('createOrUpdateReport', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('createOrUpdateReport', 'reportId', reportId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateReport', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single Annotation matching the provided ID.
         * @summary Delete an annotation
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the annotation belongs to.
         * @param {string} reportId Either the uuid or external-id of the annotation.
         * @param {string} annotationId Either the uuid or external-id of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnotation: async (workspace: string, repoSlug: string, commit: string, reportId: string, annotationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteAnnotation', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deleteAnnotation', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('deleteAnnotation', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('deleteAnnotation', 'reportId', reportId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('deleteAnnotation', 'annotationId', annotationId)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)))
                .replace(`{${"annotationId"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single Report matching the provided ID.
         * @summary Delete a report
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport: async (workspace: string, repoSlug: string, commit: string, reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteReport', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('deleteReport', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('deleteReport', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('deleteReport', 'reportId', reportId)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Annotation matching the provided ID.
         * @summary Get an annotation
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {string} annotationId Either the uuid or external-id of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotation: async (workspace: string, repoSlug: string, commit: string, reportId: string, annotationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getAnnotation', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getAnnotation', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('getAnnotation', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getAnnotation', 'reportId', reportId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('getAnnotation', 'annotationId', annotationId)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)))
                .replace(`{${"annotationId"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of Annotations for a specified report.
         * @summary List annotations
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit for which to retrieve reports.
         * @param {string} reportId Uuid or external-if of the report for which to get annotations for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotationsForReport: async (workspace: string, repoSlug: string, commit: string, reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getAnnotationsForReport', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getAnnotationsForReport', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('getAnnotationsForReport', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getAnnotationsForReport', 'reportId', reportId)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Report matching the provided ID.
         * @summary Get a report
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport: async (workspace: string, repoSlug: string, commit: string, reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getReport', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getReport', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('getReport', 'commit', commit)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getReport', 'reportId', reportId)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of Reports linked to this commit.
         * @summary List reports
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit for which to retrieve reports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsForCommit: async (workspace: string, repoSlug: string, commit: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getReportsForCommit', 'workspace', workspace)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('getReportsForCommit', 'repoSlug', repoSlug)
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('getReportsForCommit', 'commit', commit)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/commit/{commit}/reports`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: ``` curl --location \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001/annotations\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'[   {         \"external_id\": \"mysystem-annotation001\",         \"title\": \"Security scan report\",         \"annotation_type\": \"VULNERABILITY\",         \"summary\": \"This line represents a security threat.\",         \"severity\": \"HIGH\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",         \"line\": 42   },   {         \"external_id\": \"mySystem-annotation002\",         \"title\": \"Bug report\",         \"annotation_type\": \"BUG\",         \"result\": \"FAILED\",         \"summary\": \"This line might introduce a bug.\",         \"severity\": \"MEDIUM\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\",         \"line\": 13   } ]\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Bulk create or update annotations
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit for which to retrieve reports.
         * @param {string} reportId Uuid or external-if of the report for which to get annotations for.
         * @param {Array<ReportAnnotation>} body The annotations to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkCreateOrUpdateAnnotations(workspace: string, repoSlug: string, commit: string, reportId: string, body: Array<ReportAnnotation>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReportAnnotation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreateOrUpdateAnnotations(workspace, repoSlug, commit, reportId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.bulkCreateOrUpdateAnnotations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mySystem-001/annotations/mysystem-annotation001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"annotation_type\": \"VULNERABILITY\",     \"summary\": \"This line represents a security thread.\",     \"severity\": \"HIGH\",     \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",     \"line\": 42 }\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Create or update an annotation
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {string} annotationId Either the uuid or external-id of the annotation.
         * @param {ReportAnnotation} body The annotation to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateAnnotation(workspace: string, repoSlug: string, commit: string, reportId: string, annotationId: string, body: ReportAnnotation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportAnnotation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateAnnotation(workspace, repoSlug, commit, reportId, annotationId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.createOrUpdateAnnotation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"details\": \"This pull request introduces 10 new dependency vulnerabilities.\",     \"report_type\": \"SECURITY\",     \"reporter\": \"mySystem\",     \"link\": \"http://www.mysystem.com/reports/001\",     \"result\": \"FAILED\",     \"data\": [         {             \"title\": \"Duration (seconds)\",             \"type\": \"DURATION\",             \"value\": 14         },         {             \"title\": \"Safe to merge?\",             \"type\": \"BOOLEAN\",             \"value\": false         }     ] }\' ```  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as \'Yes\' or \'No\'. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: `{\"text\": \"Link text here\", \"href\": \"https://link.to.annotation/in/external/tool\"}` | The value will be read as a JSON object containing the fields \"text\" and \"href\" and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Create or update a report
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {Report} body The report to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateReport(workspace: string, repoSlug: string, commit: string, reportId: string, body: Report, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateReport(workspace, repoSlug, commit, reportId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.createOrUpdateReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a single Annotation matching the provided ID.
         * @summary Delete an annotation
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the annotation belongs to.
         * @param {string} reportId Either the uuid or external-id of the annotation.
         * @param {string} annotationId Either the uuid or external-id of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnnotation(workspace: string, repoSlug: string, commit: string, reportId: string, annotationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAnnotation(workspace, repoSlug, commit, reportId, annotationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.deleteAnnotation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a single Report matching the provided ID.
         * @summary Delete a report
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReport(workspace: string, repoSlug: string, commit: string, reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReport(workspace, repoSlug, commit, reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.deleteReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single Annotation matching the provided ID.
         * @summary Get an annotation
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {string} annotationId Either the uuid or external-id of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnotation(workspace: string, repoSlug: string, commit: string, reportId: string, annotationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportAnnotation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnotation(workspace, repoSlug, commit, reportId, annotationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.getAnnotation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of Annotations for a specified report.
         * @summary List annotations
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit for which to retrieve reports.
         * @param {string} reportId Uuid or external-if of the report for which to get annotations for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnotationsForReport(workspace: string, repoSlug: string, commit: string, reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAnnotations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnotationsForReport(workspace, repoSlug, commit, reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.getAnnotationsForReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single Report matching the provided ID.
         * @summary Get a report
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit the report belongs to.
         * @param {string} reportId Either the uuid or external-id of the report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReport(workspace: string, repoSlug: string, commit: string, reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReport(workspace, repoSlug, commit, reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.getReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of Reports linked to this commit.
         * @summary List reports
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
         * @param {string} repoSlug The repository.
         * @param {string} commit The commit for which to retrieve reports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReportsForCommit(workspace: string, repoSlug: string, commit: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedReports>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReportsForCommit(workspace, repoSlug, commit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.getReportsForCommit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportsApi - factory interface
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: ``` curl --location \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001/annotations\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'[   {         \"external_id\": \"mysystem-annotation001\",         \"title\": \"Security scan report\",         \"annotation_type\": \"VULNERABILITY\",         \"summary\": \"This line represents a security threat.\",         \"severity\": \"HIGH\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",         \"line\": 42   },   {         \"external_id\": \"mySystem-annotation002\",         \"title\": \"Bug report\",         \"annotation_type\": \"BUG\",         \"result\": \"FAILED\",         \"summary\": \"This line might introduce a bug.\",         \"severity\": \"MEDIUM\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\",         \"line\": 13   } ]\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Bulk create or update annotations
         * @param {ReportsApiBulkCreateOrUpdateAnnotationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateOrUpdateAnnotations(requestParameters: ReportsApiBulkCreateOrUpdateAnnotationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ReportAnnotation>> {
            return localVarFp.bulkCreateOrUpdateAnnotations(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mySystem-001/annotations/mysystem-annotation001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"annotation_type\": \"VULNERABILITY\",     \"summary\": \"This line represents a security thread.\",     \"severity\": \"HIGH\",     \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",     \"line\": 42 }\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Create or update an annotation
         * @param {ReportsApiCreateOrUpdateAnnotationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateAnnotation(requestParameters: ReportsApiCreateOrUpdateAnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReportAnnotation> {
            return localVarFp.createOrUpdateAnnotation(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.annotationId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"details\": \"This pull request introduces 10 new dependency vulnerabilities.\",     \"report_type\": \"SECURITY\",     \"reporter\": \"mySystem\",     \"link\": \"http://www.mysystem.com/reports/001\",     \"result\": \"FAILED\",     \"data\": [         {             \"title\": \"Duration (seconds)\",             \"type\": \"DURATION\",             \"value\": 14         },         {             \"title\": \"Safe to merge?\",             \"type\": \"BOOLEAN\",             \"value\": false         }     ] }\' ```  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as \'Yes\' or \'No\'. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: `{\"text\": \"Link text here\", \"href\": \"https://link.to.annotation/in/external/tool\"}` | The value will be read as a JSON object containing the fields \"text\" and \"href\" and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
         * @summary Create or update a report
         * @param {ReportsApiCreateOrUpdateReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateReport(requestParameters: ReportsApiCreateOrUpdateReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<Report> {
            return localVarFp.createOrUpdateReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single Annotation matching the provided ID.
         * @summary Delete an annotation
         * @param {ReportsApiDeleteAnnotationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnotation(requestParameters: ReportsApiDeleteAnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAnnotation(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.annotationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single Report matching the provided ID.
         * @summary Delete a report
         * @param {ReportsApiDeleteReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport(requestParameters: ReportsApiDeleteReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single Annotation matching the provided ID.
         * @summary Get an annotation
         * @param {ReportsApiGetAnnotationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotation(requestParameters: ReportsApiGetAnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReportAnnotation> {
            return localVarFp.getAnnotation(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.annotationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of Annotations for a specified report.
         * @summary List annotations
         * @param {ReportsApiGetAnnotationsForReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotationsForReport(requestParameters: ReportsApiGetAnnotationsForReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAnnotations> {
            return localVarFp.getAnnotationsForReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single Report matching the provided ID.
         * @summary Get a report
         * @param {ReportsApiGetReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport(requestParameters: ReportsApiGetReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<Report> {
            return localVarFp.getReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of Reports linked to this commit.
         * @summary List reports
         * @param {ReportsApiGetReportsForCommitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsForCommit(requestParameters: ReportsApiGetReportsForCommitRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedReports> {
            return localVarFp.getReportsForCommit(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - interface
 */
export interface ReportsApiInterface {
    /**
     * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: ``` curl --location \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001/annotations\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'[   {         \"external_id\": \"mysystem-annotation001\",         \"title\": \"Security scan report\",         \"annotation_type\": \"VULNERABILITY\",         \"summary\": \"This line represents a security threat.\",         \"severity\": \"HIGH\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",         \"line\": 42   },   {         \"external_id\": \"mySystem-annotation002\",         \"title\": \"Bug report\",         \"annotation_type\": \"BUG\",         \"result\": \"FAILED\",         \"summary\": \"This line might introduce a bug.\",         \"severity\": \"MEDIUM\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\",         \"line\": 13   } ]\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @summary Bulk create or update annotations
     * @param {ReportsApiBulkCreateOrUpdateAnnotationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateOrUpdateAnnotations(requestParameters: ReportsApiBulkCreateOrUpdateAnnotationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ReportAnnotation>>;

    /**
     * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mySystem-001/annotations/mysystem-annotation001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"annotation_type\": \"VULNERABILITY\",     \"summary\": \"This line represents a security thread.\",     \"severity\": \"HIGH\",     \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",     \"line\": 42 }\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @summary Create or update an annotation
     * @param {ReportsApiCreateOrUpdateAnnotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateAnnotation(requestParameters: ReportsApiCreateOrUpdateAnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReportAnnotation>;

    /**
     * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"details\": \"This pull request introduces 10 new dependency vulnerabilities.\",     \"report_type\": \"SECURITY\",     \"reporter\": \"mySystem\",     \"link\": \"http://www.mysystem.com/reports/001\",     \"result\": \"FAILED\",     \"data\": [         {             \"title\": \"Duration (seconds)\",             \"type\": \"DURATION\",             \"value\": 14         },         {             \"title\": \"Safe to merge?\",             \"type\": \"BOOLEAN\",             \"value\": false         }     ] }\' ```  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as \'Yes\' or \'No\'. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: `{\"text\": \"Link text here\", \"href\": \"https://link.to.annotation/in/external/tool\"}` | The value will be read as a JSON object containing the fields \"text\" and \"href\" and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @summary Create or update a report
     * @param {ReportsApiCreateOrUpdateReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateReport(requestParameters: ReportsApiCreateOrUpdateReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<Report>;

    /**
     * Deletes a single Annotation matching the provided ID.
     * @summary Delete an annotation
     * @param {ReportsApiDeleteAnnotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAnnotation(requestParameters: ReportsApiDeleteAnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Deletes a single Report matching the provided ID.
     * @summary Delete a report
     * @param {ReportsApiDeleteReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteReport(requestParameters: ReportsApiDeleteReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a single Annotation matching the provided ID.
     * @summary Get an annotation
     * @param {ReportsApiGetAnnotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnnotation(requestParameters: ReportsApiGetAnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReportAnnotation>;

    /**
     * Returns a paginated list of Annotations for a specified report.
     * @summary List annotations
     * @param {ReportsApiGetAnnotationsForReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnnotationsForReport(requestParameters: ReportsApiGetAnnotationsForReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAnnotations>;

    /**
     * Returns a single Report matching the provided ID.
     * @summary Get a report
     * @param {ReportsApiGetReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReport(requestParameters: ReportsApiGetReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<Report>;

    /**
     * Returns a paginated list of Reports linked to this commit.
     * @summary List reports
     * @param {ReportsApiGetReportsForCommitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportsForCommit(requestParameters: ReportsApiGetReportsForCommitRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedReports>;

}

/**
 * Request parameters for bulkCreateOrUpdateAnnotations operation in ReportsApi.
 */
export interface ReportsApiBulkCreateOrUpdateAnnotationsRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit for which to retrieve reports.
     */
    readonly commit: string

    /**
     * Uuid or external-if of the report for which to get annotations for.
     */
    readonly reportId: string

    /**
     * The annotations to create or update
     */
    readonly body: Array<ReportAnnotation>
}

/**
 * Request parameters for createOrUpdateAnnotation operation in ReportsApi.
 */
export interface ReportsApiCreateOrUpdateAnnotationRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit the report belongs to.
     */
    readonly commit: string

    /**
     * Either the uuid or external-id of the report.
     */
    readonly reportId: string

    /**
     * Either the uuid or external-id of the annotation.
     */
    readonly annotationId: string

    /**
     * The annotation to create or update
     */
    readonly body: ReportAnnotation
}

/**
 * Request parameters for createOrUpdateReport operation in ReportsApi.
 */
export interface ReportsApiCreateOrUpdateReportRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit the report belongs to.
     */
    readonly commit: string

    /**
     * Either the uuid or external-id of the report.
     */
    readonly reportId: string

    /**
     * The report to create or update
     */
    readonly body: Report
}

/**
 * Request parameters for deleteAnnotation operation in ReportsApi.
 */
export interface ReportsApiDeleteAnnotationRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit the annotation belongs to.
     */
    readonly commit: string

    /**
     * Either the uuid or external-id of the annotation.
     */
    readonly reportId: string

    /**
     * Either the uuid or external-id of the annotation.
     */
    readonly annotationId: string
}

/**
 * Request parameters for deleteReport operation in ReportsApi.
 */
export interface ReportsApiDeleteReportRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit the report belongs to.
     */
    readonly commit: string

    /**
     * Either the uuid or external-id of the report.
     */
    readonly reportId: string
}

/**
 * Request parameters for getAnnotation operation in ReportsApi.
 */
export interface ReportsApiGetAnnotationRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit the report belongs to.
     */
    readonly commit: string

    /**
     * Either the uuid or external-id of the report.
     */
    readonly reportId: string

    /**
     * Either the uuid or external-id of the annotation.
     */
    readonly annotationId: string
}

/**
 * Request parameters for getAnnotationsForReport operation in ReportsApi.
 */
export interface ReportsApiGetAnnotationsForReportRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit for which to retrieve reports.
     */
    readonly commit: string

    /**
     * Uuid or external-if of the report for which to get annotations for.
     */
    readonly reportId: string
}

/**
 * Request parameters for getReport operation in ReportsApi.
 */
export interface ReportsApiGetReportRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit the report belongs to.
     */
    readonly commit: string

    /**
     * Either the uuid or external-id of the report.
     */
    readonly reportId: string
}

/**
 * Request parameters for getReportsForCommit operation in ReportsApi.
 */
export interface ReportsApiGetReportsForCommitRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;.
     */
    readonly workspace: string

    /**
     * The repository.
     */
    readonly repoSlug: string

    /**
     * The commit for which to retrieve reports.
     */
    readonly commit: string
}

/**
 * ReportsApi - object-oriented interface
 */
export class ReportsApi extends BaseAPI implements ReportsApiInterface {
    /**
     * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: ``` curl --location \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001/annotations\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'[   {         \"external_id\": \"mysystem-annotation001\",         \"title\": \"Security scan report\",         \"annotation_type\": \"VULNERABILITY\",         \"summary\": \"This line represents a security threat.\",         \"severity\": \"HIGH\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",         \"line\": 42   },   {         \"external_id\": \"mySystem-annotation002\",         \"title\": \"Bug report\",         \"annotation_type\": \"BUG\",         \"result\": \"FAILED\",         \"summary\": \"This line might introduce a bug.\",         \"severity\": \"MEDIUM\",       \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\",         \"line\": 13   } ]\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @summary Bulk create or update annotations
     * @param {ReportsApiBulkCreateOrUpdateAnnotationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public bulkCreateOrUpdateAnnotations(requestParameters: ReportsApiBulkCreateOrUpdateAnnotationsRequest, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).bulkCreateOrUpdateAnnotations(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mySystem-001/annotations/mysystem-annotation001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"annotation_type\": \"VULNERABILITY\",     \"summary\": \"This line represents a security thread.\",     \"severity\": \"HIGH\",     \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",     \"line\": 42 }\' ```  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @summary Create or update an annotation
     * @param {ReportsApiCreateOrUpdateAnnotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createOrUpdateAnnotation(requestParameters: ReportsApiCreateOrUpdateAnnotationRequest, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).createOrUpdateAnnotation(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.annotationId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system\'s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: ``` curl --request PUT \'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001\' \\ --header \'Content-Type: application/json\' \\ --data-raw \'{     \"title\": \"Security scan report\",     \"details\": \"This pull request introduces 10 new dependency vulnerabilities.\",     \"report_type\": \"SECURITY\",     \"reporter\": \"mySystem\",     \"link\": \"http://www.mysystem.com/reports/001\",     \"result\": \"FAILED\",     \"data\": [         {             \"title\": \"Duration (seconds)\",             \"type\": \"DURATION\",             \"value\": 14         },         {             \"title\": \"Safe to merge?\",             \"type\": \"BOOLEAN\",             \"value\": false         }     ] }\' ```  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as \'Yes\' or \'No\'. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: `{\"text\": \"Link text here\", \"href\": \"https://link.to.annotation/in/external/tool\"}` | The value will be read as a JSON object containing the fields \"text\" and \"href\" and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @summary Create or update a report
     * @param {ReportsApiCreateOrUpdateReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createOrUpdateReport(requestParameters: ReportsApiCreateOrUpdateReportRequest, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).createOrUpdateReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single Annotation matching the provided ID.
     * @summary Delete an annotation
     * @param {ReportsApiDeleteAnnotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAnnotation(requestParameters: ReportsApiDeleteAnnotationRequest, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).deleteAnnotation(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.annotationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single Report matching the provided ID.
     * @summary Delete a report
     * @param {ReportsApiDeleteReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteReport(requestParameters: ReportsApiDeleteReportRequest, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).deleteReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single Annotation matching the provided ID.
     * @summary Get an annotation
     * @param {ReportsApiGetAnnotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAnnotation(requestParameters: ReportsApiGetAnnotationRequest, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getAnnotation(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, requestParameters.annotationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of Annotations for a specified report.
     * @summary List annotations
     * @param {ReportsApiGetAnnotationsForReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAnnotationsForReport(requestParameters: ReportsApiGetAnnotationsForReportRequest, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getAnnotationsForReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single Report matching the provided ID.
     * @summary Get a report
     * @param {ReportsApiGetReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getReport(requestParameters: ReportsApiGetReportRequest, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getReport(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, requestParameters.reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of Reports linked to this commit.
     * @summary List reports
     * @param {ReportsApiGetReportsForCommitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getReportsForCommit(requestParameters: ReportsApiGetReportsForCommitRequest, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getReportsForCommit(requestParameters.workspace, requestParameters.repoSlug, requestParameters.commit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepositoriesApi - axios parameter creator
 */
export const RepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a paginated list of all public repositories.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-get).
         * @summary List public repositories
         * @param {string} [after] Filter the results to include only repositories created on or after this [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)  timestamp. Example: &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;
         * @param {RepositoriesGetRoleEnum} [role] Filters the result based on the authenticated user\&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user 
         * @param {string} [q] Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). &#x60;role&#x60; parameter must also be specified. 
         * @param {string} [sort] Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        repositoriesGet: async (after?: string, role?: RepositoriesGetRoleEnum, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all repositories owned by the specified workspace.  The result can be narrowed down based on the authenticated user\'s role.  E.g. with `?role=contributor`, only those repositories that the authenticated user has write access to are returned (this includes any repo the user is an admin on, as that implies write access).  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List repositories in a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {RepositoriesWorkspaceGetRoleEnum} [role]  Filters the result based on the authenticated user\&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {string} [sort]  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceGet: async (workspace: string, role?: RepositoriesWorkspaceGetRoleEnum, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the repository. This is an irreversible operation.  This does not affect its forks.
         * @summary Delete a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [redirectTo] If a repository has been moved to a new location, use this parameter to show users a friendly message in the Bitbucket UI that the repository has moved to a new location. However, a GET to this endpoint will still return a 404. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDelete: async (repoSlug: string, workspace: string, redirectTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:delete"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (redirectTo !== undefined) {
                localVarQueryParameter['redirect_to'] = redirectTo;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order <sha> <path>  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the `?renames=false` query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to only provide exactly the data you want.  The example response returns commits made before 2011-05-18 against a file named `README.rst`. The results are filtered to only return the path and date. This request can be made using:  ``` $ curl \'https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst\'\\   \'?fields=values.next,values.path,values.commit.date&q=commit.date<=2011-05-18\' ```  In the response you can see that the file was renamed to `README.rst` by the commit made on 2011-05-16, and was previously named `README.txt`.
         * @summary List commits that modified a file
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} path Path to the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [renames]  When &#x60;true&#x60;, Bitbucket will follow the history of the file across renames (this is the default behavior). This can be turned off by specifying &#x60;false&#x60;.
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet: async (commit: string, path: string, repoSlug: string, workspace: string, renames?: string, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet', 'commit', commit)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet', 'path', path)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/filehistory/{commit}/{path}`
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (renames !== undefined) {
                localVarQueryParameter['renames'] = renames;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all the forks of the specified repository.
         * @summary List repository forks
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {RepositoriesWorkspaceRepoSlugForksGetRoleEnum} [role] Filters the result based on the authenticated user\&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user 
         * @param {string} [q] Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {string} [sort] Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugForksGet: async (repoSlug: string, workspace: string, role?: RepositoriesWorkspaceRepoSlugForksGetRoleEnum, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugForksGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugForksGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/forks`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new fork of the specified repository.  #### Forking a repository  To create a fork, specify the workspace explicitly as part of the request body:  ``` $ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/atlassian/bbql/forks \\   -H \'Content-Type: application/json\' -d \'{     \"name\": \"bbql_fork\",     \"workspace\": {       \"slug\": \"atlassian\"     } }\' ```  To fork a repository into the same workspace, also specify a new `name`.  When you specify a value for `name`, it will also affect the `slug`. The `slug` is reflected in the repository URL of the new fork. It is derived from `name` by substituting non-ASCII characters, removes whitespace, and changes characters to lower case. For example, `My repo` would turn into `my_repo`.  You need contributor access to create new forks within a workspace.   #### Change the properties of a new fork  By default the fork inherits most of its properties from the parent. However, since the optional POST body document follows the normal `repository` JSON schema and you can override the new fork\'s properties.  Properties that can be overridden include:  * description * fork_policy * language * mainbranch * is_private (note that a private repo\'s fork_policy might prohibit   the creation of public forks, in which `is_private=False` would fail) * has_issues (to initialize or disable the new repo\'s issue tracker --   note that the actual contents of the parent repository\'s issue   tracker are not copied during forking) * has_wiki (to initialize or disable the new repo\'s wiki --   note that the actual contents of the parent repository\'s wiki are not   copied during forking) * project (when forking into a private project, the fork\'s `is_private`   must be `true`)  Properties that cannot be modified include:  * scm * parent * full_name
         * @summary Fork a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Repository} [body] A repository object. This can be left blank.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugForksPost: async (repoSlug: string, workspace: string, body?: Repository, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugForksPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugForksPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/forks`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the object describing this repository.
         * @summary Get a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of webhooks installed on this repository.
         * @summary List webhooks for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/hooks`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new webhook on the specified repository.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  Also note that the `url` must properly resolve and cannot be an internal, non-routed address.
         * @summary Create a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksPost: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/hooks`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified webhook subscription from the given repository.
         * @summary Delete a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksUidDelete: async (repoSlug: string, uid: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidDelete', 'repoSlug', repoSlug)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidDelete', 'uid', uid)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/hooks/{uid}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the webhook with the specified id installed on the specified repository.
         * @summary Get a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksUidGet: async (repoSlug: string, uid: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidGet', 'repoSlug', repoSlug)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidGet', 'uid', uid)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/hooks/{uid}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
         * @summary Update a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksUidPut: async (repoSlug: string, uid: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidPut', 'repoSlug', repoSlug)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidPut', 'uid', uid)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidPut', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/hooks/{uid}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the inheritance state for repository settings
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugOverrideSettingsGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugOverrideSettingsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugOverrideSettingsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/override-settings`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the inheritance state for repository settings                 
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugOverrideSettingsPut: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugOverrideSettingsPut', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugOverrideSettingsPut', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/override-settings`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of explicit group permissions for the given repository. This endpoint does not support BBQL features.
         * @summary List explicit group permissions for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/permissions-config/groups`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the repository group permission between the requested repository and group, if one exists.  Only users with admin permission for the repository may access this resource.  The only authentication method supported for this endpoint is via app passwords.
         * @summary Delete an explicit group permission for a repository
         * @param {string} groupSlug Slug of the requested group.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete: async (groupSlug: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete', 'groupSlug', groupSlug)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/permissions-config/groups/{group_slug}`
                .replace(`{${"group_slug"}}`, encodeURIComponent(String(groupSlug)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the group permission for a given group slug and repository  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read` * `none`
         * @summary Get an explicit group permission for a repository
         * @param {string} groupSlug Slug of the requested group.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet: async (groupSlug: string, repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet', 'groupSlug', groupSlug)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/permissions-config/groups/{group_slug}`
                .replace(`{${"group_slug"}}`, encodeURIComponent(String(groupSlug)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the group permission, or grants a new permission if one does not already exist.  Only users with admin permission for the repository may access this resource.  The only authentication method supported for this endpoint is via app passwords.  Permissions can be:  * `admin` * `write` * `read`
         * @summary Update an explicit group permission for a repository
         * @param {string} groupSlug Slug of the requested group.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchema} body The permission to grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut: async (groupSlug: string, repoSlug: string, workspace: string, body: BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut', 'groupSlug', groupSlug)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/permissions-config/groups/{group_slug}`
                .replace(`{${"group_slug"}}`, encodeURIComponent(String(groupSlug)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of explicit user permissions for the given repository. This endpoint does not support BBQL features.
         * @summary List explicit user permissions for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/permissions-config/users`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the repository user permission between the requested repository and user, if one exists.  Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.
         * @summary Delete an explicit user permission for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete: async (repoSlug: string, selectedUserId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete', 'repoSlug', repoSlug)
            // verify required parameter 'selectedUserId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete', 'selectedUserId', selectedUserId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/permissions-config/users/{selected_user_id}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"selected_user_id"}}`, encodeURIComponent(String(selectedUserId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the explicit user permission for a given user and repository.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read` * `none`
         * @summary Get an explicit user permission for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet: async (repoSlug: string, selectedUserId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet', 'repoSlug', repoSlug)
            // verify required parameter 'selectedUserId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet', 'selectedUserId', selectedUserId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/permissions-config/users/{selected_user_id}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"selected_user_id"}}`, encodeURIComponent(String(selectedUserId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the explicit user permission for a given user and repository. The selected user must be a member of the workspace, and cannot be the workspace owner. Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.  Permissions can be:  * `admin` * `write` * `read`
         * @summary Update an explicit user permission for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchema} body The permission to grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut: async (repoSlug: string, selectedUserId: string, workspace: string, body: BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut', 'repoSlug', repoSlug)
            // verify required parameter 'selectedUserId' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut', 'selectedUserId', selectedUserId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut', 'body', body)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/permissions-config/users/{selected_user_id}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"selected_user_id"}}`, encodeURIComponent(String(selectedUserId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new repository.  Note: In order to set the project for the newly created repository, pass in either the project key or the project UUID as part of the request body as shown in the examples below:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{     \"scm\": \"git\",     \"project\": {         \"key\": \"MARS\"     } }\' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding ```  or  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{     \"scm\": \"git\",     \"project\": {         \"key\": \"{ba516952-992a-4c2d-acbd-17d502922f96}\"     } }\' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding ```  The project must be assigned for all repositories. If the project is not provided, the repository is automatically assigned to the oldest project in the workspace.  Note: In the examples above, the workspace ID `teamsinspace`, and/or the repository name `hablanding` can be replaced by UUIDs.
         * @summary Create a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Repository} [body] The repository that is to be created. Note that most object elements are optional. Elements \&quot;owner\&quot; and \&quot;full_name\&quot; are ignored as the URL implies them.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPost: async (repoSlug: string, workspace: string, body?: Repository, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since this endpoint can be used to both update and to create a repository, the request body depends on the intent.  #### Creation  See the POST documentation for the repository endpoint for an example of the request body.  #### Update  Note: Changing the `name` of the repository will cause the location to be changed. This is because the URL of the repo is derived from the name (a process called slugification). In such a scenario, it is possible for the request to fail if the newly created slug conflicts with an existing repository\'s slug. But if there is no conflict, the new location will be returned in the `Location` header of the response.
         * @summary Update a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Repository} [body] The repository that is to be updated.  Note that the elements \&quot;owner\&quot; and \&quot;full_name\&quot; are ignored since the URL implies them. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPut: async (repoSlug: string, workspace: string, body?: Repository, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPut', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugPut', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:admin"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  #### Raw file contents  When `path` points to a file, this endpoint returns the raw contents. The response\'s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The `Content-Disposition` header will be \"attachment\" to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian\'s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty `__init__.py` always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  #### File meta data  When the request for a file path includes the query parameter `?format=meta`, instead of returning the file\'s raw contents, Bitbucket instead returns the JSON object describing the file\'s properties:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format=meta {   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"     }   },   \"path\": \"tests/__init__.py\",   \"commit\": {     \"type\": \"commit\",     \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"       },       \"html\": {         \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"       }     }   },   \"attributes\": [],   \"type\": \"commit_file\",   \"size\": 0 } ```  File objects contain an `attributes` element that contains a list of possible modifiers. Currently defined values are:  * `link` -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * `executable` -- indicates that the file has the executable bit set. * `subrepository` -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * `binary` -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file\'s size without incurring the overhead of receiving its full contents.   #### Directory listings  When `path` points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \"pagelen\": 10,   \"values\": [     {       \"path\": \"tests/test_project\",       \"type\": \"commit_directory\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"         }       },       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       }     },     {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"         }       },       \"path\": \"tests/__init__.py\",       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       },       \"attributes\": [],       \"type\": \"commit_file\",       \"size\": 0     }   ],   \"page\": 1,   \"size\": 2 } ```  When listing the contents of the repo\'s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \"walk\" the entire directory tree, the client can either parse each response and follow the `self` links of each `commit_directory` object, or can specify a `max_depth` to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the `max_depth` parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a `commit_file`, or a `commit_directory`, both of which contain a `path` element. This path is the absolute path from the root of the repository. Each object also contains a `commit` object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their `self` link returns the paginated contents of the directory. The `meta` link on the other hand returns the actual `directory` object itself, e.g.:  ```javascript {   \"path\": \"tests/test_project\",   \"type\": \"commit_directory\",   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"     }   },   \"commit\": { ... } } ```  #### Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  `size > 1024 and attributes = \"binary\"`  which after urlencoding yields the query string:  `?q=size%3E1024+and+attributes%3D%22binary%22`  To change the ordering of the response, use the `?sort` parameter:  `.../src/eefd5ef/?sort=-size`  See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary Get file or directory contents
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} path Path to the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {RepositoriesWorkspaceRepoSlugSrcCommitPathGetFormatEnum} [format] If \&#39;meta\&#39; is provided, returns the (json) meta data for the contents of the file.  If \&#39;rendered\&#39; is provided, returns the contents of a non-binary file in HTML-formatted rendered markup. The \&#39;rendered\&#39; option only supports these filetypes: &#x60;.md&#x60;, &#x60;.markdown&#x60;, &#x60;.mkd&#x60;, &#x60;.mkdn&#x60;, &#x60;.mdown&#x60;, &#x60;.text&#x60;, &#x60;.rst&#x60;, and &#x60;.textile&#x60;. Since Git does not generally track what text encoding scheme is used, this endpoint attempts to detect the most appropriate character encoding. While usually correct, determining the character encoding can be ambiguous which in exceptional cases can lead to misinterpretation of the characters. As such, the raw element in the response object should not be treated as equivalent to the file\&#39;s actual contents.
         * @param {string} [q] Optional filter expression as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort] Optional sorting parameter as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results).
         * @param {number} [maxDepth] If provided, returns the contents of the repository and its subdirectories recursively until the specified max_depth of nested directories. When omitted, this defaults to 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugSrcCommitPathGet: async (commit: string, path: string, repoSlug: string, workspace: string, format?: RepositoriesWorkspaceRepoSlugSrcCommitPathGetFormatEnum, q?: string, sort?: string, maxDepth?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcCommitPathGet', 'commit', commit)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcCommitPathGet', 'path', path)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcCommitPathGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcCommitPathGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/src/{commit}/{path}`
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (maxDepth !== undefined) {
                localVarQueryParameter['max_depth'] = maxDepth;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo\'s main branch.  To create new commits, [POST to this endpoint](#post)
         * @summary Get the root directory of the main branch
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {RepositoriesWorkspaceRepoSlugSrcGetFormatEnum} [format] Instead of returning the file\&#39;s contents, return the (json) meta data for it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugSrcGet: async (repoSlug: string, workspace: string, format?: RepositoriesWorkspaceRepoSlugSrcGetFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/src`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png=@image.png ```  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the `image.png` file to the repository in the `/repo/path/to` directory.  To create a commit that deletes files, use the `files` parameter:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files=/file/to/delete/1.txt \\   -F files=/file/to/delete/2.txt ```  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts `multipart/form-data` (as in the examples above), as well as `application/x-www-form-urlencoded`.  Note: `multipart/form-data` is currently not supported by Forge apps for this API.  #### multipart/form-data  A `multipart/form-data` post contains a series of \"form fields\" that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a `Content-Disposition` parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above `curl` example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For `multipart/form-data` bodies that should not lead to any ambiguity, as the `Content-Disposition` header will contain the `filename` parameter to distinguish between a file named \"message\" and the commit message field.  #### application/x-www-form-urlencoded  It is also possible to upload new files using a simple `application/x-www-form-urlencoded` POST. This can be convenient when uploading pure text files:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \"/path/to/me.txt=Lorem ipsum.\" \\   --data-urlencode \"message=Initial commit\" \\   --data-urlencode \"author=Erik van Zijst <erik.van.zijst@gmail.com>\" ```  There could be a field name clash if a client were to upload a file named \"message\", as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. `curl --data-urlencode \"/message=file contents\"`.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  #### Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a `x-attributes` value in the `Content-Disposition` header. For example, to upload an executable file, as well as create a symlink from `README.txt` to `README`:  ``` --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"bin/shutdown.sh\" Content-Disposition: attachment; filename=\"shutdown.sh\"; x-attributes:\"executable\"  #!/bin/sh halt  --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"/README.txt\" Content-Disposition: attachment; filename=\"README.txt\"; x-attributes:\"link\"  README --===============1438169132528273974==-- ```  Links are files that contain the target path and have `x-attributes:\"link\"` set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying `x-attributes=\"link\"` will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include `x-attributes=\"executable\"` in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.
         * @summary Create a commit by uploading a file
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [message] The commit message. When omitted, Bitbucket uses a canned string.
         * @param {string} [author]  The raw string to be used as the new commit\&#39;s author. This string follows the format &#x60;Erik van Zijst &lt;evzijst@atlassian.com&gt;&#x60;.  When omitted, Bitbucket uses the authenticated user\&#39;s full/display name and primary email address. Commits cannot be created anonymously.
         * @param {string} [parents]  #### Deprecation Notice: Support for specifying multiple parent commits is deprecated and will be removed in a future release. Only a single SHA1 is accepted.  A SHA1 of the commit that should be the parent of the newly created commit. When omitted, the new commit will inherit from and become a child of the main branch\&#39;s tip/HEAD commit.
         * @param {string} [files]  Optional field that declares the files that the request is manipulating. When adding a new file to a repo, or when overwriting an existing file, the client can just upload the full contents of the file in a normal form field and the use of this &#x60;files&#x60; meta data field is redundant. However, when the &#x60;files&#x60; field contains a file path that does not have a corresponding, identically-named form field, then Bitbucket interprets that as the client wanting to replace the named file with the null set and the file is deleted instead.  Paths in the repo that are referenced in neither files nor an individual file field, remain unchanged and carry over from the parent to the new commit.  This API does not support renaming as an explicit feature. To rename a file, simply delete it and recreate it under the new name in the same commit. 
         * @param {string} [branch]  The name of the branch that the new commit should be created on. When omitted, the commit will be created on top of the main branch and will become the main branch\&#39;s new head.  When a branch name is provided that already exists in the repo, then the commit will be created on top of that branch. In this case, *if* a parent SHA1 was also provided, then it is asserted that the parent is the branch\&#39;s tip/HEAD at the time the request is made. When this is not the case, a 409 is returned.  When a new branch name is specified (that does not already exist in the repo), and no parent SHA1s are provided, then the new commit will inherit from the current main branch\&#39;s tip/HEAD commit, but not advance the main branch. The new commit will be the new branch. When the request *also* specifies a parent SHA1, then the new commit and branch are created directly on top of the parent commit, regardless of the state of the main branch.  When a branch name is not specified, but a parent SHA1 is provided, then Bitbucket asserts that it represents the main branch\&#39;s current HEAD/tip, or a 409 is returned.  When a branch name is not specified and the repo is empty, the new commit will become the repo\&#39;s root commit and will be on the main branch.  When a branch name is specified and the repo is empty, the new commit will become the repo\&#39;s root commit and also define the repo\&#39;s main branch going forward.  This API cannot be used to create additional root commits in non-empty repos.  The branch field cannot be repeated.  As a side effect, this API can be used to create a new branch without modifying any files, by specifying a new branch name in this field, together with &#x60;parents&#x60;, but omitting the &#x60;files&#x60; fields, while not sending any files. This will create a new commit and branch with the same contents as the first parent. The diff of this commit against its first parent will be empty. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugSrcPost: async (repoSlug: string, workspace: string, message?: string, author?: string, parents?: string, files?: string, branch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/src`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (parents !== undefined) {
                localVarQueryParameter['parents'] = parents;
            }

            if (files !== undefined) {
                localVarQueryParameter['files'] = files;
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all the watchers on the specified repository.
         * @summary List repositories watchers
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugWatchersGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugWatchersGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugWatchersGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/watchers`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object for each repository the caller has explicit access to and their effective permission  the highest level of permission the caller has. This does not return public repositories that the user was not granted any specific permission in, and does not distinguish between explicit and implicit privileges.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by repository or permission by adding the following query string parameters:  * `q=repository.name=\"geordi\"` or `q=permission>\"read\"` * `sort=repository.name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-get).
         * @summary List repository permissions for a user
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userPermissionsRepositoriesGet: async (q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/permissions/repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account", "repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoriesApi - functional programming interface
 */
export const RepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a paginated list of all public repositories.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-get).
         * @summary List public repositories
         * @param {string} [after] Filter the results to include only repositories created on or after this [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)  timestamp. Example: &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;
         * @param {RepositoriesGetRoleEnum} [role] Filters the result based on the authenticated user\&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user 
         * @param {string} [q] Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). &#x60;role&#x60; parameter must also be specified. 
         * @param {string} [sort] Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async repositoriesGet(after?: string, role?: RepositoriesGetRoleEnum, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRepositories>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesGet(after, role, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all repositories owned by the specified workspace.  The result can be narrowed down based on the authenticated user\'s role.  E.g. with `?role=contributor`, only those repositories that the authenticated user has write access to are returned (this includes any repo the user is an admin on, as that implies write access).  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List repositories in a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {RepositoriesWorkspaceGetRoleEnum} [role]  Filters the result based on the authenticated user\&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {string} [sort]  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceGet(workspace: string, role?: RepositoriesWorkspaceGetRoleEnum, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRepositories>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceGet(workspace, role, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the repository. This is an irreversible operation.  This does not affect its forks.
         * @summary Delete a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [redirectTo] If a repository has been moved to a new location, use this parameter to show users a friendly message in the Bitbucket UI that the repository has moved to a new location. However, a GET to this endpoint will still return a 404. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugDelete(repoSlug: string, workspace: string, redirectTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugDelete(repoSlug, workspace, redirectTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order <sha> <path>  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the `?renames=false` query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to only provide exactly the data you want.  The example response returns commits made before 2011-05-18 against a file named `README.rst`. The results are filtered to only return the path and date. This request can be made using:  ``` $ curl \'https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst\'\\   \'?fields=values.next,values.path,values.commit.date&q=commit.date<=2011-05-18\' ```  In the response you can see that the file was renamed to `README.rst` by the commit made on 2011-05-16, and was previously named `README.txt`.
         * @summary List commits that modified a file
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} path Path to the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [renames]  When &#x60;true&#x60;, Bitbucket will follow the history of the file across renames (this is the default behavior). This can be turned off by specifying &#x60;false&#x60;.
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet(commit: string, path: string, repoSlug: string, workspace: string, renames?: string, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFiles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet(commit, path, repoSlug, workspace, renames, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all the forks of the specified repository.
         * @summary List repository forks
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {RepositoriesWorkspaceRepoSlugForksGetRoleEnum} [role] Filters the result based on the authenticated user\&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user 
         * @param {string} [q] Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {string} [sort] Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugForksGet(repoSlug: string, workspace: string, role?: RepositoriesWorkspaceRepoSlugForksGetRoleEnum, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRepositories>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugForksGet(repoSlug, workspace, role, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugForksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new fork of the specified repository.  #### Forking a repository  To create a fork, specify the workspace explicitly as part of the request body:  ``` $ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/atlassian/bbql/forks \\   -H \'Content-Type: application/json\' -d \'{     \"name\": \"bbql_fork\",     \"workspace\": {       \"slug\": \"atlassian\"     } }\' ```  To fork a repository into the same workspace, also specify a new `name`.  When you specify a value for `name`, it will also affect the `slug`. The `slug` is reflected in the repository URL of the new fork. It is derived from `name` by substituting non-ASCII characters, removes whitespace, and changes characters to lower case. For example, `My repo` would turn into `my_repo`.  You need contributor access to create new forks within a workspace.   #### Change the properties of a new fork  By default the fork inherits most of its properties from the parent. However, since the optional POST body document follows the normal `repository` JSON schema and you can override the new fork\'s properties.  Properties that can be overridden include:  * description * fork_policy * language * mainbranch * is_private (note that a private repo\'s fork_policy might prohibit   the creation of public forks, in which `is_private=False` would fail) * has_issues (to initialize or disable the new repo\'s issue tracker --   note that the actual contents of the parent repository\'s issue   tracker are not copied during forking) * has_wiki (to initialize or disable the new repo\'s wiki --   note that the actual contents of the parent repository\'s wiki are not   copied during forking) * project (when forking into a private project, the fork\'s `is_private`   must be `true`)  Properties that cannot be modified include:  * scm * parent * full_name
         * @summary Fork a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Repository} [body] A repository object. This can be left blank.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugForksPost(repoSlug: string, workspace: string, body?: Repository, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugForksPost(repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugForksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the object describing this repository.
         * @summary Get a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of webhooks installed on this repository.
         * @summary List webhooks for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugHooksGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWebhookSubscriptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugHooksGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugHooksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new webhook on the specified repository.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  Also note that the `url` must properly resolve and cannot be an internal, non-routed address.
         * @summary Create a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugHooksPost(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugHooksPost(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugHooksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified webhook subscription from the given repository.
         * @summary Delete a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugHooksUidDelete(repoSlug: string, uid: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugHooksUidDelete(repoSlug, uid, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugHooksUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the webhook with the specified id installed on the specified repository.
         * @summary Get a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugHooksUidGet(repoSlug: string, uid: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugHooksUidGet(repoSlug, uid, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugHooksUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
         * @summary Update a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugHooksUidPut(repoSlug: string, uid: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugHooksUidPut(repoSlug, uid, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugHooksUidPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the inheritance state for repository settings
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugOverrideSettingsGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryInheritanceState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugOverrideSettingsGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugOverrideSettingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the inheritance state for repository settings                 
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugOverrideSettingsPut(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugOverrideSettingsPut(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugOverrideSettingsPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of explicit group permissions for the given repository. This endpoint does not support BBQL features.
         * @summary List explicit group permissions for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRepositoryGroupPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the repository group permission between the requested repository and group, if one exists.  Only users with admin permission for the repository may access this resource.  The only authentication method supported for this endpoint is via app passwords.
         * @summary Delete an explicit group permission for a repository
         * @param {string} groupSlug Slug of the requested group.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete(groupSlug: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete(groupSlug, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the group permission for a given group slug and repository  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read` * `none`
         * @summary Get an explicit group permission for a repository
         * @param {string} groupSlug Slug of the requested group.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet(groupSlug: string, repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryGroupPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet(groupSlug, repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the group permission, or grants a new permission if one does not already exist.  Only users with admin permission for the repository may access this resource.  The only authentication method supported for this endpoint is via app passwords.  Permissions can be:  * `admin` * `write` * `read`
         * @summary Update an explicit group permission for a repository
         * @param {string} groupSlug Slug of the requested group.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchema} body The permission to grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut(groupSlug: string, repoSlug: string, workspace: string, body: BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryGroupPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut(groupSlug, repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of explicit user permissions for the given repository. This endpoint does not support BBQL features.
         * @summary List explicit user permissions for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRepositoryUserPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the repository user permission between the requested repository and user, if one exists.  Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.
         * @summary Delete an explicit user permission for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete(repoSlug: string, selectedUserId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete(repoSlug, selectedUserId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the explicit user permission for a given user and repository.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read` * `none`
         * @summary Get an explicit user permission for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet(repoSlug: string, selectedUserId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryUserPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet(repoSlug, selectedUserId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the explicit user permission for a given user and repository. The selected user must be a member of the workspace, and cannot be the workspace owner. Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.  Permissions can be:  * `admin` * `write` * `read`
         * @summary Update an explicit user permission for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchema} body The permission to grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut(repoSlug: string, selectedUserId: string, workspace: string, body: BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryUserPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut(repoSlug, selectedUserId, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new repository.  Note: In order to set the project for the newly created repository, pass in either the project key or the project UUID as part of the request body as shown in the examples below:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{     \"scm\": \"git\",     \"project\": {         \"key\": \"MARS\"     } }\' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding ```  or  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{     \"scm\": \"git\",     \"project\": {         \"key\": \"{ba516952-992a-4c2d-acbd-17d502922f96}\"     } }\' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding ```  The project must be assigned for all repositories. If the project is not provided, the repository is automatically assigned to the oldest project in the workspace.  Note: In the examples above, the workspace ID `teamsinspace`, and/or the repository name `hablanding` can be replaced by UUIDs.
         * @summary Create a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Repository} [body] The repository that is to be created. Note that most object elements are optional. Elements \&quot;owner\&quot; and \&quot;full_name\&quot; are ignored as the URL implies them.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPost(repoSlug: string, workspace: string, body?: Repository, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPost(repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Since this endpoint can be used to both update and to create a repository, the request body depends on the intent.  #### Creation  See the POST documentation for the repository endpoint for an example of the request body.  #### Update  Note: Changing the `name` of the repository will cause the location to be changed. This is because the URL of the repo is derived from the name (a process called slugification). In such a scenario, it is possible for the request to fail if the newly created slug conflicts with an existing repository\'s slug. But if there is no conflict, the new location will be returned in the `Location` header of the response.
         * @summary Update a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Repository} [body] The repository that is to be updated.  Note that the elements \&quot;owner\&quot; and \&quot;full_name\&quot; are ignored since the URL implies them. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugPut(repoSlug: string, workspace: string, body?: Repository, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugPut(repoSlug, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  #### Raw file contents  When `path` points to a file, this endpoint returns the raw contents. The response\'s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The `Content-Disposition` header will be \"attachment\" to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian\'s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty `__init__.py` always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  #### File meta data  When the request for a file path includes the query parameter `?format=meta`, instead of returning the file\'s raw contents, Bitbucket instead returns the JSON object describing the file\'s properties:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format=meta {   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"     }   },   \"path\": \"tests/__init__.py\",   \"commit\": {     \"type\": \"commit\",     \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"       },       \"html\": {         \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"       }     }   },   \"attributes\": [],   \"type\": \"commit_file\",   \"size\": 0 } ```  File objects contain an `attributes` element that contains a list of possible modifiers. Currently defined values are:  * `link` -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * `executable` -- indicates that the file has the executable bit set. * `subrepository` -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * `binary` -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file\'s size without incurring the overhead of receiving its full contents.   #### Directory listings  When `path` points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \"pagelen\": 10,   \"values\": [     {       \"path\": \"tests/test_project\",       \"type\": \"commit_directory\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"         }       },       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       }     },     {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"         }       },       \"path\": \"tests/__init__.py\",       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       },       \"attributes\": [],       \"type\": \"commit_file\",       \"size\": 0     }   ],   \"page\": 1,   \"size\": 2 } ```  When listing the contents of the repo\'s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \"walk\" the entire directory tree, the client can either parse each response and follow the `self` links of each `commit_directory` object, or can specify a `max_depth` to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the `max_depth` parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a `commit_file`, or a `commit_directory`, both of which contain a `path` element. This path is the absolute path from the root of the repository. Each object also contains a `commit` object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their `self` link returns the paginated contents of the directory. The `meta` link on the other hand returns the actual `directory` object itself, e.g.:  ```javascript {   \"path\": \"tests/test_project\",   \"type\": \"commit_directory\",   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"     }   },   \"commit\": { ... } } ```  #### Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  `size > 1024 and attributes = \"binary\"`  which after urlencoding yields the query string:  `?q=size%3E1024+and+attributes%3D%22binary%22`  To change the ordering of the response, use the `?sort` parameter:  `.../src/eefd5ef/?sort=-size`  See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary Get file or directory contents
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} path Path to the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {RepositoriesWorkspaceRepoSlugSrcCommitPathGetFormatEnum} [format] If \&#39;meta\&#39; is provided, returns the (json) meta data for the contents of the file.  If \&#39;rendered\&#39; is provided, returns the contents of a non-binary file in HTML-formatted rendered markup. The \&#39;rendered\&#39; option only supports these filetypes: &#x60;.md&#x60;, &#x60;.markdown&#x60;, &#x60;.mkd&#x60;, &#x60;.mkdn&#x60;, &#x60;.mdown&#x60;, &#x60;.text&#x60;, &#x60;.rst&#x60;, and &#x60;.textile&#x60;. Since Git does not generally track what text encoding scheme is used, this endpoint attempts to detect the most appropriate character encoding. While usually correct, determining the character encoding can be ambiguous which in exceptional cases can lead to misinterpretation of the characters. As such, the raw element in the response object should not be treated as equivalent to the file\&#39;s actual contents.
         * @param {string} [q] Optional filter expression as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort] Optional sorting parameter as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results).
         * @param {number} [maxDepth] If provided, returns the contents of the repository and its subdirectories recursively until the specified max_depth of nested directories. When omitted, this defaults to 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugSrcCommitPathGet(commit: string, path: string, repoSlug: string, workspace: string, format?: RepositoriesWorkspaceRepoSlugSrcCommitPathGetFormatEnum, q?: string, sort?: string, maxDepth?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTreeentries>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugSrcCommitPathGet(commit, path, repoSlug, workspace, format, q, sort, maxDepth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugSrcCommitPathGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo\'s main branch.  To create new commits, [POST to this endpoint](#post)
         * @summary Get the root directory of the main branch
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {RepositoriesWorkspaceRepoSlugSrcGetFormatEnum} [format] Instead of returning the file\&#39;s contents, return the (json) meta data for it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugSrcGet(repoSlug: string, workspace: string, format?: RepositoriesWorkspaceRepoSlugSrcGetFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTreeentries>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugSrcGet(repoSlug, workspace, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugSrcGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png=@image.png ```  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the `image.png` file to the repository in the `/repo/path/to` directory.  To create a commit that deletes files, use the `files` parameter:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files=/file/to/delete/1.txt \\   -F files=/file/to/delete/2.txt ```  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts `multipart/form-data` (as in the examples above), as well as `application/x-www-form-urlencoded`.  Note: `multipart/form-data` is currently not supported by Forge apps for this API.  #### multipart/form-data  A `multipart/form-data` post contains a series of \"form fields\" that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a `Content-Disposition` parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above `curl` example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For `multipart/form-data` bodies that should not lead to any ambiguity, as the `Content-Disposition` header will contain the `filename` parameter to distinguish between a file named \"message\" and the commit message field.  #### application/x-www-form-urlencoded  It is also possible to upload new files using a simple `application/x-www-form-urlencoded` POST. This can be convenient when uploading pure text files:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \"/path/to/me.txt=Lorem ipsum.\" \\   --data-urlencode \"message=Initial commit\" \\   --data-urlencode \"author=Erik van Zijst <erik.van.zijst@gmail.com>\" ```  There could be a field name clash if a client were to upload a file named \"message\", as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. `curl --data-urlencode \"/message=file contents\"`.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  #### Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a `x-attributes` value in the `Content-Disposition` header. For example, to upload an executable file, as well as create a symlink from `README.txt` to `README`:  ``` --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"bin/shutdown.sh\" Content-Disposition: attachment; filename=\"shutdown.sh\"; x-attributes:\"executable\"  #!/bin/sh halt  --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"/README.txt\" Content-Disposition: attachment; filename=\"README.txt\"; x-attributes:\"link\"  README --===============1438169132528273974==-- ```  Links are files that contain the target path and have `x-attributes:\"link\"` set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying `x-attributes=\"link\"` will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include `x-attributes=\"executable\"` in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.
         * @summary Create a commit by uploading a file
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [message] The commit message. When omitted, Bitbucket uses a canned string.
         * @param {string} [author]  The raw string to be used as the new commit\&#39;s author. This string follows the format &#x60;Erik van Zijst &lt;evzijst@atlassian.com&gt;&#x60;.  When omitted, Bitbucket uses the authenticated user\&#39;s full/display name and primary email address. Commits cannot be created anonymously.
         * @param {string} [parents]  #### Deprecation Notice: Support for specifying multiple parent commits is deprecated and will be removed in a future release. Only a single SHA1 is accepted.  A SHA1 of the commit that should be the parent of the newly created commit. When omitted, the new commit will inherit from and become a child of the main branch\&#39;s tip/HEAD commit.
         * @param {string} [files]  Optional field that declares the files that the request is manipulating. When adding a new file to a repo, or when overwriting an existing file, the client can just upload the full contents of the file in a normal form field and the use of this &#x60;files&#x60; meta data field is redundant. However, when the &#x60;files&#x60; field contains a file path that does not have a corresponding, identically-named form field, then Bitbucket interprets that as the client wanting to replace the named file with the null set and the file is deleted instead.  Paths in the repo that are referenced in neither files nor an individual file field, remain unchanged and carry over from the parent to the new commit.  This API does not support renaming as an explicit feature. To rename a file, simply delete it and recreate it under the new name in the same commit. 
         * @param {string} [branch]  The name of the branch that the new commit should be created on. When omitted, the commit will be created on top of the main branch and will become the main branch\&#39;s new head.  When a branch name is provided that already exists in the repo, then the commit will be created on top of that branch. In this case, *if* a parent SHA1 was also provided, then it is asserted that the parent is the branch\&#39;s tip/HEAD at the time the request is made. When this is not the case, a 409 is returned.  When a new branch name is specified (that does not already exist in the repo), and no parent SHA1s are provided, then the new commit will inherit from the current main branch\&#39;s tip/HEAD commit, but not advance the main branch. The new commit will be the new branch. When the request *also* specifies a parent SHA1, then the new commit and branch are created directly on top of the parent commit, regardless of the state of the main branch.  When a branch name is not specified, but a parent SHA1 is provided, then Bitbucket asserts that it represents the main branch\&#39;s current HEAD/tip, or a 409 is returned.  When a branch name is not specified and the repo is empty, the new commit will become the repo\&#39;s root commit and will be on the main branch.  When a branch name is specified and the repo is empty, the new commit will become the repo\&#39;s root commit and also define the repo\&#39;s main branch going forward.  This API cannot be used to create additional root commits in non-empty repos.  The branch field cannot be repeated.  As a side effect, this API can be used to create a new branch without modifying any files, by specifying a new branch name in this field, together with &#x60;parents&#x60;, but omitting the &#x60;files&#x60; fields, while not sending any files. This will create a new commit and branch with the same contents as the first parent. The diff of this commit against its first parent will be empty. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugSrcPost(repoSlug: string, workspace: string, message?: string, author?: string, parents?: string, files?: string, branch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugSrcPost(repoSlug, workspace, message, author, parents, files, branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugSrcPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all the watchers on the specified repository.
         * @summary List repositories watchers
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugWatchersGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAccounts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugWatchersGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesWorkspaceRepoSlugWatchersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an object for each repository the caller has explicit access to and their effective permission  the highest level of permission the caller has. This does not return public repositories that the user was not granted any specific permission in, and does not distinguish between explicit and implicit privileges.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by repository or permission by adding the following query string parameters:  * `q=repository.name=\"geordi\"` or `q=permission>\"read\"` * `sort=repository.name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-get).
         * @summary List repository permissions for a user
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async userPermissionsRepositoriesGet(q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRepositoryPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPermissionsRepositoriesGet(q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.userPermissionsRepositoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RepositoriesApi - factory interface
 */
export const RepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoriesApiFp(configuration)
    return {
        /**
         * Returns a paginated list of all public repositories.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-get).
         * @summary List public repositories
         * @param {RepositoriesApiRepositoriesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        repositoriesGet(requestParameters: RepositoriesApiRepositoriesGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositories> {
            return localVarFp.repositoriesGet(requestParameters.after, requestParameters.role, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all repositories owned by the specified workspace.  The result can be narrowed down based on the authenticated user\'s role.  E.g. with `?role=contributor`, only those repositories that the authenticated user has write access to are returned (this includes any repo the user is an admin on, as that implies write access).  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List repositories in a workspace
         * @param {RepositoriesApiRepositoriesWorkspaceGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceGet(requestParameters: RepositoriesApiRepositoriesWorkspaceGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositories> {
            return localVarFp.repositoriesWorkspaceGet(requestParameters.workspace, requestParameters.role, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the repository. This is an irreversible operation.  This does not affect its forks.
         * @summary Delete a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugDelete(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugDelete(requestParameters.repoSlug, requestParameters.workspace, requestParameters.redirectTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order <sha> <path>  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the `?renames=false` query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to only provide exactly the data you want.  The example response returns commits made before 2011-05-18 against a file named `README.rst`. The results are filtered to only return the path and date. This request can be made using:  ``` $ curl \'https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst\'\\   \'?fields=values.next,values.path,values.commit.date&q=commit.date<=2011-05-18\' ```  In the response you can see that the file was renamed to `README.rst` by the commit made on 2011-05-16, and was previously named `README.txt`.
         * @summary List commits that modified a file
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugFilehistoryCommitPathGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugFilehistoryCommitPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedFiles> {
            return localVarFp.repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet(requestParameters.commit, requestParameters.path, requestParameters.repoSlug, requestParameters.workspace, requestParameters.renames, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all the forks of the specified repository.
         * @summary List repository forks
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugForksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugForksGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugForksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositories> {
            return localVarFp.repositoriesWorkspaceRepoSlugForksGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.role, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new fork of the specified repository.  #### Forking a repository  To create a fork, specify the workspace explicitly as part of the request body:  ``` $ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/atlassian/bbql/forks \\   -H \'Content-Type: application/json\' -d \'{     \"name\": \"bbql_fork\",     \"workspace\": {       \"slug\": \"atlassian\"     } }\' ```  To fork a repository into the same workspace, also specify a new `name`.  When you specify a value for `name`, it will also affect the `slug`. The `slug` is reflected in the repository URL of the new fork. It is derived from `name` by substituting non-ASCII characters, removes whitespace, and changes characters to lower case. For example, `My repo` would turn into `my_repo`.  You need contributor access to create new forks within a workspace.   #### Change the properties of a new fork  By default the fork inherits most of its properties from the parent. However, since the optional POST body document follows the normal `repository` JSON schema and you can override the new fork\'s properties.  Properties that can be overridden include:  * description * fork_policy * language * mainbranch * is_private (note that a private repo\'s fork_policy might prohibit   the creation of public forks, in which `is_private=False` would fail) * has_issues (to initialize or disable the new repo\'s issue tracker --   note that the actual contents of the parent repository\'s issue   tracker are not copied during forking) * has_wiki (to initialize or disable the new repo\'s wiki --   note that the actual contents of the parent repository\'s wiki are not   copied during forking) * project (when forking into a private project, the fork\'s `is_private`   must be `true`)  Properties that cannot be modified include:  * scm * parent * full_name
         * @summary Fork a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugForksPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugForksPost(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugForksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Repository> {
            return localVarFp.repositoriesWorkspaceRepoSlugForksPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the object describing this repository.
         * @summary Get a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Repository> {
            return localVarFp.repositoriesWorkspaceRepoSlugGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of webhooks installed on this repository.
         * @summary List webhooks for a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWebhookSubscriptions> {
            return localVarFp.repositoriesWorkspaceRepoSlugHooksGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new webhook on the specified repository.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  Also note that the `url` must properly resolve and cannot be an internal, non-routed address.
         * @summary Create a webhook for a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksPost(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription> {
            return localVarFp.repositoriesWorkspaceRepoSlugHooksPost(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified webhook subscription from the given repository.
         * @summary Delete a webhook for a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksUidDelete(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugHooksUidDelete(requestParameters.repoSlug, requestParameters.uid, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the webhook with the specified id installed on the specified repository.
         * @summary Get a webhook for a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksUidGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription> {
            return localVarFp.repositoriesWorkspaceRepoSlugHooksUidGet(requestParameters.repoSlug, requestParameters.uid, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
         * @summary Update a webhook for a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksUidPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription> {
            return localVarFp.repositoriesWorkspaceRepoSlugHooksUidPut(requestParameters.repoSlug, requestParameters.uid, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the inheritance state for repository settings
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugOverrideSettingsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugOverrideSettingsGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugOverrideSettingsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryInheritanceState> {
            return localVarFp.repositoriesWorkspaceRepoSlugOverrideSettingsGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the inheritance state for repository settings                 
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugOverrideSettingsPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugOverrideSettingsPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugOverrideSettingsPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugOverrideSettingsPut(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of explicit group permissions for the given repository. This endpoint does not support BBQL features.
         * @summary List explicit group permissions for a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositoryGroupPermissions> {
            return localVarFp.repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the repository group permission between the requested repository and group, if one exists.  Only users with admin permission for the repository may access this resource.  The only authentication method supported for this endpoint is via app passwords.
         * @summary Delete an explicit group permission for a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete(requestParameters.groupSlug, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the group permission for a given group slug and repository  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read` * `none`
         * @summary Get an explicit group permission for a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryGroupPermission> {
            return localVarFp.repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet(requestParameters.groupSlug, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the group permission, or grants a new permission if one does not already exist.  Only users with admin permission for the repository may access this resource.  The only authentication method supported for this endpoint is via app passwords.  Permissions can be:  * `admin` * `write` * `read`
         * @summary Update an explicit group permission for a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryGroupPermission> {
            return localVarFp.repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut(requestParameters.groupSlug, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of explicit user permissions for the given repository. This endpoint does not support BBQL features.
         * @summary List explicit user permissions for a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositoryUserPermissions> {
            return localVarFp.repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the repository user permission between the requested repository and user, if one exists.  Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.
         * @summary Delete an explicit user permission for a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete(requestParameters.repoSlug, requestParameters.selectedUserId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the explicit user permission for a given user and repository.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read` * `none`
         * @summary Get an explicit user permission for a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryUserPermission> {
            return localVarFp.repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet(requestParameters.repoSlug, requestParameters.selectedUserId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the explicit user permission for a given user and repository. The selected user must be a member of the workspace, and cannot be the workspace owner. Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.  Permissions can be:  * `admin` * `write` * `read`
         * @summary Update an explicit user permission for a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryUserPermission> {
            return localVarFp.repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut(requestParameters.repoSlug, requestParameters.selectedUserId, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new repository.  Note: In order to set the project for the newly created repository, pass in either the project key or the project UUID as part of the request body as shown in the examples below:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{     \"scm\": \"git\",     \"project\": {         \"key\": \"MARS\"     } }\' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding ```  or  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{     \"scm\": \"git\",     \"project\": {         \"key\": \"{ba516952-992a-4c2d-acbd-17d502922f96}\"     } }\' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding ```  The project must be assigned for all repositories. If the project is not provided, the repository is automatically assigned to the oldest project in the workspace.  Note: In the examples above, the workspace ID `teamsinspace`, and/or the repository name `hablanding` can be replaced by UUIDs.
         * @summary Create a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPost(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Repository> {
            return localVarFp.repositoriesWorkspaceRepoSlugPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Since this endpoint can be used to both update and to create a repository, the request body depends on the intent.  #### Creation  See the POST documentation for the repository endpoint for an example of the request body.  #### Update  Note: Changing the `name` of the repository will cause the location to be changed. This is because the URL of the repo is derived from the name (a process called slugification). In such a scenario, it is possible for the request to fail if the newly created slug conflicts with an existing repository\'s slug. But if there is no conflict, the new location will be returned in the `Location` header of the response.
         * @summary Update a repository
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Repository> {
            return localVarFp.repositoriesWorkspaceRepoSlugPut(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  #### Raw file contents  When `path` points to a file, this endpoint returns the raw contents. The response\'s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The `Content-Disposition` header will be \"attachment\" to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian\'s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty `__init__.py` always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  #### File meta data  When the request for a file path includes the query parameter `?format=meta`, instead of returning the file\'s raw contents, Bitbucket instead returns the JSON object describing the file\'s properties:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format=meta {   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"     }   },   \"path\": \"tests/__init__.py\",   \"commit\": {     \"type\": \"commit\",     \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"       },       \"html\": {         \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"       }     }   },   \"attributes\": [],   \"type\": \"commit_file\",   \"size\": 0 } ```  File objects contain an `attributes` element that contains a list of possible modifiers. Currently defined values are:  * `link` -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * `executable` -- indicates that the file has the executable bit set. * `subrepository` -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * `binary` -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file\'s size without incurring the overhead of receiving its full contents.   #### Directory listings  When `path` points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \"pagelen\": 10,   \"values\": [     {       \"path\": \"tests/test_project\",       \"type\": \"commit_directory\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"         }       },       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       }     },     {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"         }       },       \"path\": \"tests/__init__.py\",       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       },       \"attributes\": [],       \"type\": \"commit_file\",       \"size\": 0     }   ],   \"page\": 1,   \"size\": 2 } ```  When listing the contents of the repo\'s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \"walk\" the entire directory tree, the client can either parse each response and follow the `self` links of each `commit_directory` object, or can specify a `max_depth` to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the `max_depth` parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a `commit_file`, or a `commit_directory`, both of which contain a `path` element. This path is the absolute path from the root of the repository. Each object also contains a `commit` object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their `self` link returns the paginated contents of the directory. The `meta` link on the other hand returns the actual `directory` object itself, e.g.:  ```javascript {   \"path\": \"tests/test_project\",   \"type\": \"commit_directory\",   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"     }   },   \"commit\": { ... } } ```  #### Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  `size > 1024 and attributes = \"binary\"`  which after urlencoding yields the query string:  `?q=size%3E1024+and+attributes%3D%22binary%22`  To change the ordering of the response, use the `?sort` parameter:  `.../src/eefd5ef/?sort=-size`  See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary Get file or directory contents
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugSrcCommitPathGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugSrcCommitPathGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugSrcCommitPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTreeentries> {
            return localVarFp.repositoriesWorkspaceRepoSlugSrcCommitPathGet(requestParameters.commit, requestParameters.path, requestParameters.repoSlug, requestParameters.workspace, requestParameters.format, requestParameters.q, requestParameters.sort, requestParameters.maxDepth, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo\'s main branch.  To create new commits, [POST to this endpoint](#post)
         * @summary Get the root directory of the main branch
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugSrcGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugSrcGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugSrcGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTreeentries> {
            return localVarFp.repositoriesWorkspaceRepoSlugSrcGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.format, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png=@image.png ```  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the `image.png` file to the repository in the `/repo/path/to` directory.  To create a commit that deletes files, use the `files` parameter:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files=/file/to/delete/1.txt \\   -F files=/file/to/delete/2.txt ```  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts `multipart/form-data` (as in the examples above), as well as `application/x-www-form-urlencoded`.  Note: `multipart/form-data` is currently not supported by Forge apps for this API.  #### multipart/form-data  A `multipart/form-data` post contains a series of \"form fields\" that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a `Content-Disposition` parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above `curl` example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For `multipart/form-data` bodies that should not lead to any ambiguity, as the `Content-Disposition` header will contain the `filename` parameter to distinguish between a file named \"message\" and the commit message field.  #### application/x-www-form-urlencoded  It is also possible to upload new files using a simple `application/x-www-form-urlencoded` POST. This can be convenient when uploading pure text files:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \"/path/to/me.txt=Lorem ipsum.\" \\   --data-urlencode \"message=Initial commit\" \\   --data-urlencode \"author=Erik van Zijst <erik.van.zijst@gmail.com>\" ```  There could be a field name clash if a client were to upload a file named \"message\", as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. `curl --data-urlencode \"/message=file contents\"`.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  #### Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a `x-attributes` value in the `Content-Disposition` header. For example, to upload an executable file, as well as create a symlink from `README.txt` to `README`:  ``` --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"bin/shutdown.sh\" Content-Disposition: attachment; filename=\"shutdown.sh\"; x-attributes:\"executable\"  #!/bin/sh halt  --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"/README.txt\" Content-Disposition: attachment; filename=\"README.txt\"; x-attributes:\"link\"  README --===============1438169132528273974==-- ```  Links are files that contain the target path and have `x-attributes:\"link\"` set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying `x-attributes=\"link\"` will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include `x-attributes=\"executable\"` in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.
         * @summary Create a commit by uploading a file
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugSrcPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugSrcPost(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugSrcPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugSrcPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.message, requestParameters.author, requestParameters.parents, requestParameters.files, requestParameters.branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all the watchers on the specified repository.
         * @summary List repositories watchers
         * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugWatchersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugWatchersGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugWatchersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAccounts> {
            return localVarFp.repositoriesWorkspaceRepoSlugWatchersGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object for each repository the caller has explicit access to and their effective permission  the highest level of permission the caller has. This does not return public repositories that the user was not granted any specific permission in, and does not distinguish between explicit and implicit privileges.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by repository or permission by adding the following query string parameters:  * `q=repository.name=\"geordi\"` or `q=permission>\"read\"` * `sort=repository.name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-get).
         * @summary List repository permissions for a user
         * @param {RepositoriesApiUserPermissionsRepositoriesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userPermissionsRepositoriesGet(requestParameters: RepositoriesApiUserPermissionsRepositoriesGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositoryPermissions> {
            return localVarFp.userPermissionsRepositoriesGet(requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoriesApi - interface
 */
export interface RepositoriesApiInterface {
    /**
     * Returns a paginated list of all public repositories.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-get).
     * @summary List public repositories
     * @param {RepositoriesApiRepositoriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    repositoriesGet(requestParameters?: RepositoriesApiRepositoriesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositories>;

    /**
     * Returns a paginated list of all repositories owned by the specified workspace.  The result can be narrowed down based on the authenticated user\'s role.  E.g. with `?role=contributor`, only those repositories that the authenticated user has write access to are returned (this includes any repo the user is an admin on, as that implies write access).  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary List repositories in a workspace
     * @param {RepositoriesApiRepositoriesWorkspaceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceGet(requestParameters: RepositoriesApiRepositoriesWorkspaceGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositories>;

    /**
     * Deletes the repository. This is an irreversible operation.  This does not affect its forks.
     * @summary Delete a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugDelete(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order <sha> <path>  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the `?renames=false` query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to only provide exactly the data you want.  The example response returns commits made before 2011-05-18 against a file named `README.rst`. The results are filtered to only return the path and date. This request can be made using:  ``` $ curl \'https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst\'\\   \'?fields=values.next,values.path,values.commit.date&q=commit.date<=2011-05-18\' ```  In the response you can see that the file was renamed to `README.rst` by the commit made on 2011-05-16, and was previously named `README.txt`.
     * @summary List commits that modified a file
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugFilehistoryCommitPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugFilehistoryCommitPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedFiles>;

    /**
     * Returns a paginated list of all the forks of the specified repository.
     * @summary List repository forks
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugForksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugForksGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugForksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositories>;

    /**
     * Creates a new fork of the specified repository.  #### Forking a repository  To create a fork, specify the workspace explicitly as part of the request body:  ``` $ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/atlassian/bbql/forks \\   -H \'Content-Type: application/json\' -d \'{     \"name\": \"bbql_fork\",     \"workspace\": {       \"slug\": \"atlassian\"     } }\' ```  To fork a repository into the same workspace, also specify a new `name`.  When you specify a value for `name`, it will also affect the `slug`. The `slug` is reflected in the repository URL of the new fork. It is derived from `name` by substituting non-ASCII characters, removes whitespace, and changes characters to lower case. For example, `My repo` would turn into `my_repo`.  You need contributor access to create new forks within a workspace.   #### Change the properties of a new fork  By default the fork inherits most of its properties from the parent. However, since the optional POST body document follows the normal `repository` JSON schema and you can override the new fork\'s properties.  Properties that can be overridden include:  * description * fork_policy * language * mainbranch * is_private (note that a private repo\'s fork_policy might prohibit   the creation of public forks, in which `is_private=False` would fail) * has_issues (to initialize or disable the new repo\'s issue tracker --   note that the actual contents of the parent repository\'s issue   tracker are not copied during forking) * has_wiki (to initialize or disable the new repo\'s wiki --   note that the actual contents of the parent repository\'s wiki are not   copied during forking) * project (when forking into a private project, the fork\'s `is_private`   must be `true`)  Properties that cannot be modified include:  * scm * parent * full_name
     * @summary Fork a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugForksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugForksPost(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugForksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * Returns the object describing this repository.
     * @summary Get a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * Returns a paginated list of webhooks installed on this repository.
     * @summary List webhooks for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugHooksGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWebhookSubscriptions>;

    /**
     * Creates a new webhook on the specified repository.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  Also note that the `url` must properly resolve and cannot be an internal, non-routed address.
     * @summary Create a webhook for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugHooksPost(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription>;

    /**
     * Deletes the specified webhook subscription from the given repository.
     * @summary Delete a webhook for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugHooksUidDelete(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the webhook with the specified id installed on the specified repository.
     * @summary Get a webhook for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugHooksUidGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription>;

    /**
     * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
     * @summary Update a webhook for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugHooksUidPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription>;

    /**
     * 
     * @summary Retrieve the inheritance state for repository settings
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugOverrideSettingsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugOverrideSettingsGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugOverrideSettingsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryInheritanceState>;

    /**
     * 
     * @summary Set the inheritance state for repository settings                 
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugOverrideSettingsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugOverrideSettingsPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugOverrideSettingsPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a paginated list of explicit group permissions for the given repository. This endpoint does not support BBQL features.
     * @summary List explicit group permissions for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositoryGroupPermissions>;

    /**
     * Deletes the repository group permission between the requested repository and group, if one exists.  Only users with admin permission for the repository may access this resource.  The only authentication method supported for this endpoint is via app passwords.
     * @summary Delete an explicit group permission for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the group permission for a given group slug and repository  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read` * `none`
     * @summary Get an explicit group permission for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryGroupPermission>;

    /**
     * Updates the group permission, or grants a new permission if one does not already exist.  Only users with admin permission for the repository may access this resource.  The only authentication method supported for this endpoint is via app passwords.  Permissions can be:  * `admin` * `write` * `read`
     * @summary Update an explicit group permission for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryGroupPermission>;

    /**
     * Returns a paginated list of explicit user permissions for the given repository. This endpoint does not support BBQL features.
     * @summary List explicit user permissions for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositoryUserPermissions>;

    /**
     * Deletes the repository user permission between the requested repository and user, if one exists.  Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.
     * @summary Delete an explicit user permission for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the explicit user permission for a given user and repository.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read` * `none`
     * @summary Get an explicit user permission for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryUserPermission>;

    /**
     * Updates the explicit user permission for a given user and repository. The selected user must be a member of the workspace, and cannot be the workspace owner. Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.  Permissions can be:  * `admin` * `write` * `read`
     * @summary Update an explicit user permission for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryUserPermission>;

    /**
     * Creates a new repository.  Note: In order to set the project for the newly created repository, pass in either the project key or the project UUID as part of the request body as shown in the examples below:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{     \"scm\": \"git\",     \"project\": {         \"key\": \"MARS\"     } }\' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding ```  or  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{     \"scm\": \"git\",     \"project\": {         \"key\": \"{ba516952-992a-4c2d-acbd-17d502922f96}\"     } }\' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding ```  The project must be assigned for all repositories. If the project is not provided, the repository is automatically assigned to the oldest project in the workspace.  Note: In the examples above, the workspace ID `teamsinspace`, and/or the repository name `hablanding` can be replaced by UUIDs.
     * @summary Create a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPost(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * Since this endpoint can be used to both update and to create a repository, the request body depends on the intent.  #### Creation  See the POST documentation for the repository endpoint for an example of the request body.  #### Update  Note: Changing the `name` of the repository will cause the location to be changed. This is because the URL of the repo is derived from the name (a process called slugification). In such a scenario, it is possible for the request to fail if the newly created slug conflicts with an existing repository\'s slug. But if there is no conflict, the new location will be returned in the `Location` header of the response.
     * @summary Update a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  #### Raw file contents  When `path` points to a file, this endpoint returns the raw contents. The response\'s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The `Content-Disposition` header will be \"attachment\" to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian\'s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty `__init__.py` always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  #### File meta data  When the request for a file path includes the query parameter `?format=meta`, instead of returning the file\'s raw contents, Bitbucket instead returns the JSON object describing the file\'s properties:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format=meta {   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"     }   },   \"path\": \"tests/__init__.py\",   \"commit\": {     \"type\": \"commit\",     \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"       },       \"html\": {         \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"       }     }   },   \"attributes\": [],   \"type\": \"commit_file\",   \"size\": 0 } ```  File objects contain an `attributes` element that contains a list of possible modifiers. Currently defined values are:  * `link` -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * `executable` -- indicates that the file has the executable bit set. * `subrepository` -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * `binary` -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file\'s size without incurring the overhead of receiving its full contents.   #### Directory listings  When `path` points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \"pagelen\": 10,   \"values\": [     {       \"path\": \"tests/test_project\",       \"type\": \"commit_directory\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"         }       },       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       }     },     {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"         }       },       \"path\": \"tests/__init__.py\",       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       },       \"attributes\": [],       \"type\": \"commit_file\",       \"size\": 0     }   ],   \"page\": 1,   \"size\": 2 } ```  When listing the contents of the repo\'s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \"walk\" the entire directory tree, the client can either parse each response and follow the `self` links of each `commit_directory` object, or can specify a `max_depth` to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the `max_depth` parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a `commit_file`, or a `commit_directory`, both of which contain a `path` element. This path is the absolute path from the root of the repository. Each object also contains a `commit` object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their `self` link returns the paginated contents of the directory. The `meta` link on the other hand returns the actual `directory` object itself, e.g.:  ```javascript {   \"path\": \"tests/test_project\",   \"type\": \"commit_directory\",   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"     }   },   \"commit\": { ... } } ```  #### Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  `size > 1024 and attributes = \"binary\"`  which after urlencoding yields the query string:  `?q=size%3E1024+and+attributes%3D%22binary%22`  To change the ordering of the response, use the `?sort` parameter:  `.../src/eefd5ef/?sort=-size`  See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary Get file or directory contents
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugSrcCommitPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugSrcCommitPathGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugSrcCommitPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTreeentries>;

    /**
     * This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo\'s main branch.  To create new commits, [POST to this endpoint](#post)
     * @summary Get the root directory of the main branch
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugSrcGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugSrcGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugSrcGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTreeentries>;

    /**
     * This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png=@image.png ```  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the `image.png` file to the repository in the `/repo/path/to` directory.  To create a commit that deletes files, use the `files` parameter:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files=/file/to/delete/1.txt \\   -F files=/file/to/delete/2.txt ```  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts `multipart/form-data` (as in the examples above), as well as `application/x-www-form-urlencoded`.  Note: `multipart/form-data` is currently not supported by Forge apps for this API.  #### multipart/form-data  A `multipart/form-data` post contains a series of \"form fields\" that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a `Content-Disposition` parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above `curl` example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For `multipart/form-data` bodies that should not lead to any ambiguity, as the `Content-Disposition` header will contain the `filename` parameter to distinguish between a file named \"message\" and the commit message field.  #### application/x-www-form-urlencoded  It is also possible to upload new files using a simple `application/x-www-form-urlencoded` POST. This can be convenient when uploading pure text files:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \"/path/to/me.txt=Lorem ipsum.\" \\   --data-urlencode \"message=Initial commit\" \\   --data-urlencode \"author=Erik van Zijst <erik.van.zijst@gmail.com>\" ```  There could be a field name clash if a client were to upload a file named \"message\", as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. `curl --data-urlencode \"/message=file contents\"`.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  #### Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a `x-attributes` value in the `Content-Disposition` header. For example, to upload an executable file, as well as create a symlink from `README.txt` to `README`:  ``` --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"bin/shutdown.sh\" Content-Disposition: attachment; filename=\"shutdown.sh\"; x-attributes:\"executable\"  #!/bin/sh halt  --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"/README.txt\" Content-Disposition: attachment; filename=\"README.txt\"; x-attributes:\"link\"  README --===============1438169132528273974==-- ```  Links are files that contain the target path and have `x-attributes:\"link\"` set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying `x-attributes=\"link\"` will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include `x-attributes=\"executable\"` in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.
     * @summary Create a commit by uploading a file
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugSrcPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugSrcPost(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugSrcPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a paginated list of all the watchers on the specified repository.
     * @summary List repositories watchers
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugWatchersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugWatchersGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugWatchersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAccounts>;

    /**
     * Returns an object for each repository the caller has explicit access to and their effective permission  the highest level of permission the caller has. This does not return public repositories that the user was not granted any specific permission in, and does not distinguish between explicit and implicit privileges.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by repository or permission by adding the following query string parameters:  * `q=repository.name=\"geordi\"` or `q=permission>\"read\"` * `sort=repository.name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-get).
     * @summary List repository permissions for a user
     * @param {RepositoriesApiUserPermissionsRepositoriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userPermissionsRepositoriesGet(requestParameters?: RepositoriesApiUserPermissionsRepositoriesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositoryPermissions>;

}

/**
 * Request parameters for repositoriesGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesGetRequest {
    /**
     * Filter the results to include only repositories created on or after this [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)  timestamp. Example: &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;
     */
    readonly after?: string

    /**
     * Filters the result based on the authenticated user\&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user 
     */
    readonly role?: RepositoriesGetRoleEnum

    /**
     * Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). &#x60;role&#x60; parameter must also be specified. 
     */
    readonly q?: string

    /**
     * Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
     */
    readonly sort?: string
}

/**
 * Request parameters for repositoriesWorkspaceGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceGetRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     *  Filters the result based on the authenticated user\&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user 
     */
    readonly role?: RepositoriesWorkspaceGetRoleEnum

    /**
     *  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
     */
    readonly q?: string

    /**
     *  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).         
     */
    readonly sort?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugDelete operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugDeleteRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * If a repository has been moved to a new location, use this parameter to show users a friendly message in the Bitbucket UI that the repository has moved to a new location. However, a GET to this endpoint will still return a 404. 
     */
    readonly redirectTo?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugFilehistoryCommitPathGetRequest {
    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * Path to the file.
     */
    readonly path: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     *  When &#x60;true&#x60;, Bitbucket will follow the history of the file across renames (this is the default behavior). This can be turned off by specifying &#x60;false&#x60;.
     */
    readonly renames?: string

    /**
     *  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
     */
    readonly q?: string

    /**
     *  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). 
     */
    readonly sort?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugForksGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugForksGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * Filters the result based on the authenticated user\&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user 
     */
    readonly role?: RepositoriesWorkspaceRepoSlugForksGetRoleEnum

    /**
     * Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
     */
    readonly q?: string

    /**
     * Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). 
     */
    readonly sort?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugForksPost operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugForksPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * A repository object. This can be left blank.
     */
    readonly body?: Repository
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugHooksGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugHooksGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugHooksPost operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugHooksPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugHooksUidDelete operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidDeleteRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * Installed webhook\&#39;s ID
     */
    readonly uid: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugHooksUidGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * Installed webhook\&#39;s ID
     */
    readonly uid: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugHooksUidPut operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidPutRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * Installed webhook\&#39;s ID
     */
    readonly uid: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugOverrideSettingsGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugOverrideSettingsGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugOverrideSettingsPut operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugOverrideSettingsPutRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteRequest {
    /**
     * Slug of the requested group.
     */
    readonly groupSlug: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetRequest {
    /**
     * Slug of the requested group.
     */
    readonly groupSlug: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutRequest {
    /**
     * Slug of the requested group.
     */
    readonly groupSlug: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The permission to grant
     */
    readonly body: BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchema
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID. 
     */
    readonly selectedUserId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID. 
     */
    readonly selectedUserId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID. 
     */
    readonly selectedUserId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The permission to grant
     */
    readonly body: BitbucketAppsPermissionsSerializersRepoPermissionUpdateSchema
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPost operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The repository that is to be created. Note that most object elements are optional. Elements \&quot;owner\&quot; and \&quot;full_name\&quot; are ignored as the URL implies them.
     */
    readonly body?: Repository
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugPut operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugPutRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The repository that is to be updated.  Note that the elements \&quot;owner\&quot; and \&quot;full_name\&quot; are ignored since the URL implies them. 
     */
    readonly body?: Repository
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugSrcCommitPathGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugSrcCommitPathGetRequest {
    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * Path to the file.
     */
    readonly path: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * If \&#39;meta\&#39; is provided, returns the (json) meta data for the contents of the file.  If \&#39;rendered\&#39; is provided, returns the contents of a non-binary file in HTML-formatted rendered markup. The \&#39;rendered\&#39; option only supports these filetypes: &#x60;.md&#x60;, &#x60;.markdown&#x60;, &#x60;.mkd&#x60;, &#x60;.mkdn&#x60;, &#x60;.mdown&#x60;, &#x60;.text&#x60;, &#x60;.rst&#x60;, and &#x60;.textile&#x60;. Since Git does not generally track what text encoding scheme is used, this endpoint attempts to detect the most appropriate character encoding. While usually correct, determining the character encoding can be ambiguous which in exceptional cases can lead to misinterpretation of the characters. As such, the raw element in the response object should not be treated as equivalent to the file\&#39;s actual contents.
     */
    readonly format?: RepositoriesWorkspaceRepoSlugSrcCommitPathGetFormatEnum

    /**
     * Optional filter expression as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
     */
    readonly q?: string

    /**
     * Optional sorting parameter as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results).
     */
    readonly sort?: string

    /**
     * If provided, returns the contents of the repository and its subdirectories recursively until the specified max_depth of nested directories. When omitted, this defaults to 1.
     */
    readonly maxDepth?: number
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugSrcGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugSrcGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * Instead of returning the file\&#39;s contents, return the (json) meta data for it.
     */
    readonly format?: RepositoriesWorkspaceRepoSlugSrcGetFormatEnum
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugSrcPost operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugSrcPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The commit message. When omitted, Bitbucket uses a canned string.
     */
    readonly message?: string

    /**
     *  The raw string to be used as the new commit\&#39;s author. This string follows the format &#x60;Erik van Zijst &lt;evzijst@atlassian.com&gt;&#x60;.  When omitted, Bitbucket uses the authenticated user\&#39;s full/display name and primary email address. Commits cannot be created anonymously.
     */
    readonly author?: string

    /**
     *  #### Deprecation Notice: Support for specifying multiple parent commits is deprecated and will be removed in a future release. Only a single SHA1 is accepted.  A SHA1 of the commit that should be the parent of the newly created commit. When omitted, the new commit will inherit from and become a child of the main branch\&#39;s tip/HEAD commit.
     */
    readonly parents?: string

    /**
     *  Optional field that declares the files that the request is manipulating. When adding a new file to a repo, or when overwriting an existing file, the client can just upload the full contents of the file in a normal form field and the use of this &#x60;files&#x60; meta data field is redundant. However, when the &#x60;files&#x60; field contains a file path that does not have a corresponding, identically-named form field, then Bitbucket interprets that as the client wanting to replace the named file with the null set and the file is deleted instead.  Paths in the repo that are referenced in neither files nor an individual file field, remain unchanged and carry over from the parent to the new commit.  This API does not support renaming as an explicit feature. To rename a file, simply delete it and recreate it under the new name in the same commit. 
     */
    readonly files?: string

    /**
     *  The name of the branch that the new commit should be created on. When omitted, the commit will be created on top of the main branch and will become the main branch\&#39;s new head.  When a branch name is provided that already exists in the repo, then the commit will be created on top of that branch. In this case, *if* a parent SHA1 was also provided, then it is asserted that the parent is the branch\&#39;s tip/HEAD at the time the request is made. When this is not the case, a 409 is returned.  When a new branch name is specified (that does not already exist in the repo), and no parent SHA1s are provided, then the new commit will inherit from the current main branch\&#39;s tip/HEAD commit, but not advance the main branch. The new commit will be the new branch. When the request *also* specifies a parent SHA1, then the new commit and branch are created directly on top of the parent commit, regardless of the state of the main branch.  When a branch name is not specified, but a parent SHA1 is provided, then Bitbucket asserts that it represents the main branch\&#39;s current HEAD/tip, or a 409 is returned.  When a branch name is not specified and the repo is empty, the new commit will become the repo\&#39;s root commit and will be on the main branch.  When a branch name is specified and the repo is empty, the new commit will become the repo\&#39;s root commit and also define the repo\&#39;s main branch going forward.  This API cannot be used to create additional root commits in non-empty repos.  The branch field cannot be repeated.  As a side effect, this API can be used to create a new branch without modifying any files, by specifying a new branch name in this field, together with &#x60;parents&#x60;, but omitting the &#x60;files&#x60; fields, while not sending any files. This will create a new commit and branch with the same contents as the first parent. The diff of this commit against its first parent will be empty. 
     */
    readonly branch?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugWatchersGet operation in RepositoriesApi.
 */
export interface RepositoriesApiRepositoriesWorkspaceRepoSlugWatchersGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for userPermissionsRepositoriesGet operation in RepositoriesApi.
 */
export interface RepositoriesApiUserPermissionsRepositoriesGetRequest {
    /**
     *  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
     */
    readonly q?: string

    /**
     *  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
     */
    readonly sort?: string
}

/**
 * RepositoriesApi - object-oriented interface
 */
export class RepositoriesApi extends BaseAPI implements RepositoriesApiInterface {
    /**
     * Returns a paginated list of all public repositories.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-get).
     * @summary List public repositories
     * @param {RepositoriesApiRepositoriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public repositoriesGet(requestParameters: RepositoriesApiRepositoriesGetRequest = {}, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesGet(requestParameters.after, requestParameters.role, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all repositories owned by the specified workspace.  The result can be narrowed down based on the authenticated user\'s role.  E.g. with `?role=contributor`, only those repositories that the authenticated user has write access to are returned (this includes any repo the user is an admin on, as that implies write access).  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary List repositories in a workspace
     * @param {RepositoriesApiRepositoriesWorkspaceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceGet(requestParameters: RepositoriesApiRepositoriesWorkspaceGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceGet(requestParameters.workspace, requestParameters.role, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the repository. This is an irreversible operation.  This does not affect its forks.
     * @summary Delete a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugDelete(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugDeleteRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugDelete(requestParameters.repoSlug, requestParameters.workspace, requestParameters.redirectTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order <sha> <path>  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the `?renames=false` query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to only provide exactly the data you want.  The example response returns commits made before 2011-05-18 against a file named `README.rst`. The results are filtered to only return the path and date. This request can be made using:  ``` $ curl \'https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst\'\\   \'?fields=values.next,values.path,values.commit.date&q=commit.date<=2011-05-18\' ```  In the response you can see that the file was renamed to `README.rst` by the commit made on 2011-05-16, and was previously named `README.txt`.
     * @summary List commits that modified a file
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugFilehistoryCommitPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugFilehistoryCommitPathGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet(requestParameters.commit, requestParameters.path, requestParameters.repoSlug, requestParameters.workspace, requestParameters.renames, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all the forks of the specified repository.
     * @summary List repository forks
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugForksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugForksGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugForksGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugForksGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.role, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new fork of the specified repository.  #### Forking a repository  To create a fork, specify the workspace explicitly as part of the request body:  ``` $ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/atlassian/bbql/forks \\   -H \'Content-Type: application/json\' -d \'{     \"name\": \"bbql_fork\",     \"workspace\": {       \"slug\": \"atlassian\"     } }\' ```  To fork a repository into the same workspace, also specify a new `name`.  When you specify a value for `name`, it will also affect the `slug`. The `slug` is reflected in the repository URL of the new fork. It is derived from `name` by substituting non-ASCII characters, removes whitespace, and changes characters to lower case. For example, `My repo` would turn into `my_repo`.  You need contributor access to create new forks within a workspace.   #### Change the properties of a new fork  By default the fork inherits most of its properties from the parent. However, since the optional POST body document follows the normal `repository` JSON schema and you can override the new fork\'s properties.  Properties that can be overridden include:  * description * fork_policy * language * mainbranch * is_private (note that a private repo\'s fork_policy might prohibit   the creation of public forks, in which `is_private=False` would fail) * has_issues (to initialize or disable the new repo\'s issue tracker --   note that the actual contents of the parent repository\'s issue   tracker are not copied during forking) * has_wiki (to initialize or disable the new repo\'s wiki --   note that the actual contents of the parent repository\'s wiki are not   copied during forking) * project (when forking into a private project, the fork\'s `is_private`   must be `true`)  Properties that cannot be modified include:  * scm * parent * full_name
     * @summary Fork a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugForksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugForksPost(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugForksPostRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugForksPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the object describing this repository.
     * @summary Get a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of webhooks installed on this repository.
     * @summary List webhooks for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugHooksGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugHooksGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new webhook on the specified repository.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  Also note that the `url` must properly resolve and cannot be an internal, non-routed address.
     * @summary Create a webhook for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugHooksPost(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksPostRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugHooksPost(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified webhook subscription from the given repository.
     * @summary Delete a webhook for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugHooksUidDelete(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidDeleteRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugHooksUidDelete(requestParameters.repoSlug, requestParameters.uid, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the webhook with the specified id installed on the specified repository.
     * @summary Get a webhook for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugHooksUidGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugHooksUidGet(requestParameters.repoSlug, requestParameters.uid, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
     * @summary Update a webhook for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugHooksUidPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugHooksUidPutRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugHooksUidPut(requestParameters.repoSlug, requestParameters.uid, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the inheritance state for repository settings
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugOverrideSettingsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugOverrideSettingsGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugOverrideSettingsGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugOverrideSettingsGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the inheritance state for repository settings                 
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugOverrideSettingsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugOverrideSettingsPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugOverrideSettingsPutRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugOverrideSettingsPut(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of explicit group permissions for the given repository. This endpoint does not support BBQL features.
     * @summary List explicit group permissions for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the repository group permission between the requested repository and group, if one exists.  Only users with admin permission for the repository may access this resource.  The only authentication method supported for this endpoint is via app passwords.
     * @summary Delete an explicit group permission for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete(requestParameters.groupSlug, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the group permission for a given group slug and repository  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read` * `none`
     * @summary Get an explicit group permission for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet(requestParameters.groupSlug, requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the group permission, or grants a new permission if one does not already exist.  Only users with admin permission for the repository may access this resource.  The only authentication method supported for this endpoint is via app passwords.  Permissions can be:  * `admin` * `write` * `read`
     * @summary Update an explicit group permission for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut(requestParameters.groupSlug, requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of explicit user permissions for the given repository. This endpoint does not support BBQL features.
     * @summary List explicit user permissions for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the repository user permission between the requested repository and user, if one exists.  Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.
     * @summary Delete an explicit user permission for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete(requestParameters.repoSlug, requestParameters.selectedUserId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the explicit user permission for a given user and repository.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read` * `none`
     * @summary Get an explicit user permission for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet(requestParameters.repoSlug, requestParameters.selectedUserId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the explicit user permission for a given user and repository. The selected user must be a member of the workspace, and cannot be the workspace owner. Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.  Permissions can be:  * `admin` * `write` * `read`
     * @summary Update an explicit user permission for a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut(requestParameters.repoSlug, requestParameters.selectedUserId, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new repository.  Note: In order to set the project for the newly created repository, pass in either the project key or the project UUID as part of the request body as shown in the examples below:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{     \"scm\": \"git\",     \"project\": {         \"key\": \"MARS\"     } }\' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding ```  or  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{     \"scm\": \"git\",     \"project\": {         \"key\": \"{ba516952-992a-4c2d-acbd-17d502922f96}\"     } }\' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding ```  The project must be assigned for all repositories. If the project is not provided, the repository is automatically assigned to the oldest project in the workspace.  Note: In the examples above, the workspace ID `teamsinspace`, and/or the repository name `hablanding` can be replaced by UUIDs.
     * @summary Create a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPost(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPostRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since this endpoint can be used to both update and to create a repository, the request body depends on the intent.  #### Creation  See the POST documentation for the repository endpoint for an example of the request body.  #### Update  Note: Changing the `name` of the repository will cause the location to be changed. This is because the URL of the repo is derived from the name (a process called slugification). In such a scenario, it is possible for the request to fail if the newly created slug conflicts with an existing repository\'s slug. But if there is no conflict, the new location will be returned in the `Location` header of the response.
     * @summary Update a repository
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugPut(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugPutRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugPut(requestParameters.repoSlug, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  #### Raw file contents  When `path` points to a file, this endpoint returns the raw contents. The response\'s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The `Content-Disposition` header will be \"attachment\" to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian\'s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty `__init__.py` always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  #### File meta data  When the request for a file path includes the query parameter `?format=meta`, instead of returning the file\'s raw contents, Bitbucket instead returns the JSON object describing the file\'s properties:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format=meta {   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"     }   },   \"path\": \"tests/__init__.py\",   \"commit\": {     \"type\": \"commit\",     \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"       },       \"html\": {         \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"       }     }   },   \"attributes\": [],   \"type\": \"commit_file\",   \"size\": 0 } ```  File objects contain an `attributes` element that contains a list of possible modifiers. Currently defined values are:  * `link` -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * `executable` -- indicates that the file has the executable bit set. * `subrepository` -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * `binary` -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file\'s size without incurring the overhead of receiving its full contents.   #### Directory listings  When `path` points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \"pagelen\": 10,   \"values\": [     {       \"path\": \"tests/test_project\",       \"type\": \"commit_directory\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"         }       },       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       }     },     {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"         }       },       \"path\": \"tests/__init__.py\",       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       },       \"attributes\": [],       \"type\": \"commit_file\",       \"size\": 0     }   ],   \"page\": 1,   \"size\": 2 } ```  When listing the contents of the repo\'s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \"walk\" the entire directory tree, the client can either parse each response and follow the `self` links of each `commit_directory` object, or can specify a `max_depth` to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the `max_depth` parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a `commit_file`, or a `commit_directory`, both of which contain a `path` element. This path is the absolute path from the root of the repository. Each object also contains a `commit` object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their `self` link returns the paginated contents of the directory. The `meta` link on the other hand returns the actual `directory` object itself, e.g.:  ```javascript {   \"path\": \"tests/test_project\",   \"type\": \"commit_directory\",   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"     }   },   \"commit\": { ... } } ```  #### Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  `size > 1024 and attributes = \"binary\"`  which after urlencoding yields the query string:  `?q=size%3E1024+and+attributes%3D%22binary%22`  To change the ordering of the response, use the `?sort` parameter:  `.../src/eefd5ef/?sort=-size`  See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary Get file or directory contents
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugSrcCommitPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugSrcCommitPathGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugSrcCommitPathGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugSrcCommitPathGet(requestParameters.commit, requestParameters.path, requestParameters.repoSlug, requestParameters.workspace, requestParameters.format, requestParameters.q, requestParameters.sort, requestParameters.maxDepth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo\'s main branch.  To create new commits, [POST to this endpoint](#post)
     * @summary Get the root directory of the main branch
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugSrcGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugSrcGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugSrcGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugSrcGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png=@image.png ```  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the `image.png` file to the repository in the `/repo/path/to` directory.  To create a commit that deletes files, use the `files` parameter:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files=/file/to/delete/1.txt \\   -F files=/file/to/delete/2.txt ```  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts `multipart/form-data` (as in the examples above), as well as `application/x-www-form-urlencoded`.  Note: `multipart/form-data` is currently not supported by Forge apps for this API.  #### multipart/form-data  A `multipart/form-data` post contains a series of \"form fields\" that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a `Content-Disposition` parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above `curl` example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For `multipart/form-data` bodies that should not lead to any ambiguity, as the `Content-Disposition` header will contain the `filename` parameter to distinguish between a file named \"message\" and the commit message field.  #### application/x-www-form-urlencoded  It is also possible to upload new files using a simple `application/x-www-form-urlencoded` POST. This can be convenient when uploading pure text files:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \"/path/to/me.txt=Lorem ipsum.\" \\   --data-urlencode \"message=Initial commit\" \\   --data-urlencode \"author=Erik van Zijst <erik.van.zijst@gmail.com>\" ```  There could be a field name clash if a client were to upload a file named \"message\", as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. `curl --data-urlencode \"/message=file contents\"`.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  #### Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a `x-attributes` value in the `Content-Disposition` header. For example, to upload an executable file, as well as create a symlink from `README.txt` to `README`:  ``` --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"bin/shutdown.sh\" Content-Disposition: attachment; filename=\"shutdown.sh\"; x-attributes:\"executable\"  #!/bin/sh halt  --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"/README.txt\" Content-Disposition: attachment; filename=\"README.txt\"; x-attributes:\"link\"  README --===============1438169132528273974==-- ```  Links are files that contain the target path and have `x-attributes:\"link\"` set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying `x-attributes=\"link\"` will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include `x-attributes=\"executable\"` in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.
     * @summary Create a commit by uploading a file
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugSrcPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugSrcPost(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugSrcPostRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugSrcPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.message, requestParameters.author, requestParameters.parents, requestParameters.files, requestParameters.branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all the watchers on the specified repository.
     * @summary List repositories watchers
     * @param {RepositoriesApiRepositoriesWorkspaceRepoSlugWatchersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugWatchersGet(requestParameters: RepositoriesApiRepositoriesWorkspaceRepoSlugWatchersGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesWorkspaceRepoSlugWatchersGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object for each repository the caller has explicit access to and their effective permission  the highest level of permission the caller has. This does not return public repositories that the user was not granted any specific permission in, and does not distinguish between explicit and implicit privileges.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by repository or permission by adding the following query string parameters:  * `q=repository.name=\"geordi\"` or `q=permission>\"read\"` * `sort=repository.name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-get).
     * @summary List repository permissions for a user
     * @param {RepositoriesApiUserPermissionsRepositoriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public userPermissionsRepositoriesGet(requestParameters: RepositoriesApiUserPermissionsRepositoriesGetRequest = {}, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).userPermissionsRepositoriesGet(requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }
}

export const RepositoriesGetRoleEnum = {
    Admin: 'admin',
    Contributor: 'contributor',
    Member: 'member',
    Owner: 'owner'
} as const;
export type RepositoriesGetRoleEnum = typeof RepositoriesGetRoleEnum[keyof typeof RepositoriesGetRoleEnum];
export const RepositoriesWorkspaceGetRoleEnum = {
    Admin: 'admin',
    Contributor: 'contributor',
    Member: 'member',
    Owner: 'owner'
} as const;
export type RepositoriesWorkspaceGetRoleEnum = typeof RepositoriesWorkspaceGetRoleEnum[keyof typeof RepositoriesWorkspaceGetRoleEnum];
export const RepositoriesWorkspaceRepoSlugForksGetRoleEnum = {
    Admin: 'admin',
    Contributor: 'contributor',
    Member: 'member',
    Owner: 'owner'
} as const;
export type RepositoriesWorkspaceRepoSlugForksGetRoleEnum = typeof RepositoriesWorkspaceRepoSlugForksGetRoleEnum[keyof typeof RepositoriesWorkspaceRepoSlugForksGetRoleEnum];
export const RepositoriesWorkspaceRepoSlugSrcCommitPathGetFormatEnum = {
    Meta: 'meta',
    Rendered: 'rendered'
} as const;
export type RepositoriesWorkspaceRepoSlugSrcCommitPathGetFormatEnum = typeof RepositoriesWorkspaceRepoSlugSrcCommitPathGetFormatEnum[keyof typeof RepositoriesWorkspaceRepoSlugSrcCommitPathGetFormatEnum];
export const RepositoriesWorkspaceRepoSlugSrcGetFormatEnum = {
    Meta: 'meta'
} as const;
export type RepositoriesWorkspaceRepoSlugSrcGetFormatEnum = typeof RepositoriesWorkspaceRepoSlugSrcGetFormatEnum[keyof typeof RepositoriesWorkspaceRepoSlugSrcGetFormatEnum];


/**
 * SSHApi - axios parameter creator
 */
export const SSHApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a paginated list of the user\'s SSH public keys.
         * @summary List SSH keys
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserSshKeysGet: async (selectedUser: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('usersSelectedUserSshKeysGet', 'selectedUser', selectedUser)
            const localVarPath = `/users/{selected_user}/ssh-keys`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific SSH public key from a user\'s account.
         * @summary Delete a SSH key
         * @param {string} keyId The SSH key\&#39;s UUID value.
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserSshKeysKeyIdDelete: async (keyId: string, selectedUser: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('usersSelectedUserSshKeysKeyIdDelete', 'keyId', keyId)
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('usersSelectedUserSshKeysKeyIdDelete', 'selectedUser', selectedUser)
            const localVarPath = `/users/{selected_user}/ssh-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)))
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific SSH public key belonging to a user.
         * @summary Get a SSH key
         * @param {string} keyId The SSH key\&#39;s UUID value.
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserSshKeysKeyIdGet: async (keyId: string, selectedUser: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('usersSelectedUserSshKeysKeyIdGet', 'keyId', keyId)
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('usersSelectedUserSshKeysKeyIdGet', 'selectedUser', selectedUser)
            const localVarPath = `/users/{selected_user}/ssh-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)))
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a specific SSH public key on a user\'s account  Note: Only the \'comment\' field can be updated using this API. To modify the key or comment values, you must delete and add the key again.  Example:  ``` $ curl -X PUT -H \"Content-Type: application/json\" -d \'{\"label\": \"Work key\"}\' https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/ssh-keys/{b15b6026-9c02-4626-b4ad-b905f99f763a} ```
         * @summary Update a SSH key
         * @param {string} keyId The SSH key\&#39;s UUID value.
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {SshAccountKey} [body] The updated SSH key object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserSshKeysKeyIdPut: async (keyId: string, selectedUser: string, body?: SshAccountKey, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('usersSelectedUserSshKeysKeyIdPut', 'keyId', keyId)
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('usersSelectedUserSshKeysKeyIdPut', 'selectedUser', selectedUser)
            const localVarPath = `/users/{selected_user}/ssh-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)))
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new SSH public key to the specified user account and returns the resulting key.  Example:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{\"key\": \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY user@myhost\"}\' https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/ssh-keys ```
         * @summary Add a new SSH key
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {string} [expiresOn] The date or date-time of when the key will expire, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format. Example: &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;
         * @param {SshAccountKey} [body] The new SSH key object. Note that the username property has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserSshKeysPost: async (selectedUser: string, expiresOn?: string, body?: SshAccountKey, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('usersSelectedUserSshKeysPost', 'selectedUser', selectedUser)
            const localVarPath = `/users/{selected_user}/ssh-keys`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (expiresOn !== undefined) {
                localVarQueryParameter['expires_on'] = expiresOn;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SSHApi - functional programming interface
 */
export const SSHApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SSHApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a paginated list of the user\'s SSH public keys.
         * @summary List SSH keys
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSelectedUserSshKeysGet(selectedUser: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSshUserKeys>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSelectedUserSshKeysGet(selectedUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSHApi.usersSelectedUserSshKeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a specific SSH public key from a user\'s account.
         * @summary Delete a SSH key
         * @param {string} keyId The SSH key\&#39;s UUID value.
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSelectedUserSshKeysKeyIdDelete(keyId: string, selectedUser: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSelectedUserSshKeysKeyIdDelete(keyId, selectedUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSHApi.usersSelectedUserSshKeysKeyIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a specific SSH public key belonging to a user.
         * @summary Get a SSH key
         * @param {string} keyId The SSH key\&#39;s UUID value.
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSelectedUserSshKeysKeyIdGet(keyId: string, selectedUser: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SshAccountKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSelectedUserSshKeysKeyIdGet(keyId, selectedUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSHApi.usersSelectedUserSshKeysKeyIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a specific SSH public key on a user\'s account  Note: Only the \'comment\' field can be updated using this API. To modify the key or comment values, you must delete and add the key again.  Example:  ``` $ curl -X PUT -H \"Content-Type: application/json\" -d \'{\"label\": \"Work key\"}\' https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/ssh-keys/{b15b6026-9c02-4626-b4ad-b905f99f763a} ```
         * @summary Update a SSH key
         * @param {string} keyId The SSH key\&#39;s UUID value.
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {SshAccountKey} [body] The updated SSH key object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSelectedUserSshKeysKeyIdPut(keyId: string, selectedUser: string, body?: SshAccountKey, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SshAccountKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSelectedUserSshKeysKeyIdPut(keyId, selectedUser, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSHApi.usersSelectedUserSshKeysKeyIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds a new SSH public key to the specified user account and returns the resulting key.  Example:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{\"key\": \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY user@myhost\"}\' https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/ssh-keys ```
         * @summary Add a new SSH key
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {string} [expiresOn] The date or date-time of when the key will expire, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format. Example: &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;
         * @param {SshAccountKey} [body] The new SSH key object. Note that the username property has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSelectedUserSshKeysPost(selectedUser: string, expiresOn?: string, body?: SshAccountKey, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SshAccountKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSelectedUserSshKeysPost(selectedUser, expiresOn, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSHApi.usersSelectedUserSshKeysPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SSHApi - factory interface
 */
export const SSHApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SSHApiFp(configuration)
    return {
        /**
         * Returns a paginated list of the user\'s SSH public keys.
         * @summary List SSH keys
         * @param {SSHApiUsersSelectedUserSshKeysGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserSshKeysGet(requestParameters: SSHApiUsersSelectedUserSshKeysGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSshUserKeys> {
            return localVarFp.usersSelectedUserSshKeysGet(requestParameters.selectedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific SSH public key from a user\'s account.
         * @summary Delete a SSH key
         * @param {SSHApiUsersSelectedUserSshKeysKeyIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserSshKeysKeyIdDelete(requestParameters: SSHApiUsersSelectedUserSshKeysKeyIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersSelectedUserSshKeysKeyIdDelete(requestParameters.keyId, requestParameters.selectedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific SSH public key belonging to a user.
         * @summary Get a SSH key
         * @param {SSHApiUsersSelectedUserSshKeysKeyIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserSshKeysKeyIdGet(requestParameters: SSHApiUsersSelectedUserSshKeysKeyIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<SshAccountKey> {
            return localVarFp.usersSelectedUserSshKeysKeyIdGet(requestParameters.keyId, requestParameters.selectedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a specific SSH public key on a user\'s account  Note: Only the \'comment\' field can be updated using this API. To modify the key or comment values, you must delete and add the key again.  Example:  ``` $ curl -X PUT -H \"Content-Type: application/json\" -d \'{\"label\": \"Work key\"}\' https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/ssh-keys/{b15b6026-9c02-4626-b4ad-b905f99f763a} ```
         * @summary Update a SSH key
         * @param {SSHApiUsersSelectedUserSshKeysKeyIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserSshKeysKeyIdPut(requestParameters: SSHApiUsersSelectedUserSshKeysKeyIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<SshAccountKey> {
            return localVarFp.usersSelectedUserSshKeysKeyIdPut(requestParameters.keyId, requestParameters.selectedUser, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new SSH public key to the specified user account and returns the resulting key.  Example:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{\"key\": \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY user@myhost\"}\' https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/ssh-keys ```
         * @summary Add a new SSH key
         * @param {SSHApiUsersSelectedUserSshKeysPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserSshKeysPost(requestParameters: SSHApiUsersSelectedUserSshKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<SshAccountKey> {
            return localVarFp.usersSelectedUserSshKeysPost(requestParameters.selectedUser, requestParameters.expiresOn, requestParameters.body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SSHApi - interface
 */
export interface SSHApiInterface {
    /**
     * Returns a paginated list of the user\'s SSH public keys.
     * @summary List SSH keys
     * @param {SSHApiUsersSelectedUserSshKeysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersSelectedUserSshKeysGet(requestParameters: SSHApiUsersSelectedUserSshKeysGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSshUserKeys>;

    /**
     * Deletes a specific SSH public key from a user\'s account.
     * @summary Delete a SSH key
     * @param {SSHApiUsersSelectedUserSshKeysKeyIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersSelectedUserSshKeysKeyIdDelete(requestParameters: SSHApiUsersSelectedUserSshKeysKeyIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a specific SSH public key belonging to a user.
     * @summary Get a SSH key
     * @param {SSHApiUsersSelectedUserSshKeysKeyIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersSelectedUserSshKeysKeyIdGet(requestParameters: SSHApiUsersSelectedUserSshKeysKeyIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<SshAccountKey>;

    /**
     * Updates a specific SSH public key on a user\'s account  Note: Only the \'comment\' field can be updated using this API. To modify the key or comment values, you must delete and add the key again.  Example:  ``` $ curl -X PUT -H \"Content-Type: application/json\" -d \'{\"label\": \"Work key\"}\' https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/ssh-keys/{b15b6026-9c02-4626-b4ad-b905f99f763a} ```
     * @summary Update a SSH key
     * @param {SSHApiUsersSelectedUserSshKeysKeyIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersSelectedUserSshKeysKeyIdPut(requestParameters: SSHApiUsersSelectedUserSshKeysKeyIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<SshAccountKey>;

    /**
     * Adds a new SSH public key to the specified user account and returns the resulting key.  Example:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{\"key\": \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY user@myhost\"}\' https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/ssh-keys ```
     * @summary Add a new SSH key
     * @param {SSHApiUsersSelectedUserSshKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersSelectedUserSshKeysPost(requestParameters: SSHApiUsersSelectedUserSshKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<SshAccountKey>;

}

/**
 * Request parameters for usersSelectedUserSshKeysGet operation in SSHApi.
 */
export interface SSHApiUsersSelectedUserSshKeysGetRequest {
    /**
     * This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly selectedUser: string
}

/**
 * Request parameters for usersSelectedUserSshKeysKeyIdDelete operation in SSHApi.
 */
export interface SSHApiUsersSelectedUserSshKeysKeyIdDeleteRequest {
    /**
     * The SSH key\&#39;s UUID value.
     */
    readonly keyId: string

    /**
     * This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly selectedUser: string
}

/**
 * Request parameters for usersSelectedUserSshKeysKeyIdGet operation in SSHApi.
 */
export interface SSHApiUsersSelectedUserSshKeysKeyIdGetRequest {
    /**
     * The SSH key\&#39;s UUID value.
     */
    readonly keyId: string

    /**
     * This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly selectedUser: string
}

/**
 * Request parameters for usersSelectedUserSshKeysKeyIdPut operation in SSHApi.
 */
export interface SSHApiUsersSelectedUserSshKeysKeyIdPutRequest {
    /**
     * The SSH key\&#39;s UUID value.
     */
    readonly keyId: string

    /**
     * This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly selectedUser: string

    /**
     * The updated SSH key object
     */
    readonly body?: SshAccountKey
}

/**
 * Request parameters for usersSelectedUserSshKeysPost operation in SSHApi.
 */
export interface SSHApiUsersSelectedUserSshKeysPostRequest {
    /**
     * This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly selectedUser: string

    /**
     * The date or date-time of when the key will expire, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format. Example: &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;
     */
    readonly expiresOn?: string

    /**
     * The new SSH key object. Note that the username property has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).
     */
    readonly body?: SshAccountKey
}

/**
 * SSHApi - object-oriented interface
 */
export class SSHApi extends BaseAPI implements SSHApiInterface {
    /**
     * Returns a paginated list of the user\'s SSH public keys.
     * @summary List SSH keys
     * @param {SSHApiUsersSelectedUserSshKeysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersSelectedUserSshKeysGet(requestParameters: SSHApiUsersSelectedUserSshKeysGetRequest, options?: RawAxiosRequestConfig) {
        return SSHApiFp(this.configuration).usersSelectedUserSshKeysGet(requestParameters.selectedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific SSH public key from a user\'s account.
     * @summary Delete a SSH key
     * @param {SSHApiUsersSelectedUserSshKeysKeyIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersSelectedUserSshKeysKeyIdDelete(requestParameters: SSHApiUsersSelectedUserSshKeysKeyIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return SSHApiFp(this.configuration).usersSelectedUserSshKeysKeyIdDelete(requestParameters.keyId, requestParameters.selectedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific SSH public key belonging to a user.
     * @summary Get a SSH key
     * @param {SSHApiUsersSelectedUserSshKeysKeyIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersSelectedUserSshKeysKeyIdGet(requestParameters: SSHApiUsersSelectedUserSshKeysKeyIdGetRequest, options?: RawAxiosRequestConfig) {
        return SSHApiFp(this.configuration).usersSelectedUserSshKeysKeyIdGet(requestParameters.keyId, requestParameters.selectedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a specific SSH public key on a user\'s account  Note: Only the \'comment\' field can be updated using this API. To modify the key or comment values, you must delete and add the key again.  Example:  ``` $ curl -X PUT -H \"Content-Type: application/json\" -d \'{\"label\": \"Work key\"}\' https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/ssh-keys/{b15b6026-9c02-4626-b4ad-b905f99f763a} ```
     * @summary Update a SSH key
     * @param {SSHApiUsersSelectedUserSshKeysKeyIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersSelectedUserSshKeysKeyIdPut(requestParameters: SSHApiUsersSelectedUserSshKeysKeyIdPutRequest, options?: RawAxiosRequestConfig) {
        return SSHApiFp(this.configuration).usersSelectedUserSshKeysKeyIdPut(requestParameters.keyId, requestParameters.selectedUser, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new SSH public key to the specified user account and returns the resulting key.  Example:  ``` $ curl -X POST -H \"Content-Type: application/json\" -d \'{\"key\": \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY user@myhost\"}\' https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/ssh-keys ```
     * @summary Add a new SSH key
     * @param {SSHApiUsersSelectedUserSshKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersSelectedUserSshKeysPost(requestParameters: SSHApiUsersSelectedUserSshKeysPostRequest, options?: RawAxiosRequestConfig) {
        return SSHApiFp(this.configuration).usersSelectedUserSshKeysPost(requestParameters.selectedUser, requestParameters.expiresOn, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SearchApi - axios parameter creator
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search for code in the repositories of the specified user.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`). 
         * @summary Search for code in a user\'s repositories
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {string} searchQuery The search query
         * @param {number} [page] Which page of the search results to retrieve
         * @param {number} [pagelen] How many search results to retrieve per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccount: async (selectedUser: string, searchQuery: string, page?: number, pagelen?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('searchAccount', 'selectedUser', selectedUser)
            // verify required parameter 'searchQuery' is not null or undefined
            assertParamExists('searchAccount', 'searchQuery', searchQuery)
            const localVarPath = `/users/{selected_user}/search/code`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (searchQuery !== undefined) {
                localVarQueryParameter['search_query'] = searchQuery;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pagelen !== undefined) {
                localVarQueryParameter['pagelen'] = pagelen;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for code in the repositories of the specified team.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`).  Try `fields=%2Bvalues.*.*.*.*` to get an idea what\'s possible. 
         * @summary Search for code in a team\'s repositories
         * @param {string} username The account to search in; either the username or the UUID in curly braces
         * @param {string} searchQuery The search query
         * @param {number} [page] Which page of the search results to retrieve
         * @param {number} [pagelen] How many search results to retrieve per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTeam: async (username: string, searchQuery: string, page?: number, pagelen?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('searchTeam', 'username', username)
            // verify required parameter 'searchQuery' is not null or undefined
            assertParamExists('searchTeam', 'searchQuery', searchQuery)
            const localVarPath = `/teams/{username}/search/code`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (searchQuery !== undefined) {
                localVarQueryParameter['search_query'] = searchQuery;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pagelen !== undefined) {
                localVarQueryParameter['pagelen'] = pagelen;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for code in the repositories of the specified workspace.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`).  Try `fields=%2Bvalues.*.*.*.*` to get an idea what\'s possible. 
         * @summary Search for code in a workspace
         * @param {string} workspace The workspace to search in; either the slug or the UUID in curly braces
         * @param {string} searchQuery The search query
         * @param {number} [page] Which page of the search results to retrieve
         * @param {number} [pagelen] How many search results to retrieve per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorkspace: async (workspace: string, searchQuery: string, page?: number, pagelen?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('searchWorkspace', 'workspace', workspace)
            // verify required parameter 'searchQuery' is not null or undefined
            assertParamExists('searchWorkspace', 'searchQuery', searchQuery)
            const localVarPath = `/workspaces/{workspace}/search/code`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (searchQuery !== undefined) {
                localVarQueryParameter['search_query'] = searchQuery;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pagelen !== undefined) {
                localVarQueryParameter['pagelen'] = pagelen;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Search for code in the repositories of the specified user.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`). 
         * @summary Search for code in a user\'s repositories
         * @param {string} selectedUser Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
         * @param {string} searchQuery The search query
         * @param {number} [page] Which page of the search results to retrieve
         * @param {number} [pagelen] How many search results to retrieve per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccount(selectedUser: string, searchQuery: string, page?: number, pagelen?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResultPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAccount(selectedUser, searchQuery, page, pagelen, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for code in the repositories of the specified team.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`).  Try `fields=%2Bvalues.*.*.*.*` to get an idea what\'s possible. 
         * @summary Search for code in a team\'s repositories
         * @param {string} username The account to search in; either the username or the UUID in curly braces
         * @param {string} searchQuery The search query
         * @param {number} [page] Which page of the search results to retrieve
         * @param {number} [pagelen] How many search results to retrieve per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTeam(username: string, searchQuery: string, page?: number, pagelen?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResultPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTeam(username, searchQuery, page, pagelen, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for code in the repositories of the specified workspace.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`).  Try `fields=%2Bvalues.*.*.*.*` to get an idea what\'s possible. 
         * @summary Search for code in a workspace
         * @param {string} workspace The workspace to search in; either the slug or the UUID in curly braces
         * @param {string} searchQuery The search query
         * @param {number} [page] Which page of the search results to retrieve
         * @param {number} [pagelen] How many search results to retrieve per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchWorkspace(workspace: string, searchQuery: string, page?: number, pagelen?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResultPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchWorkspace(workspace, searchQuery, page, pagelen, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Search for code in the repositories of the specified user.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`). 
         * @summary Search for code in a user\'s repositories
         * @param {SearchApiSearchAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccount(requestParameters: SearchApiSearchAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchResultPage> {
            return localVarFp.searchAccount(requestParameters.selectedUser, requestParameters.searchQuery, requestParameters.page, requestParameters.pagelen, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for code in the repositories of the specified team.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`).  Try `fields=%2Bvalues.*.*.*.*` to get an idea what\'s possible. 
         * @summary Search for code in a team\'s repositories
         * @param {SearchApiSearchTeamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTeam(requestParameters: SearchApiSearchTeamRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchResultPage> {
            return localVarFp.searchTeam(requestParameters.username, requestParameters.searchQuery, requestParameters.page, requestParameters.pagelen, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for code in the repositories of the specified workspace.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`).  Try `fields=%2Bvalues.*.*.*.*` to get an idea what\'s possible. 
         * @summary Search for code in a workspace
         * @param {SearchApiSearchWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorkspace(requestParameters: SearchApiSearchWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchResultPage> {
            return localVarFp.searchWorkspace(requestParameters.workspace, requestParameters.searchQuery, requestParameters.page, requestParameters.pagelen, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - interface
 */
export interface SearchApiInterface {
    /**
     * Search for code in the repositories of the specified user.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`). 
     * @summary Search for code in a user\'s repositories
     * @param {SearchApiSearchAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAccount(requestParameters: SearchApiSearchAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchResultPage>;

    /**
     * Search for code in the repositories of the specified team.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`).  Try `fields=%2Bvalues.*.*.*.*` to get an idea what\'s possible. 
     * @summary Search for code in a team\'s repositories
     * @param {SearchApiSearchTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchTeam(requestParameters: SearchApiSearchTeamRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchResultPage>;

    /**
     * Search for code in the repositories of the specified workspace.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`).  Try `fields=%2Bvalues.*.*.*.*` to get an idea what\'s possible. 
     * @summary Search for code in a workspace
     * @param {SearchApiSearchWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchWorkspace(requestParameters: SearchApiSearchWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchResultPage>;

}

/**
 * Request parameters for searchAccount operation in SearchApi.
 */
export interface SearchApiSearchAccountRequest {
    /**
     * Either the UUID of the account surrounded by curly-braces, for example &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.
     */
    readonly selectedUser: string

    /**
     * The search query
     */
    readonly searchQuery: string

    /**
     * Which page of the search results to retrieve
     */
    readonly page?: number

    /**
     * How many search results to retrieve per page
     */
    readonly pagelen?: number
}

/**
 * Request parameters for searchTeam operation in SearchApi.
 */
export interface SearchApiSearchTeamRequest {
    /**
     * The account to search in; either the username or the UUID in curly braces
     */
    readonly username: string

    /**
     * The search query
     */
    readonly searchQuery: string

    /**
     * Which page of the search results to retrieve
     */
    readonly page?: number

    /**
     * How many search results to retrieve per page
     */
    readonly pagelen?: number
}

/**
 * Request parameters for searchWorkspace operation in SearchApi.
 */
export interface SearchApiSearchWorkspaceRequest {
    /**
     * The workspace to search in; either the slug or the UUID in curly braces
     */
    readonly workspace: string

    /**
     * The search query
     */
    readonly searchQuery: string

    /**
     * Which page of the search results to retrieve
     */
    readonly page?: number

    /**
     * How many search results to retrieve per page
     */
    readonly pagelen?: number
}

/**
 * SearchApi - object-oriented interface
 */
export class SearchApi extends BaseAPI implements SearchApiInterface {
    /**
     * Search for code in the repositories of the specified user.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`). 
     * @summary Search for code in a user\'s repositories
     * @param {SearchApiSearchAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchAccount(requestParameters: SearchApiSearchAccountRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchAccount(requestParameters.selectedUser, requestParameters.searchQuery, requestParameters.page, requestParameters.pagelen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for code in the repositories of the specified team.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`).  Try `fields=%2Bvalues.*.*.*.*` to get an idea what\'s possible. 
     * @summary Search for code in a team\'s repositories
     * @param {SearchApiSearchTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchTeam(requestParameters: SearchApiSearchTeamRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchTeam(requestParameters.username, requestParameters.searchQuery, requestParameters.page, requestParameters.pagelen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for code in the repositories of the specified workspace.  Note that searches can match in the file\'s text (`content_matches`), the path (`path_matches`), or both.  You can use the same syntax for the search query as in the UI. E.g. to search for \"foo\" only within the repository \"demo\", use the query parameter `search_query=foo+repo:demo`.  Similar to other APIs, you can request more fields using a `fields` query parameter. E.g. to get some more information about the repository of matched files, use the query parameter `search_query=foo&fields=%2Bvalues.file.commit.repository` (the `%2B` is a URL-encoded `+`).  Try `fields=%2Bvalues.*.*.*.*` to get an idea what\'s possible. 
     * @summary Search for code in a workspace
     * @param {SearchApiSearchWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchWorkspace(requestParameters: SearchApiSearchWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchWorkspace(requestParameters.workspace, requestParameters.searchQuery, requestParameters.page, requestParameters.pagelen, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SnippetsApi - axios parameter creator
 */
export const SnippetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all snippets. Like pull requests, repositories and workspaces, the full set of snippets is defined by what the current user has access to.  This includes all snippets owned by any of the workspaces the user is a member of, or snippets by other users that the current user is either watching or has collaborated on (for instance by commenting on it).  To limit the set of returned snippets, apply the `?role=[owner|contributor|member]` query parameter where the roles are defined as follows:  * `owner`: all snippets owned by the current user * `contributor`: all snippets owned by, or watched by the current user * `member`: created in a workspaces or watched by the current user  When no role is specified, all public snippets are returned, as well as all privately owned snippets watched or commented on.  The returned response is a normal paginated JSON list. This endpoint only supports `application/json` responses and no `multipart/form-data` or `multipart/related`. As a result, it is not possible to include the file contents.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-workspace-get).
         * @summary List snippets
         * @param {SnippetsGetRoleEnum} [role] Filter down the result based on the authenticated user\&#39;s role (&#x60;owner&#x60;, &#x60;contributor&#x60;, or &#x60;member&#x60;).
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        snippetsGet: async (role?: SnippetsGetRoleEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/snippets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new snippet under the authenticated user\'s account.  Snippets can contain multiple files. Both text and binary files are supported.  The simplest way to create a new snippet from a local file:      $ curl -u username:password -X POST https://api.bitbucket.org/2.0/snippets               -F file=@image.png  Creating snippets through curl has a few limitations and so let\'s look at a more complicated scenario.  Snippets are created with a multipart POST. Both `multipart/form-data` and `multipart/related` are supported. Both allow the creation of snippets with both meta data (title, etc), as well as multiple text and binary files.  The main difference is that `multipart/related` can use rich encoding for the meta data (currently JSON).   multipart/related (RFC-2387) ----------------------------  This is the most advanced and efficient way to create a paste.      POST /2.0/snippets/evzijst HTTP/1.1     Content-Length: 1188     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"title\": \"My snippet\",       \"is_private\": true,       \"scm\": \"git\",       \"files\": {           \"foo.txt\": {},           \"image.png\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      foo      --===============1438169132528273974==     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \"image.png\"     Content-Disposition: attachment; filename=\"image.png\"      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     --===============1438169132528273974==--  The request contains multiple parts and is structured as follows.  The first part is the JSON document that describes the snippet\'s properties or meta data. It either has to be the first part, or the request\'s `Content-Type` header must contain the `start` parameter to point to it.  The remaining parts are the files of which there can be zero or more. Each file part should contain the `Content-ID` MIME header through which the JSON meta data\'s `files` element addresses it. The value should be the name of the file.  `Content-Disposition` is an optional MIME header. The header\'s optional `filename` parameter can be used to specify the file name that Bitbucket should use when writing the file to disk. When present, `filename` takes precedence over the value of `Content-ID`.  When the JSON body omits the `files` element, the remaining parts are not ignored. Instead, each file is added to the new snippet as if its name was explicitly linked (the use of the `files` elements is mandatory for some operations like deleting or renaming files).   multipart/form-data -------------------  The use of JSON for the snippet\'s meta data is optional. Meta data can also be supplied as regular form fields in a more conventional `multipart/form-data` request:      $ curl -X POST -u credentials https://api.bitbucket.org/2.0/snippets               -F title=\"My snippet\"               -F file=@foo.txt -F file=@image.png      POST /2.0/snippets HTTP/1.1     Content-Length: 951     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"image.png\"     Content-Type: application/octet-stream      ?PNG      IHDR?1??I.....     ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"      My snippet     ------------------------------63a4b224c59f--  Here the meta data properties are included as flat, top-level form fields. The file attachments use the `file` field name. To attach multiple files, simply repeat the field.  The advantage of `multipart/form-data` over `multipart/related` is that it can be easier to build clients.  Essentially all properties are optional, `title` and `files` included.   Sharing and Visibility ----------------------  Snippets can be either public (visible to anyone on Bitbucket, as well as anonymous users), or private (visible only to members of the workspace). This is controlled through the snippet\'s `is_private` element:  * **is_private=false** -- everyone, including anonymous users can view   the snippet * **is_private=true** -- only workspace members can view the snippet  To create the snippet under a workspace, just append the workspace ID to the URL. See [`/2.0/snippets/{workspace}`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-workspace-post).
         * @summary Create a snippet
         * @param {Snippet} body The new snippet object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsPost: async (body: Snippet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('snippetsPost', 'body', body)
            const localVarPath = `/snippets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a snippet comment.  Comments can only be removed by the comment author, snippet creator, or workspace admin.
         * @summary Delete a comment on a snippet
         * @param {number} commentId The id of the comment.
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdCommentsCommentIdDelete: async (commentId: number, encodedId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsCommentIdDelete', 'commentId', commentId)
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsCommentIdDelete', 'encodedId', encodedId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsCommentIdDelete', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specific snippet comment.
         * @summary Get a comment on a snippet
         * @param {number} commentId The id of the comment.
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdCommentsCommentIdGet: async (commentId: number, encodedId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsCommentIdGet', 'commentId', commentId)
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsCommentIdGet', 'encodedId', encodedId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsCommentIdGet', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a comment.  The only required field in the body is `content.raw`.  Comments can only be updated by their author.
         * @summary Update a comment on a snippet
         * @param {number} commentId The id of the comment.
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {SnippetComment} body The contents to update the comment to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdCommentsCommentIdPut: async (commentId: number, encodedId: string, workspace: string, body: SnippetComment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsCommentIdPut', 'commentId', commentId)
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsCommentIdPut', 'encodedId', encodedId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsCommentIdPut', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsCommentIdPut', 'body', body)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to retrieve a paginated list of all comments for a specific snippet.  This resource works identical to commit and pull request comments.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.
         * @summary List comments on a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdCommentsGet: async (encodedId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsGet', 'encodedId', encodedId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsGet', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/comments`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new comment.  The only required field in the body is `content.raw`.  To create a threaded reply to an existing comment, include `parent.id`.
         * @summary Create a comment on a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {SnippetComment} body The contents of the new comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdCommentsPost: async (encodedId: string, workspace: string, body: SnippetComment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsPost', 'encodedId', encodedId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsPost', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommentsPost', 'body', body)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/comments`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the changes (commits) made on this snippet.
         * @summary List snippet changes
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdCommitsGet: async (encodedId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommitsGet', 'encodedId', encodedId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommitsGet', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/commits`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the changes made on this snippet in this commit.
         * @summary Get a previous snippet change
         * @param {string} encodedId The snippet id.
         * @param {string} revision The commit\&#39;s SHA1.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdCommitsRevisionGet: async (encodedId: string, revision: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommitsRevisionGet', 'encodedId', encodedId)
            // verify required parameter 'revision' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommitsRevisionGet', 'revision', revision)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdCommitsRevisionGet', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/commits/{revision}`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"revision"}}`, encodeURIComponent(String(revision)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a snippet and returns an empty response.
         * @summary Delete a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdDelete: async (encodedId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdDelete', 'encodedId', encodedId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdDelete', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Convenience resource for getting to a snippet\'s raw files without the need for first having to retrieve the snippet itself and having to pull out the versioned file links.
         * @summary Get a snippet\'s raw file at HEAD
         * @param {string} encodedId The snippet id.
         * @param {string} path Path to the file.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdFilesPathGet: async (encodedId: string, path: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdFilesPathGet', 'encodedId', encodedId)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdFilesPathGet', 'path', path)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdFilesPathGet', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/files/{path}`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single snippet.  Snippets support multiple content types:  * application/json * multipart/related * multipart/form-data   application/json ----------------  The default content type of the response is `application/json`. Since JSON is always `utf-8`, it cannot reliably contain file contents for files that are not text. Therefore, JSON snippet documents only contain the filename and links to the file contents.  This means that in order to retrieve all parts of a snippet, N+1 requests need to be made (where N is the number of files in the snippet).   multipart/related -----------------  To retrieve an entire snippet in a single response, use the `Accept: multipart/related` HTTP request header.      $ curl -H \"Accept: multipart/related\" https://api.bitbucket.org/2.0/snippets/evzijst/1  Response:      HTTP/1.1 200 OK     Content-Length: 2214     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj\"         },         \"html\": {           \"href\": \"https://bitbucket.org/snippets/evzijst/kypj\"         },         \"comments\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/comments\"         },         \"watchers\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/watchers\"         },         \"commits\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/commits\"         }       },       \"id\": kypj,       \"title\": \"My snippet\",       \"created_on\": \"2014-12-29T22:22:04.790331+00:00\",       \"updated_on\": \"2014-12-29T22:22:04.790331+00:00\",       \"is_private\": false,       \"files\": {         \"foo.txt\": {           \"links\": {             \"self\": {               \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/foo.txt\"             },             \"html\": {               \"href\": \"https://bitbucket.org/snippets/evzijst/kypj#file-foo.txt\"             }           }         },         \"image.png\": {           \"links\": {             \"self\": {               \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/image.png\"             },             \"html\": {               \"href\": \"https://bitbucket.org/snippets/evzijst/kypj#file-image.png\"             }           }         }       ],       \"owner\": {         \"username\": \"evzijst\",         \"nickname\": \"evzijst\",         \"display_name\": \"Erik van Zijst\",         \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"           },           \"html\": {             \"href\": \"https://bitbucket.org/evzijst\"           },           \"avatar\": {             \"href\": \"https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\"           }         }       },       \"creator\": {         \"username\": \"evzijst\",         \"nickname\": \"evzijst\",         \"display_name\": \"Erik van Zijst\",         \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"           },           \"html\": {             \"href\": \"https://bitbucket.org/evzijst\"           },           \"avatar\": {             \"href\": \"https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\"           }         }       }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      foo      --===============1438169132528273974==     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \"image.png\"     Content-Disposition: attachment; filename=\"image.png\"      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     --===============1438169132528273974==--  multipart/form-data -------------------  As with creating new snippets, `multipart/form-data` can be used as an alternative to `multipart/related`. However, the inherently flat structure of form-data means that only basic, root-level properties can be returned, while nested elements like `links` are omitted:      $ curl -H \"Accept: multipart/form-data\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj  Response:      HTTP/1.1 200 OK     Content-Length: 951     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"     Content-Type: text/plain; charset=\"utf-8\"      My snippet     ------------------------------63a4b224c59f--     Content-Disposition: attachment; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: attachment; name=\"file\"; filename=\"image.png\"     Content-Transfer-Encoding: base64     Content-Type: application/octet-stream      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     ------------------------------5957323a6b76--
         * @summary Get a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdGet: async (encodedId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdGet', 'encodedId', encodedId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdGet', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json,multipart/related,multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the snippet.  Note that this only works for versioned URLs that point to the latest commit of the snippet. Pointing to an older commit results in a 405 status code.  To delete a snippet, regardless of whether or not concurrent changes are being made to it, use `DELETE /snippets/{encoded_id}` instead.
         * @summary Delete a previous revision of a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} nodeId A commit revision (SHA1).
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdNodeIdDelete: async (encodedId: string, nodeId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdNodeIdDelete', 'encodedId', encodedId)
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdNodeIdDelete', 'nodeId', nodeId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdNodeIdDelete', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/{node_id}`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the raw contents of a specific file in the snippet. The `Content-Disposition` header will be \"attachment\" to avoid issues with malevolent executable files.  The file\'s mime type is derived from its filename and returned in the `Content-Type` header.  Note that for text files, no character encoding is included as part of the content type.
         * @summary Get a snippet\'s raw file
         * @param {string} encodedId The snippet id.
         * @param {string} nodeId A commit revision (SHA1).
         * @param {string} path Path to the file.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdNodeIdFilesPathGet: async (encodedId: string, nodeId: string, path: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdNodeIdFilesPathGet', 'encodedId', encodedId)
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdNodeIdFilesPathGet', 'nodeId', nodeId)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdNodeIdFilesPathGet', 'path', path)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdNodeIdFilesPathGet', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/{node_id}/files/{path}`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Identical to `GET /snippets/encoded_id`, except that this endpoint can be used to retrieve the contents of the snippet as it was at an older revision, while `/snippets/encoded_id` always returns the snippet\'s current revision.  Note that only the snippet\'s file contents are versioned, not its meta data properties like the title.  Other than that, the two endpoints are identical in behavior.
         * @summary Get a previous revision of a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} nodeId A commit revision (SHA1).
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdNodeIdGet: async (encodedId: string, nodeId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdNodeIdGet', 'encodedId', encodedId)
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdNodeIdGet', 'nodeId', nodeId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdNodeIdGet', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/{node_id}`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json,multipart/related,multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Identical to `UPDATE /snippets/encoded_id`, except that this endpoint takes an explicit commit revision. Only the snippet\'s \"HEAD\"/\"tip\" (most recent) version can be updated and requests on all other, older revisions fail by returning a 405 status.  Usage of this endpoint over the unrestricted `/snippets/encoded_id` could be desired if the caller wants to be sure no concurrent modifications have taken place between the moment of the UPDATE request and the original GET.  This can be considered a so-called \"Compare And Swap\", or CAS operation.  Other than that, the two endpoints are identical in behavior.
         * @summary Update a previous revision of a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} nodeId A commit revision (SHA1).
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdNodeIdPut: async (encodedId: string, nodeId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdNodeIdPut', 'encodedId', encodedId)
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdNodeIdPut', 'nodeId', nodeId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdNodeIdPut', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/{node_id}`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json,multipart/related,multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to update a snippet. Use this to add and delete files and to change a snippet\'s title.  To update a snippet, one can either PUT a full snapshot, or only the parts that need to be changed.  The contract for PUT on this API is that properties missing from the request remain untouched so that snippets can be efficiently manipulated with differential payloads.  To delete a property (e.g. the title, or a file), include its name in the request, but omit its value (use `null`).  As in Git, explicit renaming of files is not supported. Instead, to rename a file, delete it and add it again under another name. This can be done atomically in a single request. Rename detection is left to the SCM.  PUT supports three different content types for both request and response bodies:  * `application/json` * `multipart/related` * `multipart/form-data`  The content type used for the request body can be different than that used for the response. Content types are specified using standard HTTP headers.  Use the `Content-Type` and `Accept` headers to select the desired request and response format.   application/json ----------------  As with creation and retrieval, the content type determines what properties can be manipulated. `application/json` does not support file contents and is therefore limited to a snippet\'s meta data.  To update the title, without changing any of its files:      $ curl -X POST -H \"Content-Type: application/json\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d \'{\"title\": \"Updated title\"}\'   To delete the title:      $ curl -X POST -H \"Content-Type: application/json\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d \'{\"title\": null}\'  Not all parts of a snippet can be manipulated. The owner and creator for instance are immutable.   multipart/related -----------------  `multipart/related` can be used to manipulate all of a snippet\'s properties. The body is identical to a POST. properties omitted from the request are left unchanged. Since the `start` part contains JSON, the mechanism for manipulating the snippet\'s meta data is identical to `application/json` requests.  To update one of a snippet\'s file contents, while also changing its title:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 288     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"title\": \"My updated snippet\",       \"files\": {           \"foo.txt\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      Updated file contents.      --===============1438169132528273974==--  Here only the parts that are changed are included in the body. The other files remain untouched.  Note the use of the `files` list in the JSON part. This list contains the files that are being manipulated. This list should have corresponding multiparts in the request that contain the new contents of these files.  If a filename in the `files` list does not have a corresponding part, it will be deleted from the snippet, as shown below:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 188     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"files\": {         \"image.png\": {}       }     }      --===============1438169132528273974==--  To simulate a rename, delete a file and add the same file under another name:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 212     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {         \"files\": {           \"foo.txt\": {},           \"bar.txt\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"bar.txt\"     Content-Disposition: attachment; filename=\"bar.txt\"      foo      --===============1438169132528273974==--   multipart/form-data -----------------  Again, one can also use `multipart/form-data` to manipulate file contents and meta data atomically.      $ curl -X PUT http://localhost:12345/2.0/snippets/evzijst/kypj             -F title=\"My updated snippet\" -F file=@foo.txt      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 351     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"      My updated snippet     ------------------------------63a4b224c59f  To delete a file, omit its contents while including its name in the `files` field:      $ curl -X PUT https://api.bitbucket.org/2.0/snippets/evzijst/kypj -F files=image.png      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 149     Content-Type: multipart/form-data; boundary=----------------------------ef8871065a86      ------------------------------ef8871065a86     Content-Disposition: form-data; name=\"files\"      image.png     ------------------------------ef8871065a86--  The explicit use of the `files` element in `multipart/related` and `multipart/form-data` is only required when deleting files. The default mode of operation is for file parts to be processed, regardless of whether or not they are listed in `files`, as a convenience to the client.
         * @summary Update a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdPut: async (encodedId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdPut', 'encodedId', encodedId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdPut', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json,multipart/related,multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the diff of the specified commit against its first parent.  Note that this resource is different in functionality from the `patch` resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional `path=foo/bar.py` query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent\'s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the diff is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
         * @summary Get snippet changes between versions
         * @param {string} encodedId The snippet id.
         * @param {string} revision A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like &#x60;staging..production&#x60;.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [path] When used, only one the diff of the specified file will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdRevisionDiffGet: async (encodedId: string, revision: string, workspace: string, path?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdRevisionDiffGet', 'encodedId', encodedId)
            // verify required parameter 'revision' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdRevisionDiffGet', 'revision', revision)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdRevisionDiffGet', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/{revision}/diff`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"revision"}}`, encodeURIComponent(String(revision)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the patch of the specified commit against its first parent.  Note that this resource is different in functionality from the `diff` resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional `path=foo/bar.py` query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent\'s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the patch is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
         * @summary Get snippet patch between versions
         * @param {string} encodedId The snippet id.
         * @param {string} revision A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like &#x60;staging..production&#x60;.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdRevisionPatchGet: async (encodedId: string, revision: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdRevisionPatchGet', 'encodedId', encodedId)
            // verify required parameter 'revision' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdRevisionPatchGet', 'revision', revision)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdRevisionPatchGet', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/{revision}/patch`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"revision"}}`, encodeURIComponent(String(revision)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to stop watching a specific snippet. Returns 204 (No Content) to indicate success.
         * @summary Stop watching a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdWatchDelete: async (encodedId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdWatchDelete', 'encodedId', encodedId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdWatchDelete', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/watch`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to check if the current user is watching a specific snippet.  Returns 204 (No Content) if the user is watching the snippet and 404 if not.  Hitting this endpoint anonymously always returns a 404.
         * @summary Check if the current user is watching a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdWatchGet: async (encodedId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdWatchGet', 'encodedId', encodedId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdWatchGet', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/watch`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to start watching a specific snippet. Returns 204 (No Content).
         * @summary Watch a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdWatchPut: async (encodedId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdWatchPut', 'encodedId', encodedId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdWatchPut', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/watch`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all users watching a specific snippet.
         * @summary List users watching a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdWatchersGet: async (encodedId: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'encodedId' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdWatchersGet', 'encodedId', encodedId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceEncodedIdWatchersGet', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}/{encoded_id}/watchers`
                .replace(`{${"encoded_id"}}`, encodeURIComponent(String(encodedId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Identical to [`/snippets`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-get), except that the result is further filtered by the snippet owner and only those that are owned by `{workspace}` are returned.
         * @summary List snippets in a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {SnippetsWorkspaceGetRoleEnum} [role] Filter down the result based on the authenticated user\&#39;s role (&#x60;owner&#x60;, &#x60;contributor&#x60;, or &#x60;member&#x60;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceGet: async (workspace: string, role?: SnippetsWorkspaceGetRoleEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspaceGet', 'workspace', workspace)
            const localVarPath = `/snippets/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Identical to [`/snippets`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-post), except that the new snippet will be created under the workspace specified in the path parameter `{workspace}`.
         * @summary Create a snippet for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Snippet} body The new snippet object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspacePost: async (workspace: string, body: Snippet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('snippetsWorkspacePost', 'workspace', workspace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('snippetsWorkspacePost', 'body', body)
            const localVarPath = `/snippets/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["snippet:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SnippetsApi - functional programming interface
 */
export const SnippetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SnippetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all snippets. Like pull requests, repositories and workspaces, the full set of snippets is defined by what the current user has access to.  This includes all snippets owned by any of the workspaces the user is a member of, or snippets by other users that the current user is either watching or has collaborated on (for instance by commenting on it).  To limit the set of returned snippets, apply the `?role=[owner|contributor|member]` query parameter where the roles are defined as follows:  * `owner`: all snippets owned by the current user * `contributor`: all snippets owned by, or watched by the current user * `member`: created in a workspaces or watched by the current user  When no role is specified, all public snippets are returned, as well as all privately owned snippets watched or commented on.  The returned response is a normal paginated JSON list. This endpoint only supports `application/json` responses and no `multipart/form-data` or `multipart/related`. As a result, it is not possible to include the file contents.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-workspace-get).
         * @summary List snippets
         * @param {SnippetsGetRoleEnum} [role] Filter down the result based on the authenticated user\&#39;s role (&#x60;owner&#x60;, &#x60;contributor&#x60;, or &#x60;member&#x60;).
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async snippetsGet(role?: SnippetsGetRoleEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSnippets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsGet(role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new snippet under the authenticated user\'s account.  Snippets can contain multiple files. Both text and binary files are supported.  The simplest way to create a new snippet from a local file:      $ curl -u username:password -X POST https://api.bitbucket.org/2.0/snippets               -F file=@image.png  Creating snippets through curl has a few limitations and so let\'s look at a more complicated scenario.  Snippets are created with a multipart POST. Both `multipart/form-data` and `multipart/related` are supported. Both allow the creation of snippets with both meta data (title, etc), as well as multiple text and binary files.  The main difference is that `multipart/related` can use rich encoding for the meta data (currently JSON).   multipart/related (RFC-2387) ----------------------------  This is the most advanced and efficient way to create a paste.      POST /2.0/snippets/evzijst HTTP/1.1     Content-Length: 1188     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"title\": \"My snippet\",       \"is_private\": true,       \"scm\": \"git\",       \"files\": {           \"foo.txt\": {},           \"image.png\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      foo      --===============1438169132528273974==     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \"image.png\"     Content-Disposition: attachment; filename=\"image.png\"      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     --===============1438169132528273974==--  The request contains multiple parts and is structured as follows.  The first part is the JSON document that describes the snippet\'s properties or meta data. It either has to be the first part, or the request\'s `Content-Type` header must contain the `start` parameter to point to it.  The remaining parts are the files of which there can be zero or more. Each file part should contain the `Content-ID` MIME header through which the JSON meta data\'s `files` element addresses it. The value should be the name of the file.  `Content-Disposition` is an optional MIME header. The header\'s optional `filename` parameter can be used to specify the file name that Bitbucket should use when writing the file to disk. When present, `filename` takes precedence over the value of `Content-ID`.  When the JSON body omits the `files` element, the remaining parts are not ignored. Instead, each file is added to the new snippet as if its name was explicitly linked (the use of the `files` elements is mandatory for some operations like deleting or renaming files).   multipart/form-data -------------------  The use of JSON for the snippet\'s meta data is optional. Meta data can also be supplied as regular form fields in a more conventional `multipart/form-data` request:      $ curl -X POST -u credentials https://api.bitbucket.org/2.0/snippets               -F title=\"My snippet\"               -F file=@foo.txt -F file=@image.png      POST /2.0/snippets HTTP/1.1     Content-Length: 951     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"image.png\"     Content-Type: application/octet-stream      ?PNG      IHDR?1??I.....     ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"      My snippet     ------------------------------63a4b224c59f--  Here the meta data properties are included as flat, top-level form fields. The file attachments use the `file` field name. To attach multiple files, simply repeat the field.  The advantage of `multipart/form-data` over `multipart/related` is that it can be easier to build clients.  Essentially all properties are optional, `title` and `files` included.   Sharing and Visibility ----------------------  Snippets can be either public (visible to anyone on Bitbucket, as well as anonymous users), or private (visible only to members of the workspace). This is controlled through the snippet\'s `is_private` element:  * **is_private=false** -- everyone, including anonymous users can view   the snippet * **is_private=true** -- only workspace members can view the snippet  To create the snippet under a workspace, just append the workspace ID to the URL. See [`/2.0/snippets/{workspace}`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-workspace-post).
         * @summary Create a snippet
         * @param {Snippet} body The new snippet object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsPost(body: Snippet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Snippet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsPost(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a snippet comment.  Comments can only be removed by the comment author, snippet creator, or workspace admin.
         * @summary Delete a comment on a snippet
         * @param {number} commentId The id of the comment.
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdCommentsCommentIdDelete(commentId: number, encodedId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdCommentsCommentIdDelete(commentId, encodedId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdCommentsCommentIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specific snippet comment.
         * @summary Get a comment on a snippet
         * @param {number} commentId The id of the comment.
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdCommentsCommentIdGet(commentId: number, encodedId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SnippetComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdCommentsCommentIdGet(commentId, encodedId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdCommentsCommentIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a comment.  The only required field in the body is `content.raw`.  Comments can only be updated by their author.
         * @summary Update a comment on a snippet
         * @param {number} commentId The id of the comment.
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {SnippetComment} body The contents to update the comment to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdCommentsCommentIdPut(commentId: number, encodedId: string, workspace: string, body: SnippetComment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SnippetComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdCommentsCommentIdPut(commentId, encodedId, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdCommentsCommentIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to retrieve a paginated list of all comments for a specific snippet.  This resource works identical to commit and pull request comments.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.
         * @summary List comments on a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdCommentsGet(encodedId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSnippetComments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdCommentsGet(encodedId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdCommentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new comment.  The only required field in the body is `content.raw`.  To create a threaded reply to an existing comment, include `parent.id`.
         * @summary Create a comment on a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {SnippetComment} body The contents of the new comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdCommentsPost(encodedId: string, workspace: string, body: SnippetComment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SnippetComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdCommentsPost(encodedId, workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdCommentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the changes (commits) made on this snippet.
         * @summary List snippet changes
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdCommitsGet(encodedId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSnippetCommit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdCommitsGet(encodedId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdCommitsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the changes made on this snippet in this commit.
         * @summary Get a previous snippet change
         * @param {string} encodedId The snippet id.
         * @param {string} revision The commit\&#39;s SHA1.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdCommitsRevisionGet(encodedId: string, revision: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SnippetCommit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdCommitsRevisionGet(encodedId, revision, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdCommitsRevisionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a snippet and returns an empty response.
         * @summary Delete a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdDelete(encodedId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdDelete(encodedId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Convenience resource for getting to a snippet\'s raw files without the need for first having to retrieve the snippet itself and having to pull out the versioned file links.
         * @summary Get a snippet\'s raw file at HEAD
         * @param {string} encodedId The snippet id.
         * @param {string} path Path to the file.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdFilesPathGet(encodedId: string, path: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdFilesPathGet(encodedId, path, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdFilesPathGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single snippet.  Snippets support multiple content types:  * application/json * multipart/related * multipart/form-data   application/json ----------------  The default content type of the response is `application/json`. Since JSON is always `utf-8`, it cannot reliably contain file contents for files that are not text. Therefore, JSON snippet documents only contain the filename and links to the file contents.  This means that in order to retrieve all parts of a snippet, N+1 requests need to be made (where N is the number of files in the snippet).   multipart/related -----------------  To retrieve an entire snippet in a single response, use the `Accept: multipart/related` HTTP request header.      $ curl -H \"Accept: multipart/related\" https://api.bitbucket.org/2.0/snippets/evzijst/1  Response:      HTTP/1.1 200 OK     Content-Length: 2214     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj\"         },         \"html\": {           \"href\": \"https://bitbucket.org/snippets/evzijst/kypj\"         },         \"comments\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/comments\"         },         \"watchers\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/watchers\"         },         \"commits\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/commits\"         }       },       \"id\": kypj,       \"title\": \"My snippet\",       \"created_on\": \"2014-12-29T22:22:04.790331+00:00\",       \"updated_on\": \"2014-12-29T22:22:04.790331+00:00\",       \"is_private\": false,       \"files\": {         \"foo.txt\": {           \"links\": {             \"self\": {               \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/foo.txt\"             },             \"html\": {               \"href\": \"https://bitbucket.org/snippets/evzijst/kypj#file-foo.txt\"             }           }         },         \"image.png\": {           \"links\": {             \"self\": {               \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/image.png\"             },             \"html\": {               \"href\": \"https://bitbucket.org/snippets/evzijst/kypj#file-image.png\"             }           }         }       ],       \"owner\": {         \"username\": \"evzijst\",         \"nickname\": \"evzijst\",         \"display_name\": \"Erik van Zijst\",         \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"           },           \"html\": {             \"href\": \"https://bitbucket.org/evzijst\"           },           \"avatar\": {             \"href\": \"https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\"           }         }       },       \"creator\": {         \"username\": \"evzijst\",         \"nickname\": \"evzijst\",         \"display_name\": \"Erik van Zijst\",         \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"           },           \"html\": {             \"href\": \"https://bitbucket.org/evzijst\"           },           \"avatar\": {             \"href\": \"https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\"           }         }       }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      foo      --===============1438169132528273974==     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \"image.png\"     Content-Disposition: attachment; filename=\"image.png\"      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     --===============1438169132528273974==--  multipart/form-data -------------------  As with creating new snippets, `multipart/form-data` can be used as an alternative to `multipart/related`. However, the inherently flat structure of form-data means that only basic, root-level properties can be returned, while nested elements like `links` are omitted:      $ curl -H \"Accept: multipart/form-data\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj  Response:      HTTP/1.1 200 OK     Content-Length: 951     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"     Content-Type: text/plain; charset=\"utf-8\"      My snippet     ------------------------------63a4b224c59f--     Content-Disposition: attachment; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: attachment; name=\"file\"; filename=\"image.png\"     Content-Transfer-Encoding: base64     Content-Type: application/octet-stream      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     ------------------------------5957323a6b76--
         * @summary Get a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdGet(encodedId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Snippet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdGet(encodedId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the snippet.  Note that this only works for versioned URLs that point to the latest commit of the snippet. Pointing to an older commit results in a 405 status code.  To delete a snippet, regardless of whether or not concurrent changes are being made to it, use `DELETE /snippets/{encoded_id}` instead.
         * @summary Delete a previous revision of a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} nodeId A commit revision (SHA1).
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdNodeIdDelete(encodedId: string, nodeId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdNodeIdDelete(encodedId, nodeId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdNodeIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the raw contents of a specific file in the snippet. The `Content-Disposition` header will be \"attachment\" to avoid issues with malevolent executable files.  The file\'s mime type is derived from its filename and returned in the `Content-Type` header.  Note that for text files, no character encoding is included as part of the content type.
         * @summary Get a snippet\'s raw file
         * @param {string} encodedId The snippet id.
         * @param {string} nodeId A commit revision (SHA1).
         * @param {string} path Path to the file.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdNodeIdFilesPathGet(encodedId: string, nodeId: string, path: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdNodeIdFilesPathGet(encodedId, nodeId, path, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdNodeIdFilesPathGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Identical to `GET /snippets/encoded_id`, except that this endpoint can be used to retrieve the contents of the snippet as it was at an older revision, while `/snippets/encoded_id` always returns the snippet\'s current revision.  Note that only the snippet\'s file contents are versioned, not its meta data properties like the title.  Other than that, the two endpoints are identical in behavior.
         * @summary Get a previous revision of a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} nodeId A commit revision (SHA1).
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdNodeIdGet(encodedId: string, nodeId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Snippet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdNodeIdGet(encodedId, nodeId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdNodeIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Identical to `UPDATE /snippets/encoded_id`, except that this endpoint takes an explicit commit revision. Only the snippet\'s \"HEAD\"/\"tip\" (most recent) version can be updated and requests on all other, older revisions fail by returning a 405 status.  Usage of this endpoint over the unrestricted `/snippets/encoded_id` could be desired if the caller wants to be sure no concurrent modifications have taken place between the moment of the UPDATE request and the original GET.  This can be considered a so-called \"Compare And Swap\", or CAS operation.  Other than that, the two endpoints are identical in behavior.
         * @summary Update a previous revision of a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} nodeId A commit revision (SHA1).
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdNodeIdPut(encodedId: string, nodeId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Snippet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdNodeIdPut(encodedId, nodeId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdNodeIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to update a snippet. Use this to add and delete files and to change a snippet\'s title.  To update a snippet, one can either PUT a full snapshot, or only the parts that need to be changed.  The contract for PUT on this API is that properties missing from the request remain untouched so that snippets can be efficiently manipulated with differential payloads.  To delete a property (e.g. the title, or a file), include its name in the request, but omit its value (use `null`).  As in Git, explicit renaming of files is not supported. Instead, to rename a file, delete it and add it again under another name. This can be done atomically in a single request. Rename detection is left to the SCM.  PUT supports three different content types for both request and response bodies:  * `application/json` * `multipart/related` * `multipart/form-data`  The content type used for the request body can be different than that used for the response. Content types are specified using standard HTTP headers.  Use the `Content-Type` and `Accept` headers to select the desired request and response format.   application/json ----------------  As with creation and retrieval, the content type determines what properties can be manipulated. `application/json` does not support file contents and is therefore limited to a snippet\'s meta data.  To update the title, without changing any of its files:      $ curl -X POST -H \"Content-Type: application/json\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d \'{\"title\": \"Updated title\"}\'   To delete the title:      $ curl -X POST -H \"Content-Type: application/json\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d \'{\"title\": null}\'  Not all parts of a snippet can be manipulated. The owner and creator for instance are immutable.   multipart/related -----------------  `multipart/related` can be used to manipulate all of a snippet\'s properties. The body is identical to a POST. properties omitted from the request are left unchanged. Since the `start` part contains JSON, the mechanism for manipulating the snippet\'s meta data is identical to `application/json` requests.  To update one of a snippet\'s file contents, while also changing its title:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 288     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"title\": \"My updated snippet\",       \"files\": {           \"foo.txt\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      Updated file contents.      --===============1438169132528273974==--  Here only the parts that are changed are included in the body. The other files remain untouched.  Note the use of the `files` list in the JSON part. This list contains the files that are being manipulated. This list should have corresponding multiparts in the request that contain the new contents of these files.  If a filename in the `files` list does not have a corresponding part, it will be deleted from the snippet, as shown below:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 188     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"files\": {         \"image.png\": {}       }     }      --===============1438169132528273974==--  To simulate a rename, delete a file and add the same file under another name:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 212     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {         \"files\": {           \"foo.txt\": {},           \"bar.txt\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"bar.txt\"     Content-Disposition: attachment; filename=\"bar.txt\"      foo      --===============1438169132528273974==--   multipart/form-data -----------------  Again, one can also use `multipart/form-data` to manipulate file contents and meta data atomically.      $ curl -X PUT http://localhost:12345/2.0/snippets/evzijst/kypj             -F title=\"My updated snippet\" -F file=@foo.txt      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 351     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"      My updated snippet     ------------------------------63a4b224c59f  To delete a file, omit its contents while including its name in the `files` field:      $ curl -X PUT https://api.bitbucket.org/2.0/snippets/evzijst/kypj -F files=image.png      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 149     Content-Type: multipart/form-data; boundary=----------------------------ef8871065a86      ------------------------------ef8871065a86     Content-Disposition: form-data; name=\"files\"      image.png     ------------------------------ef8871065a86--  The explicit use of the `files` element in `multipart/related` and `multipart/form-data` is only required when deleting files. The default mode of operation is for file parts to be processed, regardless of whether or not they are listed in `files`, as a convenience to the client.
         * @summary Update a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdPut(encodedId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Snippet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdPut(encodedId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the diff of the specified commit against its first parent.  Note that this resource is different in functionality from the `patch` resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional `path=foo/bar.py` query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent\'s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the diff is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
         * @summary Get snippet changes between versions
         * @param {string} encodedId The snippet id.
         * @param {string} revision A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like &#x60;staging..production&#x60;.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [path] When used, only one the diff of the specified file will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdRevisionDiffGet(encodedId: string, revision: string, workspace: string, path?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdRevisionDiffGet(encodedId, revision, workspace, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdRevisionDiffGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the patch of the specified commit against its first parent.  Note that this resource is different in functionality from the `diff` resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional `path=foo/bar.py` query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent\'s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the patch is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
         * @summary Get snippet patch between versions
         * @param {string} encodedId The snippet id.
         * @param {string} revision A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like &#x60;staging..production&#x60;.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdRevisionPatchGet(encodedId: string, revision: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdRevisionPatchGet(encodedId, revision, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdRevisionPatchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to stop watching a specific snippet. Returns 204 (No Content) to indicate success.
         * @summary Stop watching a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdWatchDelete(encodedId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdWatchDelete(encodedId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdWatchDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to check if the current user is watching a specific snippet.  Returns 204 (No Content) if the user is watching the snippet and 404 if not.  Hitting this endpoint anonymously always returns a 404.
         * @summary Check if the current user is watching a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdWatchGet(encodedId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdWatchGet(encodedId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdWatchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to start watching a specific snippet. Returns 204 (No Content).
         * @summary Watch a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdWatchPut(encodedId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdWatchPut(encodedId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdWatchPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all users watching a specific snippet.
         * @summary List users watching a snippet
         * @param {string} encodedId The snippet id.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async snippetsWorkspaceEncodedIdWatchersGet(encodedId: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAccounts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceEncodedIdWatchersGet(encodedId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceEncodedIdWatchersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Identical to [`/snippets`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-get), except that the result is further filtered by the snippet owner and only those that are owned by `{workspace}` are returned.
         * @summary List snippets in a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {SnippetsWorkspaceGetRoleEnum} [role] Filter down the result based on the authenticated user\&#39;s role (&#x60;owner&#x60;, &#x60;contributor&#x60;, or &#x60;member&#x60;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspaceGet(workspace: string, role?: SnippetsWorkspaceGetRoleEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSnippets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspaceGet(workspace, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspaceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Identical to [`/snippets`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-post), except that the new snippet will be created under the workspace specified in the path parameter `{workspace}`.
         * @summary Create a snippet for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {Snippet} body The new snippet object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snippetsWorkspacePost(workspace: string, body: Snippet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Snippet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snippetsWorkspacePost(workspace, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnippetsApi.snippetsWorkspacePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SnippetsApi - factory interface
 */
export const SnippetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SnippetsApiFp(configuration)
    return {
        /**
         * Returns all snippets. Like pull requests, repositories and workspaces, the full set of snippets is defined by what the current user has access to.  This includes all snippets owned by any of the workspaces the user is a member of, or snippets by other users that the current user is either watching or has collaborated on (for instance by commenting on it).  To limit the set of returned snippets, apply the `?role=[owner|contributor|member]` query parameter where the roles are defined as follows:  * `owner`: all snippets owned by the current user * `contributor`: all snippets owned by, or watched by the current user * `member`: created in a workspaces or watched by the current user  When no role is specified, all public snippets are returned, as well as all privately owned snippets watched or commented on.  The returned response is a normal paginated JSON list. This endpoint only supports `application/json` responses and no `multipart/form-data` or `multipart/related`. As a result, it is not possible to include the file contents.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-workspace-get).
         * @summary List snippets
         * @param {SnippetsApiSnippetsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        snippetsGet(requestParameters: SnippetsApiSnippetsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSnippets> {
            return localVarFp.snippetsGet(requestParameters.role, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new snippet under the authenticated user\'s account.  Snippets can contain multiple files. Both text and binary files are supported.  The simplest way to create a new snippet from a local file:      $ curl -u username:password -X POST https://api.bitbucket.org/2.0/snippets               -F file=@image.png  Creating snippets through curl has a few limitations and so let\'s look at a more complicated scenario.  Snippets are created with a multipart POST. Both `multipart/form-data` and `multipart/related` are supported. Both allow the creation of snippets with both meta data (title, etc), as well as multiple text and binary files.  The main difference is that `multipart/related` can use rich encoding for the meta data (currently JSON).   multipart/related (RFC-2387) ----------------------------  This is the most advanced and efficient way to create a paste.      POST /2.0/snippets/evzijst HTTP/1.1     Content-Length: 1188     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"title\": \"My snippet\",       \"is_private\": true,       \"scm\": \"git\",       \"files\": {           \"foo.txt\": {},           \"image.png\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      foo      --===============1438169132528273974==     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \"image.png\"     Content-Disposition: attachment; filename=\"image.png\"      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     --===============1438169132528273974==--  The request contains multiple parts and is structured as follows.  The first part is the JSON document that describes the snippet\'s properties or meta data. It either has to be the first part, or the request\'s `Content-Type` header must contain the `start` parameter to point to it.  The remaining parts are the files of which there can be zero or more. Each file part should contain the `Content-ID` MIME header through which the JSON meta data\'s `files` element addresses it. The value should be the name of the file.  `Content-Disposition` is an optional MIME header. The header\'s optional `filename` parameter can be used to specify the file name that Bitbucket should use when writing the file to disk. When present, `filename` takes precedence over the value of `Content-ID`.  When the JSON body omits the `files` element, the remaining parts are not ignored. Instead, each file is added to the new snippet as if its name was explicitly linked (the use of the `files` elements is mandatory for some operations like deleting or renaming files).   multipart/form-data -------------------  The use of JSON for the snippet\'s meta data is optional. Meta data can also be supplied as regular form fields in a more conventional `multipart/form-data` request:      $ curl -X POST -u credentials https://api.bitbucket.org/2.0/snippets               -F title=\"My snippet\"               -F file=@foo.txt -F file=@image.png      POST /2.0/snippets HTTP/1.1     Content-Length: 951     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"image.png\"     Content-Type: application/octet-stream      ?PNG      IHDR?1??I.....     ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"      My snippet     ------------------------------63a4b224c59f--  Here the meta data properties are included as flat, top-level form fields. The file attachments use the `file` field name. To attach multiple files, simply repeat the field.  The advantage of `multipart/form-data` over `multipart/related` is that it can be easier to build clients.  Essentially all properties are optional, `title` and `files` included.   Sharing and Visibility ----------------------  Snippets can be either public (visible to anyone on Bitbucket, as well as anonymous users), or private (visible only to members of the workspace). This is controlled through the snippet\'s `is_private` element:  * **is_private=false** -- everyone, including anonymous users can view   the snippet * **is_private=true** -- only workspace members can view the snippet  To create the snippet under a workspace, just append the workspace ID to the URL. See [`/2.0/snippets/{workspace}`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-workspace-post).
         * @summary Create a snippet
         * @param {SnippetsApiSnippetsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsPost(requestParameters: SnippetsApiSnippetsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Snippet> {
            return localVarFp.snippetsPost(requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a snippet comment.  Comments can only be removed by the comment author, snippet creator, or workspace admin.
         * @summary Delete a comment on a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdCommentsCommentIdDelete(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.snippetsWorkspaceEncodedIdCommentsCommentIdDelete(requestParameters.commentId, requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specific snippet comment.
         * @summary Get a comment on a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdCommentsCommentIdGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<SnippetComment> {
            return localVarFp.snippetsWorkspaceEncodedIdCommentsCommentIdGet(requestParameters.commentId, requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a comment.  The only required field in the body is `content.raw`.  Comments can only be updated by their author.
         * @summary Update a comment on a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdCommentsCommentIdPut(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<SnippetComment> {
            return localVarFp.snippetsWorkspaceEncodedIdCommentsCommentIdPut(requestParameters.commentId, requestParameters.encodedId, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to retrieve a paginated list of all comments for a specific snippet.  This resource works identical to commit and pull request comments.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.
         * @summary List comments on a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdCommentsGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSnippetComments> {
            return localVarFp.snippetsWorkspaceEncodedIdCommentsGet(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new comment.  The only required field in the body is `content.raw`.  To create a threaded reply to an existing comment, include `parent.id`.
         * @summary Create a comment on a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdCommentsPost(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<SnippetComment> {
            return localVarFp.snippetsWorkspaceEncodedIdCommentsPost(requestParameters.encodedId, requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the changes (commits) made on this snippet.
         * @summary List snippet changes
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommitsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdCommitsGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommitsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSnippetCommit> {
            return localVarFp.snippetsWorkspaceEncodedIdCommitsGet(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the changes made on this snippet in this commit.
         * @summary Get a previous snippet change
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommitsRevisionGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdCommitsRevisionGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommitsRevisionGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<SnippetCommit> {
            return localVarFp.snippetsWorkspaceEncodedIdCommitsRevisionGet(requestParameters.encodedId, requestParameters.revision, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a snippet and returns an empty response.
         * @summary Delete a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdDelete(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.snippetsWorkspaceEncodedIdDelete(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Convenience resource for getting to a snippet\'s raw files without the need for first having to retrieve the snippet itself and having to pull out the versioned file links.
         * @summary Get a snippet\'s raw file at HEAD
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdFilesPathGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdFilesPathGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdFilesPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.snippetsWorkspaceEncodedIdFilesPathGet(requestParameters.encodedId, requestParameters.path, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single snippet.  Snippets support multiple content types:  * application/json * multipart/related * multipart/form-data   application/json ----------------  The default content type of the response is `application/json`. Since JSON is always `utf-8`, it cannot reliably contain file contents for files that are not text. Therefore, JSON snippet documents only contain the filename and links to the file contents.  This means that in order to retrieve all parts of a snippet, N+1 requests need to be made (where N is the number of files in the snippet).   multipart/related -----------------  To retrieve an entire snippet in a single response, use the `Accept: multipart/related` HTTP request header.      $ curl -H \"Accept: multipart/related\" https://api.bitbucket.org/2.0/snippets/evzijst/1  Response:      HTTP/1.1 200 OK     Content-Length: 2214     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj\"         },         \"html\": {           \"href\": \"https://bitbucket.org/snippets/evzijst/kypj\"         },         \"comments\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/comments\"         },         \"watchers\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/watchers\"         },         \"commits\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/commits\"         }       },       \"id\": kypj,       \"title\": \"My snippet\",       \"created_on\": \"2014-12-29T22:22:04.790331+00:00\",       \"updated_on\": \"2014-12-29T22:22:04.790331+00:00\",       \"is_private\": false,       \"files\": {         \"foo.txt\": {           \"links\": {             \"self\": {               \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/foo.txt\"             },             \"html\": {               \"href\": \"https://bitbucket.org/snippets/evzijst/kypj#file-foo.txt\"             }           }         },         \"image.png\": {           \"links\": {             \"self\": {               \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/image.png\"             },             \"html\": {               \"href\": \"https://bitbucket.org/snippets/evzijst/kypj#file-image.png\"             }           }         }       ],       \"owner\": {         \"username\": \"evzijst\",         \"nickname\": \"evzijst\",         \"display_name\": \"Erik van Zijst\",         \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"           },           \"html\": {             \"href\": \"https://bitbucket.org/evzijst\"           },           \"avatar\": {             \"href\": \"https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\"           }         }       },       \"creator\": {         \"username\": \"evzijst\",         \"nickname\": \"evzijst\",         \"display_name\": \"Erik van Zijst\",         \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"           },           \"html\": {             \"href\": \"https://bitbucket.org/evzijst\"           },           \"avatar\": {             \"href\": \"https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\"           }         }       }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      foo      --===============1438169132528273974==     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \"image.png\"     Content-Disposition: attachment; filename=\"image.png\"      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     --===============1438169132528273974==--  multipart/form-data -------------------  As with creating new snippets, `multipart/form-data` can be used as an alternative to `multipart/related`. However, the inherently flat structure of form-data means that only basic, root-level properties can be returned, while nested elements like `links` are omitted:      $ curl -H \"Accept: multipart/form-data\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj  Response:      HTTP/1.1 200 OK     Content-Length: 951     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"     Content-Type: text/plain; charset=\"utf-8\"      My snippet     ------------------------------63a4b224c59f--     Content-Disposition: attachment; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: attachment; name=\"file\"; filename=\"image.png\"     Content-Transfer-Encoding: base64     Content-Type: application/octet-stream      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     ------------------------------5957323a6b76--
         * @summary Get a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Snippet> {
            return localVarFp.snippetsWorkspaceEncodedIdGet(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the snippet.  Note that this only works for versioned URLs that point to the latest commit of the snippet. Pointing to an older commit results in a 405 status code.  To delete a snippet, regardless of whether or not concurrent changes are being made to it, use `DELETE /snippets/{encoded_id}` instead.
         * @summary Delete a previous revision of a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdNodeIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdNodeIdDelete(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdNodeIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.snippetsWorkspaceEncodedIdNodeIdDelete(requestParameters.encodedId, requestParameters.nodeId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the raw contents of a specific file in the snippet. The `Content-Disposition` header will be \"attachment\" to avoid issues with malevolent executable files.  The file\'s mime type is derived from its filename and returned in the `Content-Type` header.  Note that for text files, no character encoding is included as part of the content type.
         * @summary Get a snippet\'s raw file
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdNodeIdFilesPathGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdNodeIdFilesPathGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdNodeIdFilesPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.snippetsWorkspaceEncodedIdNodeIdFilesPathGet(requestParameters.encodedId, requestParameters.nodeId, requestParameters.path, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Identical to `GET /snippets/encoded_id`, except that this endpoint can be used to retrieve the contents of the snippet as it was at an older revision, while `/snippets/encoded_id` always returns the snippet\'s current revision.  Note that only the snippet\'s file contents are versioned, not its meta data properties like the title.  Other than that, the two endpoints are identical in behavior.
         * @summary Get a previous revision of a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdNodeIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdNodeIdGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdNodeIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Snippet> {
            return localVarFp.snippetsWorkspaceEncodedIdNodeIdGet(requestParameters.encodedId, requestParameters.nodeId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Identical to `UPDATE /snippets/encoded_id`, except that this endpoint takes an explicit commit revision. Only the snippet\'s \"HEAD\"/\"tip\" (most recent) version can be updated and requests on all other, older revisions fail by returning a 405 status.  Usage of this endpoint over the unrestricted `/snippets/encoded_id` could be desired if the caller wants to be sure no concurrent modifications have taken place between the moment of the UPDATE request and the original GET.  This can be considered a so-called \"Compare And Swap\", or CAS operation.  Other than that, the two endpoints are identical in behavior.
         * @summary Update a previous revision of a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdNodeIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdNodeIdPut(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdNodeIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Snippet> {
            return localVarFp.snippetsWorkspaceEncodedIdNodeIdPut(requestParameters.encodedId, requestParameters.nodeId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to update a snippet. Use this to add and delete files and to change a snippet\'s title.  To update a snippet, one can either PUT a full snapshot, or only the parts that need to be changed.  The contract for PUT on this API is that properties missing from the request remain untouched so that snippets can be efficiently manipulated with differential payloads.  To delete a property (e.g. the title, or a file), include its name in the request, but omit its value (use `null`).  As in Git, explicit renaming of files is not supported. Instead, to rename a file, delete it and add it again under another name. This can be done atomically in a single request. Rename detection is left to the SCM.  PUT supports three different content types for both request and response bodies:  * `application/json` * `multipart/related` * `multipart/form-data`  The content type used for the request body can be different than that used for the response. Content types are specified using standard HTTP headers.  Use the `Content-Type` and `Accept` headers to select the desired request and response format.   application/json ----------------  As with creation and retrieval, the content type determines what properties can be manipulated. `application/json` does not support file contents and is therefore limited to a snippet\'s meta data.  To update the title, without changing any of its files:      $ curl -X POST -H \"Content-Type: application/json\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d \'{\"title\": \"Updated title\"}\'   To delete the title:      $ curl -X POST -H \"Content-Type: application/json\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d \'{\"title\": null}\'  Not all parts of a snippet can be manipulated. The owner and creator for instance are immutable.   multipart/related -----------------  `multipart/related` can be used to manipulate all of a snippet\'s properties. The body is identical to a POST. properties omitted from the request are left unchanged. Since the `start` part contains JSON, the mechanism for manipulating the snippet\'s meta data is identical to `application/json` requests.  To update one of a snippet\'s file contents, while also changing its title:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 288     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"title\": \"My updated snippet\",       \"files\": {           \"foo.txt\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      Updated file contents.      --===============1438169132528273974==--  Here only the parts that are changed are included in the body. The other files remain untouched.  Note the use of the `files` list in the JSON part. This list contains the files that are being manipulated. This list should have corresponding multiparts in the request that contain the new contents of these files.  If a filename in the `files` list does not have a corresponding part, it will be deleted from the snippet, as shown below:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 188     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"files\": {         \"image.png\": {}       }     }      --===============1438169132528273974==--  To simulate a rename, delete a file and add the same file under another name:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 212     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {         \"files\": {           \"foo.txt\": {},           \"bar.txt\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"bar.txt\"     Content-Disposition: attachment; filename=\"bar.txt\"      foo      --===============1438169132528273974==--   multipart/form-data -----------------  Again, one can also use `multipart/form-data` to manipulate file contents and meta data atomically.      $ curl -X PUT http://localhost:12345/2.0/snippets/evzijst/kypj             -F title=\"My updated snippet\" -F file=@foo.txt      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 351     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"      My updated snippet     ------------------------------63a4b224c59f  To delete a file, omit its contents while including its name in the `files` field:      $ curl -X PUT https://api.bitbucket.org/2.0/snippets/evzijst/kypj -F files=image.png      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 149     Content-Type: multipart/form-data; boundary=----------------------------ef8871065a86      ------------------------------ef8871065a86     Content-Disposition: form-data; name=\"files\"      image.png     ------------------------------ef8871065a86--  The explicit use of the `files` element in `multipart/related` and `multipart/form-data` is only required when deleting files. The default mode of operation is for file parts to be processed, regardless of whether or not they are listed in `files`, as a convenience to the client.
         * @summary Update a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdPut(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Snippet> {
            return localVarFp.snippetsWorkspaceEncodedIdPut(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the diff of the specified commit against its first parent.  Note that this resource is different in functionality from the `patch` resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional `path=foo/bar.py` query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent\'s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the diff is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
         * @summary Get snippet changes between versions
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdRevisionDiffGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdRevisionDiffGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdRevisionDiffGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.snippetsWorkspaceEncodedIdRevisionDiffGet(requestParameters.encodedId, requestParameters.revision, requestParameters.workspace, requestParameters.path, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the patch of the specified commit against its first parent.  Note that this resource is different in functionality from the `diff` resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional `path=foo/bar.py` query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent\'s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the patch is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
         * @summary Get snippet patch between versions
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdRevisionPatchGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdRevisionPatchGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdRevisionPatchGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.snippetsWorkspaceEncodedIdRevisionPatchGet(requestParameters.encodedId, requestParameters.revision, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to stop watching a specific snippet. Returns 204 (No Content) to indicate success.
         * @summary Stop watching a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdWatchDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdWatchDelete(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdWatchDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.snippetsWorkspaceEncodedIdWatchDelete(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to check if the current user is watching a specific snippet.  Returns 204 (No Content) if the user is watching the snippet and 404 if not.  Hitting this endpoint anonymously always returns a 404.
         * @summary Check if the current user is watching a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdWatchGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdWatchGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdWatchGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.snippetsWorkspaceEncodedIdWatchGet(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to start watching a specific snippet. Returns 204 (No Content).
         * @summary Watch a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdWatchPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdWatchPut(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdWatchPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.snippetsWorkspaceEncodedIdWatchPut(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all users watching a specific snippet.
         * @summary List users watching a snippet
         * @param {SnippetsApiSnippetsWorkspaceEncodedIdWatchersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        snippetsWorkspaceEncodedIdWatchersGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdWatchersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAccounts> {
            return localVarFp.snippetsWorkspaceEncodedIdWatchersGet(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Identical to [`/snippets`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-get), except that the result is further filtered by the snippet owner and only those that are owned by `{workspace}` are returned.
         * @summary List snippets in a workspace
         * @param {SnippetsApiSnippetsWorkspaceGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspaceGet(requestParameters: SnippetsApiSnippetsWorkspaceGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSnippets> {
            return localVarFp.snippetsWorkspaceGet(requestParameters.workspace, requestParameters.role, options).then((request) => request(axios, basePath));
        },
        /**
         * Identical to [`/snippets`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-post), except that the new snippet will be created under the workspace specified in the path parameter `{workspace}`.
         * @summary Create a snippet for a workspace
         * @param {SnippetsApiSnippetsWorkspacePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snippetsWorkspacePost(requestParameters: SnippetsApiSnippetsWorkspacePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Snippet> {
            return localVarFp.snippetsWorkspacePost(requestParameters.workspace, requestParameters.body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SnippetsApi - interface
 */
export interface SnippetsApiInterface {
    /**
     * Returns all snippets. Like pull requests, repositories and workspaces, the full set of snippets is defined by what the current user has access to.  This includes all snippets owned by any of the workspaces the user is a member of, or snippets by other users that the current user is either watching or has collaborated on (for instance by commenting on it).  To limit the set of returned snippets, apply the `?role=[owner|contributor|member]` query parameter where the roles are defined as follows:  * `owner`: all snippets owned by the current user * `contributor`: all snippets owned by, or watched by the current user * `member`: created in a workspaces or watched by the current user  When no role is specified, all public snippets are returned, as well as all privately owned snippets watched or commented on.  The returned response is a normal paginated JSON list. This endpoint only supports `application/json` responses and no `multipart/form-data` or `multipart/related`. As a result, it is not possible to include the file contents.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-workspace-get).
     * @summary List snippets
     * @param {SnippetsApiSnippetsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    snippetsGet(requestParameters?: SnippetsApiSnippetsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSnippets>;

    /**
     * Creates a new snippet under the authenticated user\'s account.  Snippets can contain multiple files. Both text and binary files are supported.  The simplest way to create a new snippet from a local file:      $ curl -u username:password -X POST https://api.bitbucket.org/2.0/snippets               -F file=@image.png  Creating snippets through curl has a few limitations and so let\'s look at a more complicated scenario.  Snippets are created with a multipart POST. Both `multipart/form-data` and `multipart/related` are supported. Both allow the creation of snippets with both meta data (title, etc), as well as multiple text and binary files.  The main difference is that `multipart/related` can use rich encoding for the meta data (currently JSON).   multipart/related (RFC-2387) ----------------------------  This is the most advanced and efficient way to create a paste.      POST /2.0/snippets/evzijst HTTP/1.1     Content-Length: 1188     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"title\": \"My snippet\",       \"is_private\": true,       \"scm\": \"git\",       \"files\": {           \"foo.txt\": {},           \"image.png\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      foo      --===============1438169132528273974==     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \"image.png\"     Content-Disposition: attachment; filename=\"image.png\"      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     --===============1438169132528273974==--  The request contains multiple parts and is structured as follows.  The first part is the JSON document that describes the snippet\'s properties or meta data. It either has to be the first part, or the request\'s `Content-Type` header must contain the `start` parameter to point to it.  The remaining parts are the files of which there can be zero or more. Each file part should contain the `Content-ID` MIME header through which the JSON meta data\'s `files` element addresses it. The value should be the name of the file.  `Content-Disposition` is an optional MIME header. The header\'s optional `filename` parameter can be used to specify the file name that Bitbucket should use when writing the file to disk. When present, `filename` takes precedence over the value of `Content-ID`.  When the JSON body omits the `files` element, the remaining parts are not ignored. Instead, each file is added to the new snippet as if its name was explicitly linked (the use of the `files` elements is mandatory for some operations like deleting or renaming files).   multipart/form-data -------------------  The use of JSON for the snippet\'s meta data is optional. Meta data can also be supplied as regular form fields in a more conventional `multipart/form-data` request:      $ curl -X POST -u credentials https://api.bitbucket.org/2.0/snippets               -F title=\"My snippet\"               -F file=@foo.txt -F file=@image.png      POST /2.0/snippets HTTP/1.1     Content-Length: 951     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"image.png\"     Content-Type: application/octet-stream      ?PNG      IHDR?1??I.....     ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"      My snippet     ------------------------------63a4b224c59f--  Here the meta data properties are included as flat, top-level form fields. The file attachments use the `file` field name. To attach multiple files, simply repeat the field.  The advantage of `multipart/form-data` over `multipart/related` is that it can be easier to build clients.  Essentially all properties are optional, `title` and `files` included.   Sharing and Visibility ----------------------  Snippets can be either public (visible to anyone on Bitbucket, as well as anonymous users), or private (visible only to members of the workspace). This is controlled through the snippet\'s `is_private` element:  * **is_private=false** -- everyone, including anonymous users can view   the snippet * **is_private=true** -- only workspace members can view the snippet  To create the snippet under a workspace, just append the workspace ID to the URL. See [`/2.0/snippets/{workspace}`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-workspace-post).
     * @summary Create a snippet
     * @param {SnippetsApiSnippetsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsPost(requestParameters: SnippetsApiSnippetsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Snippet>;

    /**
     * Deletes a snippet comment.  Comments can only be removed by the comment author, snippet creator, or workspace admin.
     * @summary Delete a comment on a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdCommentsCommentIdDelete(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the specific snippet comment.
     * @summary Get a comment on a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdCommentsCommentIdGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<SnippetComment>;

    /**
     * Updates a comment.  The only required field in the body is `content.raw`.  Comments can only be updated by their author.
     * @summary Update a comment on a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdCommentsCommentIdPut(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<SnippetComment>;

    /**
     * Used to retrieve a paginated list of all comments for a specific snippet.  This resource works identical to commit and pull request comments.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.
     * @summary List comments on a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdCommentsGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSnippetComments>;

    /**
     * Creates a new comment.  The only required field in the body is `content.raw`.  To create a threaded reply to an existing comment, include `parent.id`.
     * @summary Create a comment on a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdCommentsPost(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<SnippetComment>;

    /**
     * Returns the changes (commits) made on this snippet.
     * @summary List snippet changes
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommitsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdCommitsGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommitsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSnippetCommit>;

    /**
     * Returns the changes made on this snippet in this commit.
     * @summary Get a previous snippet change
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommitsRevisionGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdCommitsRevisionGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommitsRevisionGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<SnippetCommit>;

    /**
     * Deletes a snippet and returns an empty response.
     * @summary Delete a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdDelete(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Convenience resource for getting to a snippet\'s raw files without the need for first having to retrieve the snippet itself and having to pull out the versioned file links.
     * @summary Get a snippet\'s raw file at HEAD
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdFilesPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdFilesPathGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdFilesPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves a single snippet.  Snippets support multiple content types:  * application/json * multipart/related * multipart/form-data   application/json ----------------  The default content type of the response is `application/json`. Since JSON is always `utf-8`, it cannot reliably contain file contents for files that are not text. Therefore, JSON snippet documents only contain the filename and links to the file contents.  This means that in order to retrieve all parts of a snippet, N+1 requests need to be made (where N is the number of files in the snippet).   multipart/related -----------------  To retrieve an entire snippet in a single response, use the `Accept: multipart/related` HTTP request header.      $ curl -H \"Accept: multipart/related\" https://api.bitbucket.org/2.0/snippets/evzijst/1  Response:      HTTP/1.1 200 OK     Content-Length: 2214     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj\"         },         \"html\": {           \"href\": \"https://bitbucket.org/snippets/evzijst/kypj\"         },         \"comments\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/comments\"         },         \"watchers\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/watchers\"         },         \"commits\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/commits\"         }       },       \"id\": kypj,       \"title\": \"My snippet\",       \"created_on\": \"2014-12-29T22:22:04.790331+00:00\",       \"updated_on\": \"2014-12-29T22:22:04.790331+00:00\",       \"is_private\": false,       \"files\": {         \"foo.txt\": {           \"links\": {             \"self\": {               \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/foo.txt\"             },             \"html\": {               \"href\": \"https://bitbucket.org/snippets/evzijst/kypj#file-foo.txt\"             }           }         },         \"image.png\": {           \"links\": {             \"self\": {               \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/image.png\"             },             \"html\": {               \"href\": \"https://bitbucket.org/snippets/evzijst/kypj#file-image.png\"             }           }         }       ],       \"owner\": {         \"username\": \"evzijst\",         \"nickname\": \"evzijst\",         \"display_name\": \"Erik van Zijst\",         \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"           },           \"html\": {             \"href\": \"https://bitbucket.org/evzijst\"           },           \"avatar\": {             \"href\": \"https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\"           }         }       },       \"creator\": {         \"username\": \"evzijst\",         \"nickname\": \"evzijst\",         \"display_name\": \"Erik van Zijst\",         \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"           },           \"html\": {             \"href\": \"https://bitbucket.org/evzijst\"           },           \"avatar\": {             \"href\": \"https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\"           }         }       }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      foo      --===============1438169132528273974==     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \"image.png\"     Content-Disposition: attachment; filename=\"image.png\"      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     --===============1438169132528273974==--  multipart/form-data -------------------  As with creating new snippets, `multipart/form-data` can be used as an alternative to `multipart/related`. However, the inherently flat structure of form-data means that only basic, root-level properties can be returned, while nested elements like `links` are omitted:      $ curl -H \"Accept: multipart/form-data\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj  Response:      HTTP/1.1 200 OK     Content-Length: 951     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"     Content-Type: text/plain; charset=\"utf-8\"      My snippet     ------------------------------63a4b224c59f--     Content-Disposition: attachment; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: attachment; name=\"file\"; filename=\"image.png\"     Content-Transfer-Encoding: base64     Content-Type: application/octet-stream      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     ------------------------------5957323a6b76--
     * @summary Get a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Snippet>;

    /**
     * Deletes the snippet.  Note that this only works for versioned URLs that point to the latest commit of the snippet. Pointing to an older commit results in a 405 status code.  To delete a snippet, regardless of whether or not concurrent changes are being made to it, use `DELETE /snippets/{encoded_id}` instead.
     * @summary Delete a previous revision of a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdNodeIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdNodeIdDelete(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdNodeIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the raw contents of a specific file in the snippet. The `Content-Disposition` header will be \"attachment\" to avoid issues with malevolent executable files.  The file\'s mime type is derived from its filename and returned in the `Content-Type` header.  Note that for text files, no character encoding is included as part of the content type.
     * @summary Get a snippet\'s raw file
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdNodeIdFilesPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdNodeIdFilesPathGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdNodeIdFilesPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Identical to `GET /snippets/encoded_id`, except that this endpoint can be used to retrieve the contents of the snippet as it was at an older revision, while `/snippets/encoded_id` always returns the snippet\'s current revision.  Note that only the snippet\'s file contents are versioned, not its meta data properties like the title.  Other than that, the two endpoints are identical in behavior.
     * @summary Get a previous revision of a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdNodeIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdNodeIdGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdNodeIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Snippet>;

    /**
     * Identical to `UPDATE /snippets/encoded_id`, except that this endpoint takes an explicit commit revision. Only the snippet\'s \"HEAD\"/\"tip\" (most recent) version can be updated and requests on all other, older revisions fail by returning a 405 status.  Usage of this endpoint over the unrestricted `/snippets/encoded_id` could be desired if the caller wants to be sure no concurrent modifications have taken place between the moment of the UPDATE request and the original GET.  This can be considered a so-called \"Compare And Swap\", or CAS operation.  Other than that, the two endpoints are identical in behavior.
     * @summary Update a previous revision of a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdNodeIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdNodeIdPut(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdNodeIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Snippet>;

    /**
     * Used to update a snippet. Use this to add and delete files and to change a snippet\'s title.  To update a snippet, one can either PUT a full snapshot, or only the parts that need to be changed.  The contract for PUT on this API is that properties missing from the request remain untouched so that snippets can be efficiently manipulated with differential payloads.  To delete a property (e.g. the title, or a file), include its name in the request, but omit its value (use `null`).  As in Git, explicit renaming of files is not supported. Instead, to rename a file, delete it and add it again under another name. This can be done atomically in a single request. Rename detection is left to the SCM.  PUT supports three different content types for both request and response bodies:  * `application/json` * `multipart/related` * `multipart/form-data`  The content type used for the request body can be different than that used for the response. Content types are specified using standard HTTP headers.  Use the `Content-Type` and `Accept` headers to select the desired request and response format.   application/json ----------------  As with creation and retrieval, the content type determines what properties can be manipulated. `application/json` does not support file contents and is therefore limited to a snippet\'s meta data.  To update the title, without changing any of its files:      $ curl -X POST -H \"Content-Type: application/json\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d \'{\"title\": \"Updated title\"}\'   To delete the title:      $ curl -X POST -H \"Content-Type: application/json\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d \'{\"title\": null}\'  Not all parts of a snippet can be manipulated. The owner and creator for instance are immutable.   multipart/related -----------------  `multipart/related` can be used to manipulate all of a snippet\'s properties. The body is identical to a POST. properties omitted from the request are left unchanged. Since the `start` part contains JSON, the mechanism for manipulating the snippet\'s meta data is identical to `application/json` requests.  To update one of a snippet\'s file contents, while also changing its title:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 288     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"title\": \"My updated snippet\",       \"files\": {           \"foo.txt\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      Updated file contents.      --===============1438169132528273974==--  Here only the parts that are changed are included in the body. The other files remain untouched.  Note the use of the `files` list in the JSON part. This list contains the files that are being manipulated. This list should have corresponding multiparts in the request that contain the new contents of these files.  If a filename in the `files` list does not have a corresponding part, it will be deleted from the snippet, as shown below:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 188     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"files\": {         \"image.png\": {}       }     }      --===============1438169132528273974==--  To simulate a rename, delete a file and add the same file under another name:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 212     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {         \"files\": {           \"foo.txt\": {},           \"bar.txt\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"bar.txt\"     Content-Disposition: attachment; filename=\"bar.txt\"      foo      --===============1438169132528273974==--   multipart/form-data -----------------  Again, one can also use `multipart/form-data` to manipulate file contents and meta data atomically.      $ curl -X PUT http://localhost:12345/2.0/snippets/evzijst/kypj             -F title=\"My updated snippet\" -F file=@foo.txt      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 351     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"      My updated snippet     ------------------------------63a4b224c59f  To delete a file, omit its contents while including its name in the `files` field:      $ curl -X PUT https://api.bitbucket.org/2.0/snippets/evzijst/kypj -F files=image.png      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 149     Content-Type: multipart/form-data; boundary=----------------------------ef8871065a86      ------------------------------ef8871065a86     Content-Disposition: form-data; name=\"files\"      image.png     ------------------------------ef8871065a86--  The explicit use of the `files` element in `multipart/related` and `multipart/form-data` is only required when deleting files. The default mode of operation is for file parts to be processed, regardless of whether or not they are listed in `files`, as a convenience to the client.
     * @summary Update a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdPut(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Snippet>;

    /**
     * Returns the diff of the specified commit against its first parent.  Note that this resource is different in functionality from the `patch` resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional `path=foo/bar.py` query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent\'s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the diff is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
     * @summary Get snippet changes between versions
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdRevisionDiffGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdRevisionDiffGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdRevisionDiffGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the patch of the specified commit against its first parent.  Note that this resource is different in functionality from the `diff` resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional `path=foo/bar.py` query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent\'s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the patch is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
     * @summary Get snippet patch between versions
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdRevisionPatchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdRevisionPatchGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdRevisionPatchGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Used to stop watching a specific snippet. Returns 204 (No Content) to indicate success.
     * @summary Stop watching a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdWatchDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdWatchDelete(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdWatchDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Used to check if the current user is watching a specific snippet.  Returns 204 (No Content) if the user is watching the snippet and 404 if not.  Hitting this endpoint anonymously always returns a 404.
     * @summary Check if the current user is watching a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdWatchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdWatchGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdWatchGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Used to start watching a specific snippet. Returns 204 (No Content).
     * @summary Watch a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdWatchPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdWatchPut(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdWatchPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a paginated list of all users watching a specific snippet.
     * @summary List users watching a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdWatchersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    snippetsWorkspaceEncodedIdWatchersGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdWatchersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAccounts>;

    /**
     * Identical to [`/snippets`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-get), except that the result is further filtered by the snippet owner and only those that are owned by `{workspace}` are returned.
     * @summary List snippets in a workspace
     * @param {SnippetsApiSnippetsWorkspaceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspaceGet(requestParameters: SnippetsApiSnippetsWorkspaceGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSnippets>;

    /**
     * Identical to [`/snippets`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-post), except that the new snippet will be created under the workspace specified in the path parameter `{workspace}`.
     * @summary Create a snippet for a workspace
     * @param {SnippetsApiSnippetsWorkspacePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    snippetsWorkspacePost(requestParameters: SnippetsApiSnippetsWorkspacePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Snippet>;

}

/**
 * Request parameters for snippetsGet operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsGetRequest {
    /**
     * Filter down the result based on the authenticated user\&#39;s role (&#x60;owner&#x60;, &#x60;contributor&#x60;, or &#x60;member&#x60;).
     */
    readonly role?: SnippetsGetRoleEnum
}

/**
 * Request parameters for snippetsPost operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsPostRequest {
    /**
     * The new snippet object.
     */
    readonly body: Snippet
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdCommentsCommentIdDelete operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdDeleteRequest {
    /**
     * The id of the comment.
     */
    readonly commentId: number

    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdCommentsCommentIdGet operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdGetRequest {
    /**
     * The id of the comment.
     */
    readonly commentId: number

    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdCommentsCommentIdPut operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdPutRequest {
    /**
     * The id of the comment.
     */
    readonly commentId: number

    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The contents to update the comment to.
     */
    readonly body: SnippetComment
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdCommentsGet operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdCommentsGetRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdCommentsPost operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdCommentsPostRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The contents of the new comment.
     */
    readonly body: SnippetComment
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdCommitsGet operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdCommitsGetRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdCommitsRevisionGet operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdCommitsRevisionGetRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * The commit\&#39;s SHA1.
     */
    readonly revision: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdDelete operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdDeleteRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdFilesPathGet operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdFilesPathGetRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * Path to the file.
     */
    readonly path: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdGet operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdGetRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdNodeIdDelete operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdNodeIdDeleteRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * A commit revision (SHA1).
     */
    readonly nodeId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdNodeIdFilesPathGet operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdNodeIdFilesPathGetRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * A commit revision (SHA1).
     */
    readonly nodeId: string

    /**
     * Path to the file.
     */
    readonly path: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdNodeIdGet operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdNodeIdGetRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * A commit revision (SHA1).
     */
    readonly nodeId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdNodeIdPut operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdNodeIdPutRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * A commit revision (SHA1).
     */
    readonly nodeId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdPut operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdPutRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdRevisionDiffGet operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdRevisionDiffGetRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like &#x60;staging..production&#x60;.
     */
    readonly revision: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * When used, only one the diff of the specified file will be returned.
     */
    readonly path?: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdRevisionPatchGet operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdRevisionPatchGetRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like &#x60;staging..production&#x60;.
     */
    readonly revision: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdWatchDelete operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdWatchDeleteRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdWatchGet operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdWatchGetRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdWatchPut operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdWatchPutRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceEncodedIdWatchersGet operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceEncodedIdWatchersGetRequest {
    /**
     * The snippet id.
     */
    readonly encodedId: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for snippetsWorkspaceGet operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspaceGetRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * Filter down the result based on the authenticated user\&#39;s role (&#x60;owner&#x60;, &#x60;contributor&#x60;, or &#x60;member&#x60;).
     */
    readonly role?: SnippetsWorkspaceGetRoleEnum
}

/**
 * Request parameters for snippetsWorkspacePost operation in SnippetsApi.
 */
export interface SnippetsApiSnippetsWorkspacePostRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The new snippet object.
     */
    readonly body: Snippet
}

/**
 * SnippetsApi - object-oriented interface
 */
export class SnippetsApi extends BaseAPI implements SnippetsApiInterface {
    /**
     * Returns all snippets. Like pull requests, repositories and workspaces, the full set of snippets is defined by what the current user has access to.  This includes all snippets owned by any of the workspaces the user is a member of, or snippets by other users that the current user is either watching or has collaborated on (for instance by commenting on it).  To limit the set of returned snippets, apply the `?role=[owner|contributor|member]` query parameter where the roles are defined as follows:  * `owner`: all snippets owned by the current user * `contributor`: all snippets owned by, or watched by the current user * `member`: created in a workspaces or watched by the current user  When no role is specified, all public snippets are returned, as well as all privately owned snippets watched or commented on.  The returned response is a normal paginated JSON list. This endpoint only supports `application/json` responses and no `multipart/form-data` or `multipart/related`. As a result, it is not possible to include the file contents.  This endpoint is deprecated. We recommend you use the [workspace scoped alternative](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-workspace-get).
     * @summary List snippets
     * @param {SnippetsApiSnippetsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public snippetsGet(requestParameters: SnippetsApiSnippetsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsGet(requestParameters.role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new snippet under the authenticated user\'s account.  Snippets can contain multiple files. Both text and binary files are supported.  The simplest way to create a new snippet from a local file:      $ curl -u username:password -X POST https://api.bitbucket.org/2.0/snippets               -F file=@image.png  Creating snippets through curl has a few limitations and so let\'s look at a more complicated scenario.  Snippets are created with a multipart POST. Both `multipart/form-data` and `multipart/related` are supported. Both allow the creation of snippets with both meta data (title, etc), as well as multiple text and binary files.  The main difference is that `multipart/related` can use rich encoding for the meta data (currently JSON).   multipart/related (RFC-2387) ----------------------------  This is the most advanced and efficient way to create a paste.      POST /2.0/snippets/evzijst HTTP/1.1     Content-Length: 1188     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"title\": \"My snippet\",       \"is_private\": true,       \"scm\": \"git\",       \"files\": {           \"foo.txt\": {},           \"image.png\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      foo      --===============1438169132528273974==     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \"image.png\"     Content-Disposition: attachment; filename=\"image.png\"      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     --===============1438169132528273974==--  The request contains multiple parts and is structured as follows.  The first part is the JSON document that describes the snippet\'s properties or meta data. It either has to be the first part, or the request\'s `Content-Type` header must contain the `start` parameter to point to it.  The remaining parts are the files of which there can be zero or more. Each file part should contain the `Content-ID` MIME header through which the JSON meta data\'s `files` element addresses it. The value should be the name of the file.  `Content-Disposition` is an optional MIME header. The header\'s optional `filename` parameter can be used to specify the file name that Bitbucket should use when writing the file to disk. When present, `filename` takes precedence over the value of `Content-ID`.  When the JSON body omits the `files` element, the remaining parts are not ignored. Instead, each file is added to the new snippet as if its name was explicitly linked (the use of the `files` elements is mandatory for some operations like deleting or renaming files).   multipart/form-data -------------------  The use of JSON for the snippet\'s meta data is optional. Meta data can also be supplied as regular form fields in a more conventional `multipart/form-data` request:      $ curl -X POST -u credentials https://api.bitbucket.org/2.0/snippets               -F title=\"My snippet\"               -F file=@foo.txt -F file=@image.png      POST /2.0/snippets HTTP/1.1     Content-Length: 951     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"image.png\"     Content-Type: application/octet-stream      ?PNG      IHDR?1??I.....     ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"      My snippet     ------------------------------63a4b224c59f--  Here the meta data properties are included as flat, top-level form fields. The file attachments use the `file` field name. To attach multiple files, simply repeat the field.  The advantage of `multipart/form-data` over `multipart/related` is that it can be easier to build clients.  Essentially all properties are optional, `title` and `files` included.   Sharing and Visibility ----------------------  Snippets can be either public (visible to anyone on Bitbucket, as well as anonymous users), or private (visible only to members of the workspace). This is controlled through the snippet\'s `is_private` element:  * **is_private=false** -- everyone, including anonymous users can view   the snippet * **is_private=true** -- only workspace members can view the snippet  To create the snippet under a workspace, just append the workspace ID to the URL. See [`/2.0/snippets/{workspace}`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-workspace-post).
     * @summary Create a snippet
     * @param {SnippetsApiSnippetsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsPost(requestParameters: SnippetsApiSnippetsPostRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsPost(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a snippet comment.  Comments can only be removed by the comment author, snippet creator, or workspace admin.
     * @summary Delete a comment on a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdCommentsCommentIdDelete(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdCommentsCommentIdDelete(requestParameters.commentId, requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specific snippet comment.
     * @summary Get a comment on a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdCommentsCommentIdGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdGetRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdCommentsCommentIdGet(requestParameters.commentId, requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a comment.  The only required field in the body is `content.raw`.  Comments can only be updated by their author.
     * @summary Update a comment on a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdCommentsCommentIdPut(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsCommentIdPutRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdCommentsCommentIdPut(requestParameters.commentId, requestParameters.encodedId, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to retrieve a paginated list of all comments for a specific snippet.  This resource works identical to commit and pull request comments.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.
     * @summary List comments on a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdCommentsGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsGetRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdCommentsGet(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new comment.  The only required field in the body is `content.raw`.  To create a threaded reply to an existing comment, include `parent.id`.
     * @summary Create a comment on a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdCommentsPost(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommentsPostRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdCommentsPost(requestParameters.encodedId, requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the changes (commits) made on this snippet.
     * @summary List snippet changes
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommitsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdCommitsGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommitsGetRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdCommitsGet(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the changes made on this snippet in this commit.
     * @summary Get a previous snippet change
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdCommitsRevisionGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdCommitsRevisionGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdCommitsRevisionGetRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdCommitsRevisionGet(requestParameters.encodedId, requestParameters.revision, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a snippet and returns an empty response.
     * @summary Delete a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdDelete(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdDelete(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Convenience resource for getting to a snippet\'s raw files without the need for first having to retrieve the snippet itself and having to pull out the versioned file links.
     * @summary Get a snippet\'s raw file at HEAD
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdFilesPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdFilesPathGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdFilesPathGetRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdFilesPathGet(requestParameters.encodedId, requestParameters.path, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single snippet.  Snippets support multiple content types:  * application/json * multipart/related * multipart/form-data   application/json ----------------  The default content type of the response is `application/json`. Since JSON is always `utf-8`, it cannot reliably contain file contents for files that are not text. Therefore, JSON snippet documents only contain the filename and links to the file contents.  This means that in order to retrieve all parts of a snippet, N+1 requests need to be made (where N is the number of files in the snippet).   multipart/related -----------------  To retrieve an entire snippet in a single response, use the `Accept: multipart/related` HTTP request header.      $ curl -H \"Accept: multipart/related\" https://api.bitbucket.org/2.0/snippets/evzijst/1  Response:      HTTP/1.1 200 OK     Content-Length: 2214     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj\"         },         \"html\": {           \"href\": \"https://bitbucket.org/snippets/evzijst/kypj\"         },         \"comments\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/comments\"         },         \"watchers\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/watchers\"         },         \"commits\": {           \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/commits\"         }       },       \"id\": kypj,       \"title\": \"My snippet\",       \"created_on\": \"2014-12-29T22:22:04.790331+00:00\",       \"updated_on\": \"2014-12-29T22:22:04.790331+00:00\",       \"is_private\": false,       \"files\": {         \"foo.txt\": {           \"links\": {             \"self\": {               \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/foo.txt\"             },             \"html\": {               \"href\": \"https://bitbucket.org/snippets/evzijst/kypj#file-foo.txt\"             }           }         },         \"image.png\": {           \"links\": {             \"self\": {               \"href\": \"https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/image.png\"             },             \"html\": {               \"href\": \"https://bitbucket.org/snippets/evzijst/kypj#file-image.png\"             }           }         }       ],       \"owner\": {         \"username\": \"evzijst\",         \"nickname\": \"evzijst\",         \"display_name\": \"Erik van Zijst\",         \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"           },           \"html\": {             \"href\": \"https://bitbucket.org/evzijst\"           },           \"avatar\": {             \"href\": \"https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\"           }         }       },       \"creator\": {         \"username\": \"evzijst\",         \"nickname\": \"evzijst\",         \"display_name\": \"Erik van Zijst\",         \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"           },           \"html\": {             \"href\": \"https://bitbucket.org/evzijst\"           },           \"avatar\": {             \"href\": \"https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\"           }         }       }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      foo      --===============1438169132528273974==     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \"image.png\"     Content-Disposition: attachment; filename=\"image.png\"      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     --===============1438169132528273974==--  multipart/form-data -------------------  As with creating new snippets, `multipart/form-data` can be used as an alternative to `multipart/related`. However, the inherently flat structure of form-data means that only basic, root-level properties can be returned, while nested elements like `links` are omitted:      $ curl -H \"Accept: multipart/form-data\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj  Response:      HTTP/1.1 200 OK     Content-Length: 951     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"     Content-Type: text/plain; charset=\"utf-8\"      My snippet     ------------------------------63a4b224c59f--     Content-Disposition: attachment; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: attachment; name=\"file\"; filename=\"image.png\"     Content-Transfer-Encoding: base64     Content-Type: application/octet-stream      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==     ------------------------------5957323a6b76--
     * @summary Get a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdGetRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdGet(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the snippet.  Note that this only works for versioned URLs that point to the latest commit of the snippet. Pointing to an older commit results in a 405 status code.  To delete a snippet, regardless of whether or not concurrent changes are being made to it, use `DELETE /snippets/{encoded_id}` instead.
     * @summary Delete a previous revision of a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdNodeIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdNodeIdDelete(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdNodeIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdNodeIdDelete(requestParameters.encodedId, requestParameters.nodeId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the raw contents of a specific file in the snippet. The `Content-Disposition` header will be \"attachment\" to avoid issues with malevolent executable files.  The file\'s mime type is derived from its filename and returned in the `Content-Type` header.  Note that for text files, no character encoding is included as part of the content type.
     * @summary Get a snippet\'s raw file
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdNodeIdFilesPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdNodeIdFilesPathGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdNodeIdFilesPathGetRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdNodeIdFilesPathGet(requestParameters.encodedId, requestParameters.nodeId, requestParameters.path, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Identical to `GET /snippets/encoded_id`, except that this endpoint can be used to retrieve the contents of the snippet as it was at an older revision, while `/snippets/encoded_id` always returns the snippet\'s current revision.  Note that only the snippet\'s file contents are versioned, not its meta data properties like the title.  Other than that, the two endpoints are identical in behavior.
     * @summary Get a previous revision of a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdNodeIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdNodeIdGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdNodeIdGetRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdNodeIdGet(requestParameters.encodedId, requestParameters.nodeId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Identical to `UPDATE /snippets/encoded_id`, except that this endpoint takes an explicit commit revision. Only the snippet\'s \"HEAD\"/\"tip\" (most recent) version can be updated and requests on all other, older revisions fail by returning a 405 status.  Usage of this endpoint over the unrestricted `/snippets/encoded_id` could be desired if the caller wants to be sure no concurrent modifications have taken place between the moment of the UPDATE request and the original GET.  This can be considered a so-called \"Compare And Swap\", or CAS operation.  Other than that, the two endpoints are identical in behavior.
     * @summary Update a previous revision of a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdNodeIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdNodeIdPut(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdNodeIdPutRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdNodeIdPut(requestParameters.encodedId, requestParameters.nodeId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to update a snippet. Use this to add and delete files and to change a snippet\'s title.  To update a snippet, one can either PUT a full snapshot, or only the parts that need to be changed.  The contract for PUT on this API is that properties missing from the request remain untouched so that snippets can be efficiently manipulated with differential payloads.  To delete a property (e.g. the title, or a file), include its name in the request, but omit its value (use `null`).  As in Git, explicit renaming of files is not supported. Instead, to rename a file, delete it and add it again under another name. This can be done atomically in a single request. Rename detection is left to the SCM.  PUT supports three different content types for both request and response bodies:  * `application/json` * `multipart/related` * `multipart/form-data`  The content type used for the request body can be different than that used for the response. Content types are specified using standard HTTP headers.  Use the `Content-Type` and `Accept` headers to select the desired request and response format.   application/json ----------------  As with creation and retrieval, the content type determines what properties can be manipulated. `application/json` does not support file contents and is therefore limited to a snippet\'s meta data.  To update the title, without changing any of its files:      $ curl -X POST -H \"Content-Type: application/json\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d \'{\"title\": \"Updated title\"}\'   To delete the title:      $ curl -X POST -H \"Content-Type: application/json\" https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d \'{\"title\": null}\'  Not all parts of a snippet can be manipulated. The owner and creator for instance are immutable.   multipart/related -----------------  `multipart/related` can be used to manipulate all of a snippet\'s properties. The body is identical to a POST. properties omitted from the request are left unchanged. Since the `start` part contains JSON, the mechanism for manipulating the snippet\'s meta data is identical to `application/json` requests.  To update one of a snippet\'s file contents, while also changing its title:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 288     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"title\": \"My updated snippet\",       \"files\": {           \"foo.txt\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"foo.txt\"     Content-Disposition: attachment; filename=\"foo.txt\"      Updated file contents.      --===============1438169132528273974==--  Here only the parts that are changed are included in the body. The other files remain untouched.  Note the use of the `files` list in the JSON part. This list contains the files that are being manipulated. This list should have corresponding multiparts in the request that contain the new contents of these files.  If a filename in the `files` list does not have a corresponding part, it will be deleted from the snippet, as shown below:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 188     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {       \"files\": {         \"image.png\": {}       }     }      --===============1438169132528273974==--  To simulate a rename, delete a file and add the same file under another name:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 212     Content-Type: multipart/related; start=\"snippet\"; boundary=\"===============1438169132528273974==\"     MIME-Version: 1.0      --===============1438169132528273974==     Content-Type: application/json; charset=\"utf-8\"     MIME-Version: 1.0     Content-ID: snippet      {         \"files\": {           \"foo.txt\": {},           \"bar.txt\": {}         }     }      --===============1438169132528273974==     Content-Type: text/plain; charset=\"us-ascii\"     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \"bar.txt\"     Content-Disposition: attachment; filename=\"bar.txt\"      foo      --===============1438169132528273974==--   multipart/form-data -----------------  Again, one can also use `multipart/form-data` to manipulate file contents and meta data atomically.      $ curl -X PUT http://localhost:12345/2.0/snippets/evzijst/kypj             -F title=\"My updated snippet\" -F file=@foo.txt      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 351     Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"file\"; filename=\"foo.txt\"     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name=\"title\"      My updated snippet     ------------------------------63a4b224c59f  To delete a file, omit its contents while including its name in the `files` field:      $ curl -X PUT https://api.bitbucket.org/2.0/snippets/evzijst/kypj -F files=image.png      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 149     Content-Type: multipart/form-data; boundary=----------------------------ef8871065a86      ------------------------------ef8871065a86     Content-Disposition: form-data; name=\"files\"      image.png     ------------------------------ef8871065a86--  The explicit use of the `files` element in `multipart/related` and `multipart/form-data` is only required when deleting files. The default mode of operation is for file parts to be processed, regardless of whether or not they are listed in `files`, as a convenience to the client.
     * @summary Update a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdPut(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdPutRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdPut(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the diff of the specified commit against its first parent.  Note that this resource is different in functionality from the `patch` resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional `path=foo/bar.py` query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent\'s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the diff is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
     * @summary Get snippet changes between versions
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdRevisionDiffGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdRevisionDiffGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdRevisionDiffGetRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdRevisionDiffGet(requestParameters.encodedId, requestParameters.revision, requestParameters.workspace, requestParameters.path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the patch of the specified commit against its first parent.  Note that this resource is different in functionality from the `diff` resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional `path=foo/bar.py` query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent\'s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the patch is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
     * @summary Get snippet patch between versions
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdRevisionPatchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdRevisionPatchGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdRevisionPatchGetRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdRevisionPatchGet(requestParameters.encodedId, requestParameters.revision, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to stop watching a specific snippet. Returns 204 (No Content) to indicate success.
     * @summary Stop watching a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdWatchDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdWatchDelete(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdWatchDeleteRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdWatchDelete(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to check if the current user is watching a specific snippet.  Returns 204 (No Content) if the user is watching the snippet and 404 if not.  Hitting this endpoint anonymously always returns a 404.
     * @summary Check if the current user is watching a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdWatchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdWatchGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdWatchGetRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdWatchGet(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to start watching a specific snippet. Returns 204 (No Content).
     * @summary Watch a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdWatchPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdWatchPut(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdWatchPutRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdWatchPut(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all users watching a specific snippet.
     * @summary List users watching a snippet
     * @param {SnippetsApiSnippetsWorkspaceEncodedIdWatchersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public snippetsWorkspaceEncodedIdWatchersGet(requestParameters: SnippetsApiSnippetsWorkspaceEncodedIdWatchersGetRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceEncodedIdWatchersGet(requestParameters.encodedId, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Identical to [`/snippets`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-get), except that the result is further filtered by the snippet owner and only those that are owned by `{workspace}` are returned.
     * @summary List snippets in a workspace
     * @param {SnippetsApiSnippetsWorkspaceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspaceGet(requestParameters: SnippetsApiSnippetsWorkspaceGetRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspaceGet(requestParameters.workspace, requestParameters.role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Identical to [`/snippets`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-post), except that the new snippet will be created under the workspace specified in the path parameter `{workspace}`.
     * @summary Create a snippet for a workspace
     * @param {SnippetsApiSnippetsWorkspacePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snippetsWorkspacePost(requestParameters: SnippetsApiSnippetsWorkspacePostRequest, options?: RawAxiosRequestConfig) {
        return SnippetsApiFp(this.configuration).snippetsWorkspacePost(requestParameters.workspace, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}

export const SnippetsGetRoleEnum = {
    Owner: 'owner',
    Contributor: 'contributor',
    Member: 'member'
} as const;
export type SnippetsGetRoleEnum = typeof SnippetsGetRoleEnum[keyof typeof SnippetsGetRoleEnum];
export const SnippetsWorkspaceGetRoleEnum = {
    Owner: 'owner',
    Contributor: 'contributor',
    Member: 'member'
} as const;
export type SnippetsWorkspaceGetRoleEnum = typeof SnippetsWorkspaceGetRoleEnum[keyof typeof SnippetsWorkspaceGetRoleEnum];


/**
 * SourceApi - axios parameter creator
 */
export const SourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order <sha> <path>  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the `?renames=false` query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to only provide exactly the data you want.  The example response returns commits made before 2011-05-18 against a file named `README.rst`. The results are filtered to only return the path and date. This request can be made using:  ``` $ curl \'https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst\'\\   \'?fields=values.next,values.path,values.commit.date&q=commit.date<=2011-05-18\' ```  In the response you can see that the file was renamed to `README.rst` by the commit made on 2011-05-16, and was previously named `README.txt`.
         * @summary List commits that modified a file
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} path Path to the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [renames]  When &#x60;true&#x60;, Bitbucket will follow the history of the file across renames (this is the default behavior). This can be turned off by specifying &#x60;false&#x60;.
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet: async (commit: string, path: string, repoSlug: string, workspace: string, renames?: string, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet', 'commit', commit)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet', 'path', path)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/filehistory/{commit}/{path}`
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (renames !== undefined) {
                localVarQueryParameter['renames'] = renames;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  #### Raw file contents  When `path` points to a file, this endpoint returns the raw contents. The response\'s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The `Content-Disposition` header will be \"attachment\" to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian\'s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty `__init__.py` always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  #### File meta data  When the request for a file path includes the query parameter `?format=meta`, instead of returning the file\'s raw contents, Bitbucket instead returns the JSON object describing the file\'s properties:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format=meta {   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"     }   },   \"path\": \"tests/__init__.py\",   \"commit\": {     \"type\": \"commit\",     \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"       },       \"html\": {         \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"       }     }   },   \"attributes\": [],   \"type\": \"commit_file\",   \"size\": 0 } ```  File objects contain an `attributes` element that contains a list of possible modifiers. Currently defined values are:  * `link` -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * `executable` -- indicates that the file has the executable bit set. * `subrepository` -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * `binary` -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file\'s size without incurring the overhead of receiving its full contents.   #### Directory listings  When `path` points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \"pagelen\": 10,   \"values\": [     {       \"path\": \"tests/test_project\",       \"type\": \"commit_directory\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"         }       },       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       }     },     {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"         }       },       \"path\": \"tests/__init__.py\",       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       },       \"attributes\": [],       \"type\": \"commit_file\",       \"size\": 0     }   ],   \"page\": 1,   \"size\": 2 } ```  When listing the contents of the repo\'s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \"walk\" the entire directory tree, the client can either parse each response and follow the `self` links of each `commit_directory` object, or can specify a `max_depth` to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the `max_depth` parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a `commit_file`, or a `commit_directory`, both of which contain a `path` element. This path is the absolute path from the root of the repository. Each object also contains a `commit` object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their `self` link returns the paginated contents of the directory. The `meta` link on the other hand returns the actual `directory` object itself, e.g.:  ```javascript {   \"path\": \"tests/test_project\",   \"type\": \"commit_directory\",   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"     }   },   \"commit\": { ... } } ```  #### Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  `size > 1024 and attributes = \"binary\"`  which after urlencoding yields the query string:  `?q=size%3E1024+and+attributes%3D%22binary%22`  To change the ordering of the response, use the `?sort` parameter:  `.../src/eefd5ef/?sort=-size`  See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary Get file or directory contents
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} path Path to the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {RepositoriesWorkspaceRepoSlugSrcCommitPathGetFormatEnum} [format] If \&#39;meta\&#39; is provided, returns the (json) meta data for the contents of the file.  If \&#39;rendered\&#39; is provided, returns the contents of a non-binary file in HTML-formatted rendered markup. The \&#39;rendered\&#39; option only supports these filetypes: &#x60;.md&#x60;, &#x60;.markdown&#x60;, &#x60;.mkd&#x60;, &#x60;.mkdn&#x60;, &#x60;.mdown&#x60;, &#x60;.text&#x60;, &#x60;.rst&#x60;, and &#x60;.textile&#x60;. Since Git does not generally track what text encoding scheme is used, this endpoint attempts to detect the most appropriate character encoding. While usually correct, determining the character encoding can be ambiguous which in exceptional cases can lead to misinterpretation of the characters. As such, the raw element in the response object should not be treated as equivalent to the file\&#39;s actual contents.
         * @param {string} [q] Optional filter expression as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort] Optional sorting parameter as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results).
         * @param {number} [maxDepth] If provided, returns the contents of the repository and its subdirectories recursively until the specified max_depth of nested directories. When omitted, this defaults to 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugSrcCommitPathGet: async (commit: string, path: string, repoSlug: string, workspace: string, format?: RepositoriesWorkspaceRepoSlugSrcCommitPathGetFormatEnum, q?: string, sort?: string, maxDepth?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commit' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcCommitPathGet', 'commit', commit)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcCommitPathGet', 'path', path)
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcCommitPathGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcCommitPathGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/src/{commit}/{path}`
                .replace(`{${"commit"}}`, encodeURIComponent(String(commit)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (maxDepth !== undefined) {
                localVarQueryParameter['max_depth'] = maxDepth;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo\'s main branch.  To create new commits, [POST to this endpoint](#post)
         * @summary Get the root directory of the main branch
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {RepositoriesWorkspaceRepoSlugSrcGetFormatEnum} [format] Instead of returning the file\&#39;s contents, return the (json) meta data for it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugSrcGet: async (repoSlug: string, workspace: string, format?: RepositoriesWorkspaceRepoSlugSrcGetFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/src`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png=@image.png ```  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the `image.png` file to the repository in the `/repo/path/to` directory.  To create a commit that deletes files, use the `files` parameter:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files=/file/to/delete/1.txt \\   -F files=/file/to/delete/2.txt ```  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts `multipart/form-data` (as in the examples above), as well as `application/x-www-form-urlencoded`.  Note: `multipart/form-data` is currently not supported by Forge apps for this API.  #### multipart/form-data  A `multipart/form-data` post contains a series of \"form fields\" that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a `Content-Disposition` parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above `curl` example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For `multipart/form-data` bodies that should not lead to any ambiguity, as the `Content-Disposition` header will contain the `filename` parameter to distinguish between a file named \"message\" and the commit message field.  #### application/x-www-form-urlencoded  It is also possible to upload new files using a simple `application/x-www-form-urlencoded` POST. This can be convenient when uploading pure text files:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \"/path/to/me.txt=Lorem ipsum.\" \\   --data-urlencode \"message=Initial commit\" \\   --data-urlencode \"author=Erik van Zijst <erik.van.zijst@gmail.com>\" ```  There could be a field name clash if a client were to upload a file named \"message\", as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. `curl --data-urlencode \"/message=file contents\"`.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  #### Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a `x-attributes` value in the `Content-Disposition` header. For example, to upload an executable file, as well as create a symlink from `README.txt` to `README`:  ``` --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"bin/shutdown.sh\" Content-Disposition: attachment; filename=\"shutdown.sh\"; x-attributes:\"executable\"  #!/bin/sh halt  --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"/README.txt\" Content-Disposition: attachment; filename=\"README.txt\"; x-attributes:\"link\"  README --===============1438169132528273974==-- ```  Links are files that contain the target path and have `x-attributes:\"link\"` set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying `x-attributes=\"link\"` will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include `x-attributes=\"executable\"` in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.
         * @summary Create a commit by uploading a file
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [message] The commit message. When omitted, Bitbucket uses a canned string.
         * @param {string} [author]  The raw string to be used as the new commit\&#39;s author. This string follows the format &#x60;Erik van Zijst &lt;evzijst@atlassian.com&gt;&#x60;.  When omitted, Bitbucket uses the authenticated user\&#39;s full/display name and primary email address. Commits cannot be created anonymously.
         * @param {string} [parents]  #### Deprecation Notice: Support for specifying multiple parent commits is deprecated and will be removed in a future release. Only a single SHA1 is accepted.  A SHA1 of the commit that should be the parent of the newly created commit. When omitted, the new commit will inherit from and become a child of the main branch\&#39;s tip/HEAD commit.
         * @param {string} [files]  Optional field that declares the files that the request is manipulating. When adding a new file to a repo, or when overwriting an existing file, the client can just upload the full contents of the file in a normal form field and the use of this &#x60;files&#x60; meta data field is redundant. However, when the &#x60;files&#x60; field contains a file path that does not have a corresponding, identically-named form field, then Bitbucket interprets that as the client wanting to replace the named file with the null set and the file is deleted instead.  Paths in the repo that are referenced in neither files nor an individual file field, remain unchanged and carry over from the parent to the new commit.  This API does not support renaming as an explicit feature. To rename a file, simply delete it and recreate it under the new name in the same commit. 
         * @param {string} [branch]  The name of the branch that the new commit should be created on. When omitted, the commit will be created on top of the main branch and will become the main branch\&#39;s new head.  When a branch name is provided that already exists in the repo, then the commit will be created on top of that branch. In this case, *if* a parent SHA1 was also provided, then it is asserted that the parent is the branch\&#39;s tip/HEAD at the time the request is made. When this is not the case, a 409 is returned.  When a new branch name is specified (that does not already exist in the repo), and no parent SHA1s are provided, then the new commit will inherit from the current main branch\&#39;s tip/HEAD commit, but not advance the main branch. The new commit will be the new branch. When the request *also* specifies a parent SHA1, then the new commit and branch are created directly on top of the parent commit, regardless of the state of the main branch.  When a branch name is not specified, but a parent SHA1 is provided, then Bitbucket asserts that it represents the main branch\&#39;s current HEAD/tip, or a 409 is returned.  When a branch name is not specified and the repo is empty, the new commit will become the repo\&#39;s root commit and will be on the main branch.  When a branch name is specified and the repo is empty, the new commit will become the repo\&#39;s root commit and also define the repo\&#39;s main branch going forward.  This API cannot be used to create additional root commits in non-empty repos.  The branch field cannot be repeated.  As a side effect, this API can be used to create a new branch without modifying any files, by specifying a new branch name in this field, together with &#x60;parents&#x60;, but omitting the &#x60;files&#x60; fields, while not sending any files. This will create a new commit and branch with the same contents as the first parent. The diff of this commit against its first parent will be empty. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugSrcPost: async (repoSlug: string, workspace: string, message?: string, author?: string, parents?: string, files?: string, branch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugSrcPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/src`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository:write"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (parents !== undefined) {
                localVarQueryParameter['parents'] = parents;
            }

            if (files !== undefined) {
                localVarQueryParameter['files'] = files;
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourceApi - functional programming interface
 */
export const SourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order <sha> <path>  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the `?renames=false` query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to only provide exactly the data you want.  The example response returns commits made before 2011-05-18 against a file named `README.rst`. The results are filtered to only return the path and date. This request can be made using:  ``` $ curl \'https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst\'\\   \'?fields=values.next,values.path,values.commit.date&q=commit.date<=2011-05-18\' ```  In the response you can see that the file was renamed to `README.rst` by the commit made on 2011-05-16, and was previously named `README.txt`.
         * @summary List commits that modified a file
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} path Path to the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [renames]  When &#x60;true&#x60;, Bitbucket will follow the history of the file across renames (this is the default behavior). This can be turned off by specifying &#x60;false&#x60;.
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet(commit: string, path: string, repoSlug: string, workspace: string, renames?: string, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFiles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet(commit, path, repoSlug, workspace, renames, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceApi.repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  #### Raw file contents  When `path` points to a file, this endpoint returns the raw contents. The response\'s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The `Content-Disposition` header will be \"attachment\" to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian\'s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty `__init__.py` always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  #### File meta data  When the request for a file path includes the query parameter `?format=meta`, instead of returning the file\'s raw contents, Bitbucket instead returns the JSON object describing the file\'s properties:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format=meta {   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"     }   },   \"path\": \"tests/__init__.py\",   \"commit\": {     \"type\": \"commit\",     \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"       },       \"html\": {         \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"       }     }   },   \"attributes\": [],   \"type\": \"commit_file\",   \"size\": 0 } ```  File objects contain an `attributes` element that contains a list of possible modifiers. Currently defined values are:  * `link` -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * `executable` -- indicates that the file has the executable bit set. * `subrepository` -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * `binary` -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file\'s size without incurring the overhead of receiving its full contents.   #### Directory listings  When `path` points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \"pagelen\": 10,   \"values\": [     {       \"path\": \"tests/test_project\",       \"type\": \"commit_directory\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"         }       },       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       }     },     {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"         }       },       \"path\": \"tests/__init__.py\",       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       },       \"attributes\": [],       \"type\": \"commit_file\",       \"size\": 0     }   ],   \"page\": 1,   \"size\": 2 } ```  When listing the contents of the repo\'s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \"walk\" the entire directory tree, the client can either parse each response and follow the `self` links of each `commit_directory` object, or can specify a `max_depth` to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the `max_depth` parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a `commit_file`, or a `commit_directory`, both of which contain a `path` element. This path is the absolute path from the root of the repository. Each object also contains a `commit` object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their `self` link returns the paginated contents of the directory. The `meta` link on the other hand returns the actual `directory` object itself, e.g.:  ```javascript {   \"path\": \"tests/test_project\",   \"type\": \"commit_directory\",   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"     }   },   \"commit\": { ... } } ```  #### Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  `size > 1024 and attributes = \"binary\"`  which after urlencoding yields the query string:  `?q=size%3E1024+and+attributes%3D%22binary%22`  To change the ordering of the response, use the `?sort` parameter:  `.../src/eefd5ef/?sort=-size`  See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary Get file or directory contents
         * @param {string} commit The commit\&#39;s SHA1.
         * @param {string} path Path to the file.
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {RepositoriesWorkspaceRepoSlugSrcCommitPathGetFormatEnum} [format] If \&#39;meta\&#39; is provided, returns the (json) meta data for the contents of the file.  If \&#39;rendered\&#39; is provided, returns the contents of a non-binary file in HTML-formatted rendered markup. The \&#39;rendered\&#39; option only supports these filetypes: &#x60;.md&#x60;, &#x60;.markdown&#x60;, &#x60;.mkd&#x60;, &#x60;.mkdn&#x60;, &#x60;.mdown&#x60;, &#x60;.text&#x60;, &#x60;.rst&#x60;, and &#x60;.textile&#x60;. Since Git does not generally track what text encoding scheme is used, this endpoint attempts to detect the most appropriate character encoding. While usually correct, determining the character encoding can be ambiguous which in exceptional cases can lead to misinterpretation of the characters. As such, the raw element in the response object should not be treated as equivalent to the file\&#39;s actual contents.
         * @param {string} [q] Optional filter expression as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort] Optional sorting parameter as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results).
         * @param {number} [maxDepth] If provided, returns the contents of the repository and its subdirectories recursively until the specified max_depth of nested directories. When omitted, this defaults to 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugSrcCommitPathGet(commit: string, path: string, repoSlug: string, workspace: string, format?: RepositoriesWorkspaceRepoSlugSrcCommitPathGetFormatEnum, q?: string, sort?: string, maxDepth?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTreeentries>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugSrcCommitPathGet(commit, path, repoSlug, workspace, format, q, sort, maxDepth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceApi.repositoriesWorkspaceRepoSlugSrcCommitPathGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo\'s main branch.  To create new commits, [POST to this endpoint](#post)
         * @summary Get the root directory of the main branch
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {RepositoriesWorkspaceRepoSlugSrcGetFormatEnum} [format] Instead of returning the file\&#39;s contents, return the (json) meta data for it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugSrcGet(repoSlug: string, workspace: string, format?: RepositoriesWorkspaceRepoSlugSrcGetFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTreeentries>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugSrcGet(repoSlug, workspace, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceApi.repositoriesWorkspaceRepoSlugSrcGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png=@image.png ```  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the `image.png` file to the repository in the `/repo/path/to` directory.  To create a commit that deletes files, use the `files` parameter:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files=/file/to/delete/1.txt \\   -F files=/file/to/delete/2.txt ```  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts `multipart/form-data` (as in the examples above), as well as `application/x-www-form-urlencoded`.  Note: `multipart/form-data` is currently not supported by Forge apps for this API.  #### multipart/form-data  A `multipart/form-data` post contains a series of \"form fields\" that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a `Content-Disposition` parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above `curl` example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For `multipart/form-data` bodies that should not lead to any ambiguity, as the `Content-Disposition` header will contain the `filename` parameter to distinguish between a file named \"message\" and the commit message field.  #### application/x-www-form-urlencoded  It is also possible to upload new files using a simple `application/x-www-form-urlencoded` POST. This can be convenient when uploading pure text files:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \"/path/to/me.txt=Lorem ipsum.\" \\   --data-urlencode \"message=Initial commit\" \\   --data-urlencode \"author=Erik van Zijst <erik.van.zijst@gmail.com>\" ```  There could be a field name clash if a client were to upload a file named \"message\", as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. `curl --data-urlencode \"/message=file contents\"`.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  #### Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a `x-attributes` value in the `Content-Disposition` header. For example, to upload an executable file, as well as create a symlink from `README.txt` to `README`:  ``` --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"bin/shutdown.sh\" Content-Disposition: attachment; filename=\"shutdown.sh\"; x-attributes:\"executable\"  #!/bin/sh halt  --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"/README.txt\" Content-Disposition: attachment; filename=\"README.txt\"; x-attributes:\"link\"  README --===============1438169132528273974==-- ```  Links are files that contain the target path and have `x-attributes:\"link\"` set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying `x-attributes=\"link\"` will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include `x-attributes=\"executable\"` in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.
         * @summary Create a commit by uploading a file
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [message] The commit message. When omitted, Bitbucket uses a canned string.
         * @param {string} [author]  The raw string to be used as the new commit\&#39;s author. This string follows the format &#x60;Erik van Zijst &lt;evzijst@atlassian.com&gt;&#x60;.  When omitted, Bitbucket uses the authenticated user\&#39;s full/display name and primary email address. Commits cannot be created anonymously.
         * @param {string} [parents]  #### Deprecation Notice: Support for specifying multiple parent commits is deprecated and will be removed in a future release. Only a single SHA1 is accepted.  A SHA1 of the commit that should be the parent of the newly created commit. When omitted, the new commit will inherit from and become a child of the main branch\&#39;s tip/HEAD commit.
         * @param {string} [files]  Optional field that declares the files that the request is manipulating. When adding a new file to a repo, or when overwriting an existing file, the client can just upload the full contents of the file in a normal form field and the use of this &#x60;files&#x60; meta data field is redundant. However, when the &#x60;files&#x60; field contains a file path that does not have a corresponding, identically-named form field, then Bitbucket interprets that as the client wanting to replace the named file with the null set and the file is deleted instead.  Paths in the repo that are referenced in neither files nor an individual file field, remain unchanged and carry over from the parent to the new commit.  This API does not support renaming as an explicit feature. To rename a file, simply delete it and recreate it under the new name in the same commit. 
         * @param {string} [branch]  The name of the branch that the new commit should be created on. When omitted, the commit will be created on top of the main branch and will become the main branch\&#39;s new head.  When a branch name is provided that already exists in the repo, then the commit will be created on top of that branch. In this case, *if* a parent SHA1 was also provided, then it is asserted that the parent is the branch\&#39;s tip/HEAD at the time the request is made. When this is not the case, a 409 is returned.  When a new branch name is specified (that does not already exist in the repo), and no parent SHA1s are provided, then the new commit will inherit from the current main branch\&#39;s tip/HEAD commit, but not advance the main branch. The new commit will be the new branch. When the request *also* specifies a parent SHA1, then the new commit and branch are created directly on top of the parent commit, regardless of the state of the main branch.  When a branch name is not specified, but a parent SHA1 is provided, then Bitbucket asserts that it represents the main branch\&#39;s current HEAD/tip, or a 409 is returned.  When a branch name is not specified and the repo is empty, the new commit will become the repo\&#39;s root commit and will be on the main branch.  When a branch name is specified and the repo is empty, the new commit will become the repo\&#39;s root commit and also define the repo\&#39;s main branch going forward.  This API cannot be used to create additional root commits in non-empty repos.  The branch field cannot be repeated.  As a side effect, this API can be used to create a new branch without modifying any files, by specifying a new branch name in this field, together with &#x60;parents&#x60;, but omitting the &#x60;files&#x60; fields, while not sending any files. This will create a new commit and branch with the same contents as the first parent. The diff of this commit against its first parent will be empty. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugSrcPost(repoSlug: string, workspace: string, message?: string, author?: string, parents?: string, files?: string, branch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugSrcPost(repoSlug, workspace, message, author, parents, files, branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceApi.repositoriesWorkspaceRepoSlugSrcPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SourceApi - factory interface
 */
export const SourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourceApiFp(configuration)
    return {
        /**
         * Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order <sha> <path>  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the `?renames=false` query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to only provide exactly the data you want.  The example response returns commits made before 2011-05-18 against a file named `README.rst`. The results are filtered to only return the path and date. This request can be made using:  ``` $ curl \'https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst\'\\   \'?fields=values.next,values.path,values.commit.date&q=commit.date<=2011-05-18\' ```  In the response you can see that the file was renamed to `README.rst` by the commit made on 2011-05-16, and was previously named `README.txt`.
         * @summary List commits that modified a file
         * @param {SourceApiRepositoriesWorkspaceRepoSlugFilehistoryCommitPathGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet(requestParameters: SourceApiRepositoriesWorkspaceRepoSlugFilehistoryCommitPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedFiles> {
            return localVarFp.repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet(requestParameters.commit, requestParameters.path, requestParameters.repoSlug, requestParameters.workspace, requestParameters.renames, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  #### Raw file contents  When `path` points to a file, this endpoint returns the raw contents. The response\'s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The `Content-Disposition` header will be \"attachment\" to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian\'s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty `__init__.py` always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  #### File meta data  When the request for a file path includes the query parameter `?format=meta`, instead of returning the file\'s raw contents, Bitbucket instead returns the JSON object describing the file\'s properties:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format=meta {   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"     }   },   \"path\": \"tests/__init__.py\",   \"commit\": {     \"type\": \"commit\",     \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"       },       \"html\": {         \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"       }     }   },   \"attributes\": [],   \"type\": \"commit_file\",   \"size\": 0 } ```  File objects contain an `attributes` element that contains a list of possible modifiers. Currently defined values are:  * `link` -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * `executable` -- indicates that the file has the executable bit set. * `subrepository` -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * `binary` -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file\'s size without incurring the overhead of receiving its full contents.   #### Directory listings  When `path` points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \"pagelen\": 10,   \"values\": [     {       \"path\": \"tests/test_project\",       \"type\": \"commit_directory\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"         }       },       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       }     },     {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"         }       },       \"path\": \"tests/__init__.py\",       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       },       \"attributes\": [],       \"type\": \"commit_file\",       \"size\": 0     }   ],   \"page\": 1,   \"size\": 2 } ```  When listing the contents of the repo\'s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \"walk\" the entire directory tree, the client can either parse each response and follow the `self` links of each `commit_directory` object, or can specify a `max_depth` to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the `max_depth` parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a `commit_file`, or a `commit_directory`, both of which contain a `path` element. This path is the absolute path from the root of the repository. Each object also contains a `commit` object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their `self` link returns the paginated contents of the directory. The `meta` link on the other hand returns the actual `directory` object itself, e.g.:  ```javascript {   \"path\": \"tests/test_project\",   \"type\": \"commit_directory\",   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"     }   },   \"commit\": { ... } } ```  #### Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  `size > 1024 and attributes = \"binary\"`  which after urlencoding yields the query string:  `?q=size%3E1024+and+attributes%3D%22binary%22`  To change the ordering of the response, use the `?sort` parameter:  `.../src/eefd5ef/?sort=-size`  See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary Get file or directory contents
         * @param {SourceApiRepositoriesWorkspaceRepoSlugSrcCommitPathGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugSrcCommitPathGet(requestParameters: SourceApiRepositoriesWorkspaceRepoSlugSrcCommitPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTreeentries> {
            return localVarFp.repositoriesWorkspaceRepoSlugSrcCommitPathGet(requestParameters.commit, requestParameters.path, requestParameters.repoSlug, requestParameters.workspace, requestParameters.format, requestParameters.q, requestParameters.sort, requestParameters.maxDepth, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo\'s main branch.  To create new commits, [POST to this endpoint](#post)
         * @summary Get the root directory of the main branch
         * @param {SourceApiRepositoriesWorkspaceRepoSlugSrcGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugSrcGet(requestParameters: SourceApiRepositoriesWorkspaceRepoSlugSrcGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTreeentries> {
            return localVarFp.repositoriesWorkspaceRepoSlugSrcGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.format, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png=@image.png ```  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the `image.png` file to the repository in the `/repo/path/to` directory.  To create a commit that deletes files, use the `files` parameter:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files=/file/to/delete/1.txt \\   -F files=/file/to/delete/2.txt ```  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts `multipart/form-data` (as in the examples above), as well as `application/x-www-form-urlencoded`.  Note: `multipart/form-data` is currently not supported by Forge apps for this API.  #### multipart/form-data  A `multipart/form-data` post contains a series of \"form fields\" that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a `Content-Disposition` parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above `curl` example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For `multipart/form-data` bodies that should not lead to any ambiguity, as the `Content-Disposition` header will contain the `filename` parameter to distinguish between a file named \"message\" and the commit message field.  #### application/x-www-form-urlencoded  It is also possible to upload new files using a simple `application/x-www-form-urlencoded` POST. This can be convenient when uploading pure text files:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \"/path/to/me.txt=Lorem ipsum.\" \\   --data-urlencode \"message=Initial commit\" \\   --data-urlencode \"author=Erik van Zijst <erik.van.zijst@gmail.com>\" ```  There could be a field name clash if a client were to upload a file named \"message\", as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. `curl --data-urlencode \"/message=file contents\"`.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  #### Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a `x-attributes` value in the `Content-Disposition` header. For example, to upload an executable file, as well as create a symlink from `README.txt` to `README`:  ``` --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"bin/shutdown.sh\" Content-Disposition: attachment; filename=\"shutdown.sh\"; x-attributes:\"executable\"  #!/bin/sh halt  --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"/README.txt\" Content-Disposition: attachment; filename=\"README.txt\"; x-attributes:\"link\"  README --===============1438169132528273974==-- ```  Links are files that contain the target path and have `x-attributes:\"link\"` set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying `x-attributes=\"link\"` will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include `x-attributes=\"executable\"` in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.
         * @summary Create a commit by uploading a file
         * @param {SourceApiRepositoriesWorkspaceRepoSlugSrcPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugSrcPost(requestParameters: SourceApiRepositoriesWorkspaceRepoSlugSrcPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugSrcPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.message, requestParameters.author, requestParameters.parents, requestParameters.files, requestParameters.branch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SourceApi - interface
 */
export interface SourceApiInterface {
    /**
     * Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order <sha> <path>  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the `?renames=false` query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to only provide exactly the data you want.  The example response returns commits made before 2011-05-18 against a file named `README.rst`. The results are filtered to only return the path and date. This request can be made using:  ``` $ curl \'https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst\'\\   \'?fields=values.next,values.path,values.commit.date&q=commit.date<=2011-05-18\' ```  In the response you can see that the file was renamed to `README.rst` by the commit made on 2011-05-16, and was previously named `README.txt`.
     * @summary List commits that modified a file
     * @param {SourceApiRepositoriesWorkspaceRepoSlugFilehistoryCommitPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet(requestParameters: SourceApiRepositoriesWorkspaceRepoSlugFilehistoryCommitPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedFiles>;

    /**
     * This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  #### Raw file contents  When `path` points to a file, this endpoint returns the raw contents. The response\'s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The `Content-Disposition` header will be \"attachment\" to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian\'s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty `__init__.py` always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  #### File meta data  When the request for a file path includes the query parameter `?format=meta`, instead of returning the file\'s raw contents, Bitbucket instead returns the JSON object describing the file\'s properties:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format=meta {   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"     }   },   \"path\": \"tests/__init__.py\",   \"commit\": {     \"type\": \"commit\",     \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"       },       \"html\": {         \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"       }     }   },   \"attributes\": [],   \"type\": \"commit_file\",   \"size\": 0 } ```  File objects contain an `attributes` element that contains a list of possible modifiers. Currently defined values are:  * `link` -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * `executable` -- indicates that the file has the executable bit set. * `subrepository` -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * `binary` -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file\'s size without incurring the overhead of receiving its full contents.   #### Directory listings  When `path` points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \"pagelen\": 10,   \"values\": [     {       \"path\": \"tests/test_project\",       \"type\": \"commit_directory\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"         }       },       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       }     },     {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"         }       },       \"path\": \"tests/__init__.py\",       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       },       \"attributes\": [],       \"type\": \"commit_file\",       \"size\": 0     }   ],   \"page\": 1,   \"size\": 2 } ```  When listing the contents of the repo\'s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \"walk\" the entire directory tree, the client can either parse each response and follow the `self` links of each `commit_directory` object, or can specify a `max_depth` to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the `max_depth` parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a `commit_file`, or a `commit_directory`, both of which contain a `path` element. This path is the absolute path from the root of the repository. Each object also contains a `commit` object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their `self` link returns the paginated contents of the directory. The `meta` link on the other hand returns the actual `directory` object itself, e.g.:  ```javascript {   \"path\": \"tests/test_project\",   \"type\": \"commit_directory\",   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"     }   },   \"commit\": { ... } } ```  #### Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  `size > 1024 and attributes = \"binary\"`  which after urlencoding yields the query string:  `?q=size%3E1024+and+attributes%3D%22binary%22`  To change the ordering of the response, use the `?sort` parameter:  `.../src/eefd5ef/?sort=-size`  See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary Get file or directory contents
     * @param {SourceApiRepositoriesWorkspaceRepoSlugSrcCommitPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugSrcCommitPathGet(requestParameters: SourceApiRepositoriesWorkspaceRepoSlugSrcCommitPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTreeentries>;

    /**
     * This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo\'s main branch.  To create new commits, [POST to this endpoint](#post)
     * @summary Get the root directory of the main branch
     * @param {SourceApiRepositoriesWorkspaceRepoSlugSrcGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugSrcGet(requestParameters: SourceApiRepositoriesWorkspaceRepoSlugSrcGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTreeentries>;

    /**
     * This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png=@image.png ```  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the `image.png` file to the repository in the `/repo/path/to` directory.  To create a commit that deletes files, use the `files` parameter:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files=/file/to/delete/1.txt \\   -F files=/file/to/delete/2.txt ```  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts `multipart/form-data` (as in the examples above), as well as `application/x-www-form-urlencoded`.  Note: `multipart/form-data` is currently not supported by Forge apps for this API.  #### multipart/form-data  A `multipart/form-data` post contains a series of \"form fields\" that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a `Content-Disposition` parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above `curl` example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For `multipart/form-data` bodies that should not lead to any ambiguity, as the `Content-Disposition` header will contain the `filename` parameter to distinguish between a file named \"message\" and the commit message field.  #### application/x-www-form-urlencoded  It is also possible to upload new files using a simple `application/x-www-form-urlencoded` POST. This can be convenient when uploading pure text files:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \"/path/to/me.txt=Lorem ipsum.\" \\   --data-urlencode \"message=Initial commit\" \\   --data-urlencode \"author=Erik van Zijst <erik.van.zijst@gmail.com>\" ```  There could be a field name clash if a client were to upload a file named \"message\", as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. `curl --data-urlencode \"/message=file contents\"`.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  #### Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a `x-attributes` value in the `Content-Disposition` header. For example, to upload an executable file, as well as create a symlink from `README.txt` to `README`:  ``` --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"bin/shutdown.sh\" Content-Disposition: attachment; filename=\"shutdown.sh\"; x-attributes:\"executable\"  #!/bin/sh halt  --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"/README.txt\" Content-Disposition: attachment; filename=\"README.txt\"; x-attributes:\"link\"  README --===============1438169132528273974==-- ```  Links are files that contain the target path and have `x-attributes:\"link\"` set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying `x-attributes=\"link\"` will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include `x-attributes=\"executable\"` in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.
     * @summary Create a commit by uploading a file
     * @param {SourceApiRepositoriesWorkspaceRepoSlugSrcPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugSrcPost(requestParameters: SourceApiRepositoriesWorkspaceRepoSlugSrcPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet operation in SourceApi.
 */
export interface SourceApiRepositoriesWorkspaceRepoSlugFilehistoryCommitPathGetRequest {
    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * Path to the file.
     */
    readonly path: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     *  When &#x60;true&#x60;, Bitbucket will follow the history of the file across renames (this is the default behavior). This can be turned off by specifying &#x60;false&#x60;.
     */
    readonly renames?: string

    /**
     *  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
     */
    readonly q?: string

    /**
     *  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). 
     */
    readonly sort?: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugSrcCommitPathGet operation in SourceApi.
 */
export interface SourceApiRepositoriesWorkspaceRepoSlugSrcCommitPathGetRequest {
    /**
     * The commit\&#39;s SHA1.
     */
    readonly commit: string

    /**
     * Path to the file.
     */
    readonly path: string

    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * If \&#39;meta\&#39; is provided, returns the (json) meta data for the contents of the file.  If \&#39;rendered\&#39; is provided, returns the contents of a non-binary file in HTML-formatted rendered markup. The \&#39;rendered\&#39; option only supports these filetypes: &#x60;.md&#x60;, &#x60;.markdown&#x60;, &#x60;.mkd&#x60;, &#x60;.mkdn&#x60;, &#x60;.mdown&#x60;, &#x60;.text&#x60;, &#x60;.rst&#x60;, and &#x60;.textile&#x60;. Since Git does not generally track what text encoding scheme is used, this endpoint attempts to detect the most appropriate character encoding. While usually correct, determining the character encoding can be ambiguous which in exceptional cases can lead to misinterpretation of the characters. As such, the raw element in the response object should not be treated as equivalent to the file\&#39;s actual contents.
     */
    readonly format?: RepositoriesWorkspaceRepoSlugSrcCommitPathGetFormatEnum

    /**
     * Optional filter expression as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
     */
    readonly q?: string

    /**
     * Optional sorting parameter as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results).
     */
    readonly sort?: string

    /**
     * If provided, returns the contents of the repository and its subdirectories recursively until the specified max_depth of nested directories. When omitted, this defaults to 1.
     */
    readonly maxDepth?: number
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugSrcGet operation in SourceApi.
 */
export interface SourceApiRepositoriesWorkspaceRepoSlugSrcGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * Instead of returning the file\&#39;s contents, return the (json) meta data for it.
     */
    readonly format?: RepositoriesWorkspaceRepoSlugSrcGetFormatEnum
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugSrcPost operation in SourceApi.
 */
export interface SourceApiRepositoriesWorkspaceRepoSlugSrcPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * The commit message. When omitted, Bitbucket uses a canned string.
     */
    readonly message?: string

    /**
     *  The raw string to be used as the new commit\&#39;s author. This string follows the format &#x60;Erik van Zijst &lt;evzijst@atlassian.com&gt;&#x60;.  When omitted, Bitbucket uses the authenticated user\&#39;s full/display name and primary email address. Commits cannot be created anonymously.
     */
    readonly author?: string

    /**
     *  #### Deprecation Notice: Support for specifying multiple parent commits is deprecated and will be removed in a future release. Only a single SHA1 is accepted.  A SHA1 of the commit that should be the parent of the newly created commit. When omitted, the new commit will inherit from and become a child of the main branch\&#39;s tip/HEAD commit.
     */
    readonly parents?: string

    /**
     *  Optional field that declares the files that the request is manipulating. When adding a new file to a repo, or when overwriting an existing file, the client can just upload the full contents of the file in a normal form field and the use of this &#x60;files&#x60; meta data field is redundant. However, when the &#x60;files&#x60; field contains a file path that does not have a corresponding, identically-named form field, then Bitbucket interprets that as the client wanting to replace the named file with the null set and the file is deleted instead.  Paths in the repo that are referenced in neither files nor an individual file field, remain unchanged and carry over from the parent to the new commit.  This API does not support renaming as an explicit feature. To rename a file, simply delete it and recreate it under the new name in the same commit. 
     */
    readonly files?: string

    /**
     *  The name of the branch that the new commit should be created on. When omitted, the commit will be created on top of the main branch and will become the main branch\&#39;s new head.  When a branch name is provided that already exists in the repo, then the commit will be created on top of that branch. In this case, *if* a parent SHA1 was also provided, then it is asserted that the parent is the branch\&#39;s tip/HEAD at the time the request is made. When this is not the case, a 409 is returned.  When a new branch name is specified (that does not already exist in the repo), and no parent SHA1s are provided, then the new commit will inherit from the current main branch\&#39;s tip/HEAD commit, but not advance the main branch. The new commit will be the new branch. When the request *also* specifies a parent SHA1, then the new commit and branch are created directly on top of the parent commit, regardless of the state of the main branch.  When a branch name is not specified, but a parent SHA1 is provided, then Bitbucket asserts that it represents the main branch\&#39;s current HEAD/tip, or a 409 is returned.  When a branch name is not specified and the repo is empty, the new commit will become the repo\&#39;s root commit and will be on the main branch.  When a branch name is specified and the repo is empty, the new commit will become the repo\&#39;s root commit and also define the repo\&#39;s main branch going forward.  This API cannot be used to create additional root commits in non-empty repos.  The branch field cannot be repeated.  As a side effect, this API can be used to create a new branch without modifying any files, by specifying a new branch name in this field, together with &#x60;parents&#x60;, but omitting the &#x60;files&#x60; fields, while not sending any files. This will create a new commit and branch with the same contents as the first parent. The diff of this commit against its first parent will be empty. 
     */
    readonly branch?: string
}

/**
 * SourceApi - object-oriented interface
 */
export class SourceApi extends BaseAPI implements SourceApiInterface {
    /**
     * Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order <sha> <path>  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the `?renames=false` query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to only provide exactly the data you want.  The example response returns commits made before 2011-05-18 against a file named `README.rst`. The results are filtered to only return the path and date. This request can be made using:  ``` $ curl \'https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst\'\\   \'?fields=values.next,values.path,values.commit.date&q=commit.date<=2011-05-18\' ```  In the response you can see that the file was renamed to `README.rst` by the commit made on 2011-05-16, and was previously named `README.txt`.
     * @summary List commits that modified a file
     * @param {SourceApiRepositoriesWorkspaceRepoSlugFilehistoryCommitPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet(requestParameters: SourceApiRepositoriesWorkspaceRepoSlugFilehistoryCommitPathGetRequest, options?: RawAxiosRequestConfig) {
        return SourceApiFp(this.configuration).repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet(requestParameters.commit, requestParameters.path, requestParameters.repoSlug, requestParameters.workspace, requestParameters.renames, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  #### Raw file contents  When `path` points to a file, this endpoint returns the raw contents. The response\'s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The `Content-Disposition` header will be \"attachment\" to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian\'s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty `__init__.py` always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  #### File meta data  When the request for a file path includes the query parameter `?format=meta`, instead of returning the file\'s raw contents, Bitbucket instead returns the JSON object describing the file\'s properties:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format=meta {   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"     }   },   \"path\": \"tests/__init__.py\",   \"commit\": {     \"type\": \"commit\",     \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",     \"links\": {       \"self\": {         \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"       },       \"html\": {         \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"       }     }   },   \"attributes\": [],   \"type\": \"commit_file\",   \"size\": 0 } ```  File objects contain an `attributes` element that contains a list of possible modifiers. Currently defined values are:  * `link` -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * `executable` -- indicates that the file has the executable bit set. * `subrepository` -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * `binary` -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file\'s size without incurring the overhead of receiving its full contents.   #### Directory listings  When `path` points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  ```javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \"pagelen\": 10,   \"values\": [     {       \"path\": \"tests/test_project\",       \"type\": \"commit_directory\",       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"         }       },       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       }     },     {       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"         },         \"meta\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"         }       },       \"path\": \"tests/__init__.py\",       \"commit\": {         \"type\": \"commit\",         \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"           },           \"html\": {             \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"           }         }       },       \"attributes\": [],       \"type\": \"commit_file\",       \"size\": 0     }   ],   \"page\": 1,   \"size\": 2 } ```  When listing the contents of the repo\'s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \"walk\" the entire directory tree, the client can either parse each response and follow the `self` links of each `commit_directory` object, or can specify a `max_depth` to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the `max_depth` parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a `commit_file`, or a `commit_directory`, both of which contain a `path` element. This path is the absolute path from the root of the repository. Each object also contains a `commit` object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their `self` link returns the paginated contents of the directory. The `meta` link on the other hand returns the actual `directory` object itself, e.g.:  ```javascript {   \"path\": \"tests/test_project\",   \"type\": \"commit_directory\",   \"links\": {     \"self\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"     },     \"meta\": {       \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"     }   },   \"commit\": { ... } } ```  #### Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  `size > 1024 and attributes = \"binary\"`  which after urlencoding yields the query string:  `?q=size%3E1024+and+attributes%3D%22binary%22`  To change the ordering of the response, use the `?sort` parameter:  `.../src/eefd5ef/?sort=-size`  See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary Get file or directory contents
     * @param {SourceApiRepositoriesWorkspaceRepoSlugSrcCommitPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugSrcCommitPathGet(requestParameters: SourceApiRepositoriesWorkspaceRepoSlugSrcCommitPathGetRequest, options?: RawAxiosRequestConfig) {
        return SourceApiFp(this.configuration).repositoriesWorkspaceRepoSlugSrcCommitPathGet(requestParameters.commit, requestParameters.path, requestParameters.repoSlug, requestParameters.workspace, requestParameters.format, requestParameters.q, requestParameters.sort, requestParameters.maxDepth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo\'s main branch.  To create new commits, [POST to this endpoint](#post)
     * @summary Get the root directory of the main branch
     * @param {SourceApiRepositoriesWorkspaceRepoSlugSrcGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugSrcGet(requestParameters: SourceApiRepositoriesWorkspaceRepoSlugSrcGetRequest, options?: RawAxiosRequestConfig) {
        return SourceApiFp(this.configuration).repositoriesWorkspaceRepoSlugSrcGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png=@image.png ```  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the `image.png` file to the repository in the `/repo/path/to` directory.  To create a commit that deletes files, use the `files` parameter:  ``` $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files=/file/to/delete/1.txt \\   -F files=/file/to/delete/2.txt ```  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts `multipart/form-data` (as in the examples above), as well as `application/x-www-form-urlencoded`.  Note: `multipart/form-data` is currently not supported by Forge apps for this API.  #### multipart/form-data  A `multipart/form-data` post contains a series of \"form fields\" that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a `Content-Disposition` parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above `curl` example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For `multipart/form-data` bodies that should not lead to any ambiguity, as the `Content-Disposition` header will contain the `filename` parameter to distinguish between a file named \"message\" and the commit message field.  #### application/x-www-form-urlencoded  It is also possible to upload new files using a simple `application/x-www-form-urlencoded` POST. This can be convenient when uploading pure text files:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \"/path/to/me.txt=Lorem ipsum.\" \\   --data-urlencode \"message=Initial commit\" \\   --data-urlencode \"author=Erik van Zijst <erik.van.zijst@gmail.com>\" ```  There could be a field name clash if a client were to upload a file named \"message\", as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. `curl --data-urlencode \"/message=file contents\"`.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  #### Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a `x-attributes` value in the `Content-Disposition` header. For example, to upload an executable file, as well as create a symlink from `README.txt` to `README`:  ``` --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"bin/shutdown.sh\" Content-Disposition: attachment; filename=\"shutdown.sh\"; x-attributes:\"executable\"  #!/bin/sh halt  --===============1438169132528273974== Content-Type: text/plain; charset=\"us-ascii\" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \"/README.txt\" Content-Disposition: attachment; filename=\"README.txt\"; x-attributes:\"link\"  README --===============1438169132528273974==-- ```  Links are files that contain the target path and have `x-attributes:\"link\"` set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying `x-attributes=\"link\"` will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include `x-attributes=\"executable\"` in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.
     * @summary Create a commit by uploading a file
     * @param {SourceApiRepositoriesWorkspaceRepoSlugSrcPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugSrcPost(requestParameters: SourceApiRepositoriesWorkspaceRepoSlugSrcPostRequest, options?: RawAxiosRequestConfig) {
        return SourceApiFp(this.configuration).repositoriesWorkspaceRepoSlugSrcPost(requestParameters.repoSlug, requestParameters.workspace, requestParameters.message, requestParameters.author, requestParameters.parents, requestParameters.files, requestParameters.branch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns details about a specific one of the authenticated user\'s email addresses.  Details describe whether the address has been confirmed by the user and whether it is the user\'s primary address or not.
         * @summary Get an email address for current user
         * @param {string} email Email address of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEmailsEmailGet: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('userEmailsEmailGet', 'email', email)
            const localVarPath = `/user/emails/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["email"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the authenticated user\'s email addresses. Both confirmed and unconfirmed.
         * @summary List email addresses for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEmailsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["email"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the currently logged in user.
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the public information associated with a user account.  If the user\'s profile is private, `location`, `website` and `created_on` elements are omitted.  Note that the user object returned by this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-bitbucket-user-objects) for details.
         * @summary Get a user
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserGet: async (selectedUser: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('usersSelectedUserGet', 'selectedUser', selectedUser)
            const localVarPath = `/users/{selected_user}`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns details about a specific one of the authenticated user\'s email addresses.  Details describe whether the address has been confirmed by the user and whether it is the user\'s primary address or not.
         * @summary Get an email address for current user
         * @param {string} email Email address of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userEmailsEmailGet(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userEmailsEmailGet(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userEmailsEmailGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all the authenticated user\'s email addresses. Both confirmed and unconfirmed.
         * @summary List email addresses for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userEmailsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userEmailsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userEmailsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the currently logged in user.
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the public information associated with a user account.  If the user\'s profile is private, `location`, `website` and `created_on` elements are omitted.  Note that the user object returned by this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-bitbucket-user-objects) for details.
         * @summary Get a user
         * @param {string} selectedUser This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSelectedUserGet(selectedUser: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSelectedUserGet(selectedUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersSelectedUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Returns details about a specific one of the authenticated user\'s email addresses.  Details describe whether the address has been confirmed by the user and whether it is the user\'s primary address or not.
         * @summary Get an email address for current user
         * @param {UsersApiUserEmailsEmailGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEmailsEmailGet(requestParameters: UsersApiUserEmailsEmailGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelError> {
            return localVarFp.userEmailsEmailGet(requestParameters.email, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the authenticated user\'s email addresses. Both confirmed and unconfirmed.
         * @summary List email addresses for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEmailsGet(options?: RawAxiosRequestConfig): AxiosPromise<ModelError> {
            return localVarFp.userEmailsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the currently logged in user.
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet(options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.userGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the public information associated with a user account.  If the user\'s profile is private, `location`, `website` and `created_on` elements are omitted.  Note that the user object returned by this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-bitbucket-user-objects) for details.
         * @summary Get a user
         * @param {UsersApiUsersSelectedUserGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSelectedUserGet(requestParameters: UsersApiUsersSelectedUserGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.usersSelectedUserGet(requestParameters.selectedUser, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - interface
 */
export interface UsersApiInterface {
    /**
     * Returns details about a specific one of the authenticated user\'s email addresses.  Details describe whether the address has been confirmed by the user and whether it is the user\'s primary address or not.
     * @summary Get an email address for current user
     * @param {UsersApiUserEmailsEmailGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userEmailsEmailGet(requestParameters: UsersApiUserEmailsEmailGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelError>;

    /**
     * Returns all the authenticated user\'s email addresses. Both confirmed and unconfirmed.
     * @summary List email addresses for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userEmailsGet(options?: RawAxiosRequestConfig): AxiosPromise<ModelError>;

    /**
     * Returns the currently logged in user.
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userGet(options?: RawAxiosRequestConfig): AxiosPromise<Account>;

    /**
     * Gets the public information associated with a user account.  If the user\'s profile is private, `location`, `website` and `created_on` elements are omitted.  Note that the user object returned by this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-bitbucket-user-objects) for details.
     * @summary Get a user
     * @param {UsersApiUsersSelectedUserGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersSelectedUserGet(requestParameters: UsersApiUsersSelectedUserGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Account>;

}

/**
 * Request parameters for userEmailsEmailGet operation in UsersApi.
 */
export interface UsersApiUserEmailsEmailGetRequest {
    /**
     * Email address of the user.
     */
    readonly email: string
}

/**
 * Request parameters for usersSelectedUserGet operation in UsersApi.
 */
export interface UsersApiUsersSelectedUserGetRequest {
    /**
     * This can either be an Atlassian Account ID OR the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. 
     */
    readonly selectedUser: string
}

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * Returns details about a specific one of the authenticated user\'s email addresses.  Details describe whether the address has been confirmed by the user and whether it is the user\'s primary address or not.
     * @summary Get an email address for current user
     * @param {UsersApiUserEmailsEmailGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userEmailsEmailGet(requestParameters: UsersApiUserEmailsEmailGetRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userEmailsEmailGet(requestParameters.email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the authenticated user\'s email addresses. Both confirmed and unconfirmed.
     * @summary List email addresses for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userEmailsGet(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userEmailsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the currently logged in user.
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userGet(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the public information associated with a user account.  If the user\'s profile is private, `location`, `website` and `created_on` elements are omitted.  Note that the user object returned by this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-bitbucket-user-objects) for details.
     * @summary Get a user
     * @param {UsersApiUsersSelectedUserGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersSelectedUserGet(requestParameters: UsersApiUsersSelectedUserGetRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersSelectedUserGet(requestParameters.selectedUser, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhooksApi - axios parameter creator
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the webhook resource or subject types on which webhooks can be registered.  Each resource/subject type contains an `events` link that returns the paginated list of specific events each individual subject type can emit.  This endpoint is publicly accessible and does not require authentication or scopes.
         * @summary Get a webhook resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookEventsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hook_events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all valid webhook events for the specified entity. **The team and user webhooks are deprecated, and you should use workspace instead. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).**  This is public data that does not require any scopes or authentication.  NOTE: The example response is a truncated response object for the `workspace` `subject_type`. We return the same structure for the other `subject_type` objects.
         * @summary List subscribable webhook types
         * @param {HookEventsSubjectTypeGetSubjectTypeEnum} subjectType A resource or subject type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookEventsSubjectTypeGet: async (subjectType: HookEventsSubjectTypeGetSubjectTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subjectType' is not null or undefined
            assertParamExists('hookEventsSubjectTypeGet', 'subjectType', subjectType)
            const localVarPath = `/hook_events/{subject_type}`
                .replace(`{${"subject_type"}}`, encodeURIComponent(String(subjectType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of webhooks installed on this repository.
         * @summary List webhooks for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksGet: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/hooks`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new webhook on the specified repository.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  Also note that the `url` must properly resolve and cannot be an internal, non-routed address.
         * @summary Create a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksPost: async (repoSlug: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksPost', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksPost', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/hooks`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified webhook subscription from the given repository.
         * @summary Delete a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksUidDelete: async (repoSlug: string, uid: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidDelete', 'repoSlug', repoSlug)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidDelete', 'uid', uid)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidDelete', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/hooks/{uid}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the webhook with the specified id installed on the specified repository.
         * @summary Get a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksUidGet: async (repoSlug: string, uid: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidGet', 'repoSlug', repoSlug)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidGet', 'uid', uid)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidGet', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/hooks/{uid}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
         * @summary Update a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksUidPut: async (repoSlug: string, uid: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidPut', 'repoSlug', repoSlug)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidPut', 'uid', uid)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('repositoriesWorkspaceRepoSlugHooksUidPut', 'workspace', workspace)
            const localVarPath = `/repositories/{workspace}/{repo_slug}/hooks/{uid}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of webhooks installed on this workspace.
         * @summary List webhooks for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksGet: async (workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/hooks`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new webhook on the specified workspace.  Workspace webhooks are fired for events from all repositories contained by that workspace.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/workspaces/my-workspace/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  This call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  The `url` must properly resolve and cannot be an internal, non-routed address.  Only workspace owners can install webhooks on workspaces.
         * @summary Create a webhook for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksPost: async (workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksPost', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/hooks`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified webhook subscription from the given workspace.
         * @summary Delete a webhook for a workspace
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksUidDelete: async (uid: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksUidDelete', 'uid', uid)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksUidDelete', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/hooks/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the webhook with the specified id installed on the given workspace.
         * @summary Get a webhook for a workspace
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksUidGet: async (uid: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksUidGet', 'uid', uid)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksUidGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/hooks/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
         * @summary Update a webhook for a workspace
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksUidPut: async (uid: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksUidPut', 'uid', uid)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksUidPut', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/hooks/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the webhook resource or subject types on which webhooks can be registered.  Each resource/subject type contains an `events` link that returns the paginated list of specific events each individual subject type can emit.  This endpoint is publicly accessible and does not require authentication or scopes.
         * @summary Get a webhook resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hookEventsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubjectTypes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hookEventsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.hookEventsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all valid webhook events for the specified entity. **The team and user webhooks are deprecated, and you should use workspace instead. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).**  This is public data that does not require any scopes or authentication.  NOTE: The example response is a truncated response object for the `workspace` `subject_type`. We return the same structure for the other `subject_type` objects.
         * @summary List subscribable webhook types
         * @param {HookEventsSubjectTypeGetSubjectTypeEnum} subjectType A resource or subject type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hookEventsSubjectTypeGet(subjectType: HookEventsSubjectTypeGetSubjectTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedHookEvents>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hookEventsSubjectTypeGet(subjectType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.hookEventsSubjectTypeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of webhooks installed on this repository.
         * @summary List webhooks for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugHooksGet(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWebhookSubscriptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugHooksGet(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.repositoriesWorkspaceRepoSlugHooksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new webhook on the specified repository.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  Also note that the `url` must properly resolve and cannot be an internal, non-routed address.
         * @summary Create a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugHooksPost(repoSlug: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugHooksPost(repoSlug, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.repositoriesWorkspaceRepoSlugHooksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified webhook subscription from the given repository.
         * @summary Delete a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugHooksUidDelete(repoSlug: string, uid: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugHooksUidDelete(repoSlug, uid, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.repositoriesWorkspaceRepoSlugHooksUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the webhook with the specified id installed on the specified repository.
         * @summary Get a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugHooksUidGet(repoSlug: string, uid: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugHooksUidGet(repoSlug, uid, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.repositoriesWorkspaceRepoSlugHooksUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
         * @summary Update a webhook for a repository
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesWorkspaceRepoSlugHooksUidPut(repoSlug: string, uid: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesWorkspaceRepoSlugHooksUidPut(repoSlug, uid, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.repositoriesWorkspaceRepoSlugHooksUidPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of webhooks installed on this workspace.
         * @summary List webhooks for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceHooksGet(workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWebhookSubscriptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceHooksGet(workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.workspacesWorkspaceHooksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new webhook on the specified workspace.  Workspace webhooks are fired for events from all repositories contained by that workspace.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/workspaces/my-workspace/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  This call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  The `url` must properly resolve and cannot be an internal, non-routed address.  Only workspace owners can install webhooks on workspaces.
         * @summary Create a webhook for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceHooksPost(workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceHooksPost(workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.workspacesWorkspaceHooksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified webhook subscription from the given workspace.
         * @summary Delete a webhook for a workspace
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceHooksUidDelete(uid: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceHooksUidDelete(uid, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.workspacesWorkspaceHooksUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the webhook with the specified id installed on the given workspace.
         * @summary Get a webhook for a workspace
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceHooksUidGet(uid: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceHooksUidGet(uid, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.workspacesWorkspaceHooksUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
         * @summary Update a webhook for a workspace
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceHooksUidPut(uid: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceHooksUidPut(uid, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.workspacesWorkspaceHooksUidPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Returns the webhook resource or subject types on which webhooks can be registered.  Each resource/subject type contains an `events` link that returns the paginated list of specific events each individual subject type can emit.  This endpoint is publicly accessible and does not require authentication or scopes.
         * @summary Get a webhook resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookEventsGet(options?: RawAxiosRequestConfig): AxiosPromise<SubjectTypes> {
            return localVarFp.hookEventsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all valid webhook events for the specified entity. **The team and user webhooks are deprecated, and you should use workspace instead. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).**  This is public data that does not require any scopes or authentication.  NOTE: The example response is a truncated response object for the `workspace` `subject_type`. We return the same structure for the other `subject_type` objects.
         * @summary List subscribable webhook types
         * @param {WebhooksApiHookEventsSubjectTypeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookEventsSubjectTypeGet(requestParameters: WebhooksApiHookEventsSubjectTypeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedHookEvents> {
            return localVarFp.hookEventsSubjectTypeGet(requestParameters.subjectType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of webhooks installed on this repository.
         * @summary List webhooks for a repository
         * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksGet(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWebhookSubscriptions> {
            return localVarFp.repositoriesWorkspaceRepoSlugHooksGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new webhook on the specified repository.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  Also note that the `url` must properly resolve and cannot be an internal, non-routed address.
         * @summary Create a webhook for a repository
         * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksPost(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription> {
            return localVarFp.repositoriesWorkspaceRepoSlugHooksPost(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified webhook subscription from the given repository.
         * @summary Delete a webhook for a repository
         * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksUidDelete(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesWorkspaceRepoSlugHooksUidDelete(requestParameters.repoSlug, requestParameters.uid, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the webhook with the specified id installed on the specified repository.
         * @summary Get a webhook for a repository
         * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksUidGet(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription> {
            return localVarFp.repositoriesWorkspaceRepoSlugHooksUidGet(requestParameters.repoSlug, requestParameters.uid, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
         * @summary Update a webhook for a repository
         * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesWorkspaceRepoSlugHooksUidPut(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription> {
            return localVarFp.repositoriesWorkspaceRepoSlugHooksUidPut(requestParameters.repoSlug, requestParameters.uid, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of webhooks installed on this workspace.
         * @summary List webhooks for a workspace
         * @param {WebhooksApiWorkspacesWorkspaceHooksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksGet(requestParameters: WebhooksApiWorkspacesWorkspaceHooksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWebhookSubscriptions> {
            return localVarFp.workspacesWorkspaceHooksGet(requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new webhook on the specified workspace.  Workspace webhooks are fired for events from all repositories contained by that workspace.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/workspaces/my-workspace/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  This call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  The `url` must properly resolve and cannot be an internal, non-routed address.  Only workspace owners can install webhooks on workspaces.
         * @summary Create a webhook for a workspace
         * @param {WebhooksApiWorkspacesWorkspaceHooksPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksPost(requestParameters: WebhooksApiWorkspacesWorkspaceHooksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription> {
            return localVarFp.workspacesWorkspaceHooksPost(requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified webhook subscription from the given workspace.
         * @summary Delete a webhook for a workspace
         * @param {WebhooksApiWorkspacesWorkspaceHooksUidDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksUidDelete(requestParameters: WebhooksApiWorkspacesWorkspaceHooksUidDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.workspacesWorkspaceHooksUidDelete(requestParameters.uid, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the webhook with the specified id installed on the given workspace.
         * @summary Get a webhook for a workspace
         * @param {WebhooksApiWorkspacesWorkspaceHooksUidGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksUidGet(requestParameters: WebhooksApiWorkspacesWorkspaceHooksUidGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription> {
            return localVarFp.workspacesWorkspaceHooksUidGet(requestParameters.uid, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
         * @summary Update a webhook for a workspace
         * @param {WebhooksApiWorkspacesWorkspaceHooksUidPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksUidPut(requestParameters: WebhooksApiWorkspacesWorkspaceHooksUidPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription> {
            return localVarFp.workspacesWorkspaceHooksUidPut(requestParameters.uid, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - interface
 */
export interface WebhooksApiInterface {
    /**
     * Returns the webhook resource or subject types on which webhooks can be registered.  Each resource/subject type contains an `events` link that returns the paginated list of specific events each individual subject type can emit.  This endpoint is publicly accessible and does not require authentication or scopes.
     * @summary Get a webhook resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hookEventsGet(options?: RawAxiosRequestConfig): AxiosPromise<SubjectTypes>;

    /**
     * Returns a paginated list of all valid webhook events for the specified entity. **The team and user webhooks are deprecated, and you should use workspace instead. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).**  This is public data that does not require any scopes or authentication.  NOTE: The example response is a truncated response object for the `workspace` `subject_type`. We return the same structure for the other `subject_type` objects.
     * @summary List subscribable webhook types
     * @param {WebhooksApiHookEventsSubjectTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hookEventsSubjectTypeGet(requestParameters: WebhooksApiHookEventsSubjectTypeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedHookEvents>;

    /**
     * Returns a paginated list of webhooks installed on this repository.
     * @summary List webhooks for a repository
     * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugHooksGet(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWebhookSubscriptions>;

    /**
     * Creates a new webhook on the specified repository.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  Also note that the `url` must properly resolve and cannot be an internal, non-routed address.
     * @summary Create a webhook for a repository
     * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugHooksPost(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription>;

    /**
     * Deletes the specified webhook subscription from the given repository.
     * @summary Delete a webhook for a repository
     * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugHooksUidDelete(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the webhook with the specified id installed on the specified repository.
     * @summary Get a webhook for a repository
     * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugHooksUidGet(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription>;

    /**
     * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
     * @summary Update a webhook for a repository
     * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    repositoriesWorkspaceRepoSlugHooksUidPut(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription>;

    /**
     * Returns a paginated list of webhooks installed on this workspace.
     * @summary List webhooks for a workspace
     * @param {WebhooksApiWorkspacesWorkspaceHooksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceHooksGet(requestParameters: WebhooksApiWorkspacesWorkspaceHooksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWebhookSubscriptions>;

    /**
     * Creates a new webhook on the specified workspace.  Workspace webhooks are fired for events from all repositories contained by that workspace.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/workspaces/my-workspace/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  This call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  The `url` must properly resolve and cannot be an internal, non-routed address.  Only workspace owners can install webhooks on workspaces.
     * @summary Create a webhook for a workspace
     * @param {WebhooksApiWorkspacesWorkspaceHooksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceHooksPost(requestParameters: WebhooksApiWorkspacesWorkspaceHooksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription>;

    /**
     * Deletes the specified webhook subscription from the given workspace.
     * @summary Delete a webhook for a workspace
     * @param {WebhooksApiWorkspacesWorkspaceHooksUidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceHooksUidDelete(requestParameters: WebhooksApiWorkspacesWorkspaceHooksUidDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the webhook with the specified id installed on the given workspace.
     * @summary Get a webhook for a workspace
     * @param {WebhooksApiWorkspacesWorkspaceHooksUidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceHooksUidGet(requestParameters: WebhooksApiWorkspacesWorkspaceHooksUidGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription>;

    /**
     * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
     * @summary Update a webhook for a workspace
     * @param {WebhooksApiWorkspacesWorkspaceHooksUidPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceHooksUidPut(requestParameters: WebhooksApiWorkspacesWorkspaceHooksUidPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription>;

}

/**
 * Request parameters for hookEventsSubjectTypeGet operation in WebhooksApi.
 */
export interface WebhooksApiHookEventsSubjectTypeGetRequest {
    /**
     * A resource or subject type.
     */
    readonly subjectType: HookEventsSubjectTypeGetSubjectTypeEnum
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugHooksGet operation in WebhooksApi.
 */
export interface WebhooksApiRepositoriesWorkspaceRepoSlugHooksGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugHooksPost operation in WebhooksApi.
 */
export interface WebhooksApiRepositoriesWorkspaceRepoSlugHooksPostRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugHooksUidDelete operation in WebhooksApi.
 */
export interface WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidDeleteRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * Installed webhook\&#39;s ID
     */
    readonly uid: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugHooksUidGet operation in WebhooksApi.
 */
export interface WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * Installed webhook\&#39;s ID
     */
    readonly uid: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for repositoriesWorkspaceRepoSlugHooksUidPut operation in WebhooksApi.
 */
export interface WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidPutRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * Installed webhook\&#39;s ID
     */
    readonly uid: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceHooksGet operation in WebhooksApi.
 */
export interface WebhooksApiWorkspacesWorkspaceHooksGetRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceHooksPost operation in WebhooksApi.
 */
export interface WebhooksApiWorkspacesWorkspaceHooksPostRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceHooksUidDelete operation in WebhooksApi.
 */
export interface WebhooksApiWorkspacesWorkspaceHooksUidDeleteRequest {
    /**
     * Installed webhook\&#39;s ID
     */
    readonly uid: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceHooksUidGet operation in WebhooksApi.
 */
export interface WebhooksApiWorkspacesWorkspaceHooksUidGetRequest {
    /**
     * Installed webhook\&#39;s ID
     */
    readonly uid: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceHooksUidPut operation in WebhooksApi.
 */
export interface WebhooksApiWorkspacesWorkspaceHooksUidPutRequest {
    /**
     * Installed webhook\&#39;s ID
     */
    readonly uid: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * WebhooksApi - object-oriented interface
 */
export class WebhooksApi extends BaseAPI implements WebhooksApiInterface {
    /**
     * Returns the webhook resource or subject types on which webhooks can be registered.  Each resource/subject type contains an `events` link that returns the paginated list of specific events each individual subject type can emit.  This endpoint is publicly accessible and does not require authentication or scopes.
     * @summary Get a webhook resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public hookEventsGet(options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).hookEventsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all valid webhook events for the specified entity. **The team and user webhooks are deprecated, and you should use workspace instead. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).**  This is public data that does not require any scopes or authentication.  NOTE: The example response is a truncated response object for the `workspace` `subject_type`. We return the same structure for the other `subject_type` objects.
     * @summary List subscribable webhook types
     * @param {WebhooksApiHookEventsSubjectTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public hookEventsSubjectTypeGet(requestParameters: WebhooksApiHookEventsSubjectTypeGetRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).hookEventsSubjectTypeGet(requestParameters.subjectType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of webhooks installed on this repository.
     * @summary List webhooks for a repository
     * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugHooksGet(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksGetRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).repositoriesWorkspaceRepoSlugHooksGet(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new webhook on the specified repository.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  Also note that the `url` must properly resolve and cannot be an internal, non-routed address.
     * @summary Create a webhook for a repository
     * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugHooksPost(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksPostRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).repositoriesWorkspaceRepoSlugHooksPost(requestParameters.repoSlug, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified webhook subscription from the given repository.
     * @summary Delete a webhook for a repository
     * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugHooksUidDelete(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidDeleteRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).repositoriesWorkspaceRepoSlugHooksUidDelete(requestParameters.repoSlug, requestParameters.uid, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the webhook with the specified id installed on the specified repository.
     * @summary Get a webhook for a repository
     * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugHooksUidGet(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidGetRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).repositoriesWorkspaceRepoSlugHooksUidGet(requestParameters.repoSlug, requestParameters.uid, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
     * @summary Update a webhook for a repository
     * @param {WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repositoriesWorkspaceRepoSlugHooksUidPut(requestParameters: WebhooksApiRepositoriesWorkspaceRepoSlugHooksUidPutRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).repositoriesWorkspaceRepoSlugHooksUidPut(requestParameters.repoSlug, requestParameters.uid, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of webhooks installed on this workspace.
     * @summary List webhooks for a workspace
     * @param {WebhooksApiWorkspacesWorkspaceHooksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceHooksGet(requestParameters: WebhooksApiWorkspacesWorkspaceHooksGetRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).workspacesWorkspaceHooksGet(requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new webhook on the specified workspace.  Workspace webhooks are fired for events from all repositories contained by that workspace.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/workspaces/my-workspace/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  This call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  The `url` must properly resolve and cannot be an internal, non-routed address.  Only workspace owners can install webhooks on workspaces.
     * @summary Create a webhook for a workspace
     * @param {WebhooksApiWorkspacesWorkspaceHooksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceHooksPost(requestParameters: WebhooksApiWorkspacesWorkspaceHooksPostRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).workspacesWorkspaceHooksPost(requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified webhook subscription from the given workspace.
     * @summary Delete a webhook for a workspace
     * @param {WebhooksApiWorkspacesWorkspaceHooksUidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceHooksUidDelete(requestParameters: WebhooksApiWorkspacesWorkspaceHooksUidDeleteRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).workspacesWorkspaceHooksUidDelete(requestParameters.uid, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the webhook with the specified id installed on the given workspace.
     * @summary Get a webhook for a workspace
     * @param {WebhooksApiWorkspacesWorkspaceHooksUidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceHooksUidGet(requestParameters: WebhooksApiWorkspacesWorkspaceHooksUidGetRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).workspacesWorkspaceHooksUidGet(requestParameters.uid, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
     * @summary Update a webhook for a workspace
     * @param {WebhooksApiWorkspacesWorkspaceHooksUidPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceHooksUidPut(requestParameters: WebhooksApiWorkspacesWorkspaceHooksUidPutRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).workspacesWorkspaceHooksUidPut(requestParameters.uid, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }
}

export const HookEventsSubjectTypeGetSubjectTypeEnum = {
    Repository: 'repository',
    Workspace: 'workspace'
} as const;
export type HookEventsSubjectTypeGetSubjectTypeEnum = typeof HookEventsSubjectTypeGetSubjectTypeEnum[keyof typeof HookEventsSubjectTypeGetSubjectTypeEnum];


/**
 * WorkspacesApi - axios parameter creator
 */
export const WorkspacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an object for each workspace the caller is a member of, and their effective role - the highest level of privilege the caller has. If a user is a member of multiple groups with distinct roles, only the highest level is returned.  Permissions can be:  * `owner` * `collaborator` * `member`  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  **When you move your administration from Bitbucket Cloud to admin.atlassian.com, the following fields on `workspace_membership` will no longer be present: `last_accessed` and `added_on`. See the [deprecation announcement](/cloud/bitbucket/announcement-breaking-change-workspace-membership/).**  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by workspace or permission by adding the following query string parameters:  * `q=workspace.slug=\"bbworkspace1\"` or `q=permission=\"owner\"` * `sort=workspace.slug`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  This endpoint is deprecated and will be replaced with a new endpoint by end of calendar year 2025.
         * @summary List workspaces for the current user
         * @param {string} [q]  Query string to narrow down the response. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details.
         * @param {string} [sort]  Name of a response property to sort results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results) for details. 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userPermissionsWorkspacesGet: async (q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/permissions/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of workspaces accessible by the authenticated user.  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by workspace or permission by adding the following query string parameters:  * `q=slug=\"bbworkspace1\"` or `q=is_private=true` * `sort=created_on`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  This endpoint is deprecated and will be replaced with a new endpoint by end of calendar year 2025.
         * @summary List workspaces for user
         * @param {WorkspacesGetRoleEnum} [role]              Filters the workspaces based on the authenticated user\&#39;s role on each workspace.              * **member**: returns a list of all the workspaces which the caller is a member of                 at least one workspace group or repository             * **collaborator**: returns a list of workspaces which the caller has write access                 to at least one repository in the workspace             * **owner**: returns a list of workspaces which the caller has administrator access             
         * @param {string} [q]  Query string to narrow down the response. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details.
         * @param {string} [sort]  Name of a response property to sort results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results) for details. 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        workspacesGet: async (role?: WorkspacesGetRoleEnum, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the requested workspace.
         * @summary Get a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceGet: async (workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of webhooks installed on this workspace.
         * @summary List webhooks for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksGet: async (workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/hooks`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new webhook on the specified workspace.  Workspace webhooks are fired for events from all repositories contained by that workspace.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/workspaces/my-workspace/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  This call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  The `url` must properly resolve and cannot be an internal, non-routed address.  Only workspace owners can install webhooks on workspaces.
         * @summary Create a webhook for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksPost: async (workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksPost', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/hooks`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified webhook subscription from the given workspace.
         * @summary Delete a webhook for a workspace
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksUidDelete: async (uid: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksUidDelete', 'uid', uid)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksUidDelete', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/hooks/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the webhook with the specified id installed on the given workspace.
         * @summary Get a webhook for a workspace
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksUidGet: async (uid: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksUidGet', 'uid', uid)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksUidGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/hooks/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
         * @summary Update a webhook for a workspace
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksUidPut: async (uid: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksUidPut', 'uid', uid)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceHooksUidPut', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/hooks/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["webhook"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all members of the requested workspace.  This endpoint additionally supports [filtering](/cloud/bitbucket/rest/intro/#filtering) by email address, if called by a workspace administrator, integration or workspace access token. This is done by adding the following query string parameter:  * `q=user.email IN (\"user1@org.com\",\"user2@org.com\")`  When filtering by email, you can query up to 90 addresses at a time. Note that the query parameter values need to be URL escaped, so the final query string should be:  * `q=user.email%20IN%20(%22user1@org.com%22,%22user2@org.com%22)`  Email addresses that you filter by (and only these email addresses) can be included in the response using the `fields` query parameter:  * `&fields=+values.user.email` - add the `email` field to the default `user` response object * `&fields=values.user.email,values.user.account_id` - only return user email addresses and account IDs  Once again, all query parameter values must be URL escaped.
         * @summary List users in a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceMembersGet: async (workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceMembersGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/members`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the workspace membership, which includes a `User` object for the member and a `Workspace` object for the requested workspace.
         * @summary Get user membership for a workspace
         * @param {string} member Member\&#39;s UUID or Atlassian ID.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceMembersMemberGet: async (member: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'member' is not null or undefined
            assertParamExists('workspacesWorkspaceMembersMemberGet', 'member', member)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceMembersMemberGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/members/{member}`
                .replace(`{${"member"}}`, encodeURIComponent(String(member)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of members in a workspace and their permission levels. Permission can be: * `owner` * `collaborator` * `member`  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  **When you move your administration from Bitbucket Cloud to admin.atlassian.com, the following fields on `workspace_membership` will no longer be present: `last_accessed` and `added_on`. See the [deprecation announcement](/cloud/bitbucket/announcement-breaking-change-workspace-membership/).**  Results may be further [filtered](/cloud/bitbucket/rest/intro/#filtering) by permission by adding the following query string parameters:  * `q=permission=\"owner\"`
         * @summary List user permissions in a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspacePermissionsGet: async (workspace: string, q?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspacePermissionsGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/permissions`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object for each repository permission for all of a workspace\'s repositories.  Permissions returned are effective permissions: the highest level of permission the user has. This does not distinguish between direct and indirect (group) privileges.  Only users with admin permission for the team may access this resource.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by repository, user, or permission by adding the following query string parameters:  * `q=repository.name=\"geordi\"` or `q=permission>\"read\"` * `sort=user.display_name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.
         * @summary List all repository permissions for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspacePermissionsRepositoriesGet: async (workspace: string, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspacePermissionsRepositoriesGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/permissions/repositories`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["account"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object for the repository permission of each user in the requested repository.  Permissions returned are effective permissions: the highest level of permission the user has. This does not distinguish between direct and indirect (group) privileges.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by user, or permission by adding the following query string parameters:  * `q=permission>\"read\"` * `sort=user.display_name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.
         * @summary List a repository permissions for a workspace
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspacePermissionsRepositoriesRepoSlugGet: async (repoSlug: string, workspace: string, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoSlug' is not null or undefined
            assertParamExists('workspacesWorkspacePermissionsRepositoriesRepoSlugGet', 'repoSlug', repoSlug)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspacePermissionsRepositoriesRepoSlugGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/permissions/repositories/{repo_slug}`
                .replace(`{${"repo_slug"}}`, encodeURIComponent(String(repoSlug)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["repository"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of projects in this workspace.
         * @summary List projects in a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsGet: async (workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the requested project.
         * @summary Get a project for a workspace
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyGet: async (projectKey: string, workspace: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyGet', 'projectKey', projectKey)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspaceProjectsProjectKeyGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/projects/{project_key}`
                .replace(`{${"project_key"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["project"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all workspace pull requests authored by the specified user.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List workspace pull requests for a user
         * @param {string} selectedUser This can either be the username of the pull request author, the author\&#39;s UUID surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, or the author\&#39;s Atlassian ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {WorkspacesWorkspacePullrequestsSelectedUserGetStateEnum} [state] Only return pull requests that are in this state. This parameter can be repeated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspacePullrequestsSelectedUserGet: async (selectedUser: string, workspace: string, state?: WorkspacesWorkspacePullrequestsSelectedUserGetStateEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedUser' is not null or undefined
            assertParamExists('workspacesWorkspacePullrequestsSelectedUserGet', 'selectedUser', selectedUser)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacesWorkspacePullrequestsSelectedUserGet', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}/pullrequests/{selected_user}`
                .replace(`{${"selected_user"}}`, encodeURIComponent(String(selectedUser)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["pullrequest"], configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspacesApi - functional programming interface
 */
export const WorkspacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspacesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns an object for each workspace the caller is a member of, and their effective role - the highest level of privilege the caller has. If a user is a member of multiple groups with distinct roles, only the highest level is returned.  Permissions can be:  * `owner` * `collaborator` * `member`  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  **When you move your administration from Bitbucket Cloud to admin.atlassian.com, the following fields on `workspace_membership` will no longer be present: `last_accessed` and `added_on`. See the [deprecation announcement](/cloud/bitbucket/announcement-breaking-change-workspace-membership/).**  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by workspace or permission by adding the following query string parameters:  * `q=workspace.slug=\"bbworkspace1\"` or `q=permission=\"owner\"` * `sort=workspace.slug`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  This endpoint is deprecated and will be replaced with a new endpoint by end of calendar year 2025.
         * @summary List workspaces for the current user
         * @param {string} [q]  Query string to narrow down the response. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details.
         * @param {string} [sort]  Name of a response property to sort results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results) for details. 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async userPermissionsWorkspacesGet(q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWorkspaceMemberships>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPermissionsWorkspacesGet(q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.userPermissionsWorkspacesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of workspaces accessible by the authenticated user.  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by workspace or permission by adding the following query string parameters:  * `q=slug=\"bbworkspace1\"` or `q=is_private=true` * `sort=created_on`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  This endpoint is deprecated and will be replaced with a new endpoint by end of calendar year 2025.
         * @summary List workspaces for user
         * @param {WorkspacesGetRoleEnum} [role]              Filters the workspaces based on the authenticated user\&#39;s role on each workspace.              * **member**: returns a list of all the workspaces which the caller is a member of                 at least one workspace group or repository             * **collaborator**: returns a list of workspaces which the caller has write access                 to at least one repository in the workspace             * **owner**: returns a list of workspaces which the caller has administrator access             
         * @param {string} [q]  Query string to narrow down the response. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details.
         * @param {string} [sort]  Name of a response property to sort results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results) for details. 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async workspacesGet(role?: WorkspacesGetRoleEnum, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWorkspaces>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesGet(role, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the requested workspace.
         * @summary Get a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceGet(workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceGet(workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesWorkspaceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of webhooks installed on this workspace.
         * @summary List webhooks for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceHooksGet(workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWebhookSubscriptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceHooksGet(workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesWorkspaceHooksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new webhook on the specified workspace.  Workspace webhooks are fired for events from all repositories contained by that workspace.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/workspaces/my-workspace/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  This call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  The `url` must properly resolve and cannot be an internal, non-routed address.  Only workspace owners can install webhooks on workspaces.
         * @summary Create a webhook for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceHooksPost(workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceHooksPost(workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesWorkspaceHooksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified webhook subscription from the given workspace.
         * @summary Delete a webhook for a workspace
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceHooksUidDelete(uid: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceHooksUidDelete(uid, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesWorkspaceHooksUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the webhook with the specified id installed on the given workspace.
         * @summary Get a webhook for a workspace
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceHooksUidGet(uid: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceHooksUidGet(uid, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesWorkspaceHooksUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
         * @summary Update a webhook for a workspace
         * @param {string} uid Installed webhook\&#39;s ID
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceHooksUidPut(uid: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceHooksUidPut(uid, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesWorkspaceHooksUidPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all members of the requested workspace.  This endpoint additionally supports [filtering](/cloud/bitbucket/rest/intro/#filtering) by email address, if called by a workspace administrator, integration or workspace access token. This is done by adding the following query string parameter:  * `q=user.email IN (\"user1@org.com\",\"user2@org.com\")`  When filtering by email, you can query up to 90 addresses at a time. Note that the query parameter values need to be URL escaped, so the final query string should be:  * `q=user.email%20IN%20(%22user1@org.com%22,%22user2@org.com%22)`  Email addresses that you filter by (and only these email addresses) can be included in the response using the `fields` query parameter:  * `&fields=+values.user.email` - add the `email` field to the default `user` response object * `&fields=values.user.email,values.user.account_id` - only return user email addresses and account IDs  Once again, all query parameter values must be URL escaped.
         * @summary List users in a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceMembersGet(workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWorkspaceMemberships>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceMembersGet(workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesWorkspaceMembersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the workspace membership, which includes a `User` object for the member and a `Workspace` object for the requested workspace.
         * @summary Get user membership for a workspace
         * @param {string} member Member\&#39;s UUID or Atlassian ID.
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceMembersMemberGet(member: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceMembersMemberGet(member, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesWorkspaceMembersMemberGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the list of members in a workspace and their permission levels. Permission can be: * `owner` * `collaborator` * `member`  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  **When you move your administration from Bitbucket Cloud to admin.atlassian.com, the following fields on `workspace_membership` will no longer be present: `last_accessed` and `added_on`. See the [deprecation announcement](/cloud/bitbucket/announcement-breaking-change-workspace-membership/).**  Results may be further [filtered](/cloud/bitbucket/rest/intro/#filtering) by permission by adding the following query string parameters:  * `q=permission=\"owner\"`
         * @summary List user permissions in a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspacePermissionsGet(workspace: string, q?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWorkspaceMemberships>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspacePermissionsGet(workspace, q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesWorkspacePermissionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an object for each repository permission for all of a workspace\'s repositories.  Permissions returned are effective permissions: the highest level of permission the user has. This does not distinguish between direct and indirect (group) privileges.  Only users with admin permission for the team may access this resource.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by repository, user, or permission by adding the following query string parameters:  * `q=repository.name=\"geordi\"` or `q=permission>\"read\"` * `sort=user.display_name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.
         * @summary List all repository permissions for a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspacePermissionsRepositoriesGet(workspace: string, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRepositoryPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspacePermissionsRepositoriesGet(workspace, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesWorkspacePermissionsRepositoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an object for the repository permission of each user in the requested repository.  Permissions returned are effective permissions: the highest level of permission the user has. This does not distinguish between direct and indirect (group) privileges.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by user, or permission by adding the following query string parameters:  * `q=permission>\"read\"` * `sort=user.display_name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.
         * @summary List a repository permissions for a workspace
         * @param {string} repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {string} [q]  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
         * @param {string} [sort]  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspacePermissionsRepositoriesRepoSlugGet(repoSlug: string, workspace: string, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRepositoryPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspacePermissionsRepositoriesRepoSlugGet(repoSlug, workspace, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesWorkspacePermissionsRepositoriesRepoSlugGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the list of projects in this workspace.
         * @summary List projects in a workspace
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsGet(workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProjects>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsGet(workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesWorkspaceProjectsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the requested project.
         * @summary Get a project for a workspace
         * @param {string} projectKey The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspaceProjectsProjectKeyGet(projectKey: string, workspace: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspaceProjectsProjectKeyGet(projectKey, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesWorkspaceProjectsProjectKeyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all workspace pull requests authored by the specified user.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List workspace pull requests for a user
         * @param {string} selectedUser This can either be the username of the pull request author, the author\&#39;s UUID surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, or the author\&#39;s Atlassian ID. 
         * @param {string} workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
         * @param {WorkspacesWorkspacePullrequestsSelectedUserGetStateEnum} [state] Only return pull requests that are in this state. This parameter can be repeated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesWorkspacePullrequestsSelectedUserGet(selectedUser: string, workspace: string, state?: WorkspacesWorkspacePullrequestsSelectedUserGetStateEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPullrequests>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesWorkspacePullrequestsSelectedUserGet(selectedUser, workspace, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesWorkspacePullrequestsSelectedUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspacesApi - factory interface
 */
export const WorkspacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspacesApiFp(configuration)
    return {
        /**
         * Returns an object for each workspace the caller is a member of, and their effective role - the highest level of privilege the caller has. If a user is a member of multiple groups with distinct roles, only the highest level is returned.  Permissions can be:  * `owner` * `collaborator` * `member`  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  **When you move your administration from Bitbucket Cloud to admin.atlassian.com, the following fields on `workspace_membership` will no longer be present: `last_accessed` and `added_on`. See the [deprecation announcement](/cloud/bitbucket/announcement-breaking-change-workspace-membership/).**  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by workspace or permission by adding the following query string parameters:  * `q=workspace.slug=\"bbworkspace1\"` or `q=permission=\"owner\"` * `sort=workspace.slug`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  This endpoint is deprecated and will be replaced with a new endpoint by end of calendar year 2025.
         * @summary List workspaces for the current user
         * @param {WorkspacesApiUserPermissionsWorkspacesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userPermissionsWorkspacesGet(requestParameters: WorkspacesApiUserPermissionsWorkspacesGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWorkspaceMemberships> {
            return localVarFp.userPermissionsWorkspacesGet(requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of workspaces accessible by the authenticated user.  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by workspace or permission by adding the following query string parameters:  * `q=slug=\"bbworkspace1\"` or `q=is_private=true` * `sort=created_on`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  This endpoint is deprecated and will be replaced with a new endpoint by end of calendar year 2025.
         * @summary List workspaces for user
         * @param {WorkspacesApiWorkspacesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        workspacesGet(requestParameters: WorkspacesApiWorkspacesGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWorkspaces> {
            return localVarFp.workspacesGet(requestParameters.role, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the requested workspace.
         * @summary Get a workspace
         * @param {WorkspacesApiWorkspacesWorkspaceGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceGet(requestParameters: WorkspacesApiWorkspacesWorkspaceGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Workspace> {
            return localVarFp.workspacesWorkspaceGet(requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of webhooks installed on this workspace.
         * @summary List webhooks for a workspace
         * @param {WorkspacesApiWorkspacesWorkspaceHooksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksGet(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWebhookSubscriptions> {
            return localVarFp.workspacesWorkspaceHooksGet(requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new webhook on the specified workspace.  Workspace webhooks are fired for events from all repositories contained by that workspace.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/workspaces/my-workspace/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  This call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  The `url` must properly resolve and cannot be an internal, non-routed address.  Only workspace owners can install webhooks on workspaces.
         * @summary Create a webhook for a workspace
         * @param {WorkspacesApiWorkspacesWorkspaceHooksPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksPost(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription> {
            return localVarFp.workspacesWorkspaceHooksPost(requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified webhook subscription from the given workspace.
         * @summary Delete a webhook for a workspace
         * @param {WorkspacesApiWorkspacesWorkspaceHooksUidDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksUidDelete(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksUidDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.workspacesWorkspaceHooksUidDelete(requestParameters.uid, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the webhook with the specified id installed on the given workspace.
         * @summary Get a webhook for a workspace
         * @param {WorkspacesApiWorkspacesWorkspaceHooksUidGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksUidGet(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksUidGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription> {
            return localVarFp.workspacesWorkspaceHooksUidGet(requestParameters.uid, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
         * @summary Update a webhook for a workspace
         * @param {WorkspacesApiWorkspacesWorkspaceHooksUidPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceHooksUidPut(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksUidPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription> {
            return localVarFp.workspacesWorkspaceHooksUidPut(requestParameters.uid, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all members of the requested workspace.  This endpoint additionally supports [filtering](/cloud/bitbucket/rest/intro/#filtering) by email address, if called by a workspace administrator, integration or workspace access token. This is done by adding the following query string parameter:  * `q=user.email IN (\"user1@org.com\",\"user2@org.com\")`  When filtering by email, you can query up to 90 addresses at a time. Note that the query parameter values need to be URL escaped, so the final query string should be:  * `q=user.email%20IN%20(%22user1@org.com%22,%22user2@org.com%22)`  Email addresses that you filter by (and only these email addresses) can be included in the response using the `fields` query parameter:  * `&fields=+values.user.email` - add the `email` field to the default `user` response object * `&fields=values.user.email,values.user.account_id` - only return user email addresses and account IDs  Once again, all query parameter values must be URL escaped.
         * @summary List users in a workspace
         * @param {WorkspacesApiWorkspacesWorkspaceMembersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceMembersGet(requestParameters: WorkspacesApiWorkspacesWorkspaceMembersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWorkspaceMemberships> {
            return localVarFp.workspacesWorkspaceMembersGet(requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the workspace membership, which includes a `User` object for the member and a `Workspace` object for the requested workspace.
         * @summary Get user membership for a workspace
         * @param {WorkspacesApiWorkspacesWorkspaceMembersMemberGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceMembersMemberGet(requestParameters: WorkspacesApiWorkspacesWorkspaceMembersMemberGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceMembership> {
            return localVarFp.workspacesWorkspaceMembersMemberGet(requestParameters.member, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of members in a workspace and their permission levels. Permission can be: * `owner` * `collaborator` * `member`  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  **When you move your administration from Bitbucket Cloud to admin.atlassian.com, the following fields on `workspace_membership` will no longer be present: `last_accessed` and `added_on`. See the [deprecation announcement](/cloud/bitbucket/announcement-breaking-change-workspace-membership/).**  Results may be further [filtered](/cloud/bitbucket/rest/intro/#filtering) by permission by adding the following query string parameters:  * `q=permission=\"owner\"`
         * @summary List user permissions in a workspace
         * @param {WorkspacesApiWorkspacesWorkspacePermissionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspacePermissionsGet(requestParameters: WorkspacesApiWorkspacesWorkspacePermissionsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWorkspaceMemberships> {
            return localVarFp.workspacesWorkspacePermissionsGet(requestParameters.workspace, requestParameters.q, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object for each repository permission for all of a workspace\'s repositories.  Permissions returned are effective permissions: the highest level of permission the user has. This does not distinguish between direct and indirect (group) privileges.  Only users with admin permission for the team may access this resource.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by repository, user, or permission by adding the following query string parameters:  * `q=repository.name=\"geordi\"` or `q=permission>\"read\"` * `sort=user.display_name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.
         * @summary List all repository permissions for a workspace
         * @param {WorkspacesApiWorkspacesWorkspacePermissionsRepositoriesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspacePermissionsRepositoriesGet(requestParameters: WorkspacesApiWorkspacesWorkspacePermissionsRepositoriesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositoryPermissions> {
            return localVarFp.workspacesWorkspacePermissionsRepositoriesGet(requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object for the repository permission of each user in the requested repository.  Permissions returned are effective permissions: the highest level of permission the user has. This does not distinguish between direct and indirect (group) privileges.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by user, or permission by adding the following query string parameters:  * `q=permission>\"read\"` * `sort=user.display_name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.
         * @summary List a repository permissions for a workspace
         * @param {WorkspacesApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspacePermissionsRepositoriesRepoSlugGet(requestParameters: WorkspacesApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositoryPermissions> {
            return localVarFp.workspacesWorkspacePermissionsRepositoriesRepoSlugGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of projects in this workspace.
         * @summary List projects in a workspace
         * @param {WorkspacesApiWorkspacesWorkspaceProjectsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsGet(requestParameters: WorkspacesApiWorkspacesWorkspaceProjectsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProjects> {
            return localVarFp.workspacesWorkspaceProjectsGet(requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the requested project.
         * @summary Get a project for a workspace
         * @param {WorkspacesApiWorkspacesWorkspaceProjectsProjectKeyGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspaceProjectsProjectKeyGet(requestParameters: WorkspacesApiWorkspacesWorkspaceProjectsProjectKeyGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.workspacesWorkspaceProjectsProjectKeyGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all workspace pull requests authored by the specified user.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
         * @summary List workspace pull requests for a user
         * @param {WorkspacesApiWorkspacesWorkspacePullrequestsSelectedUserGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesWorkspacePullrequestsSelectedUserGet(requestParameters: WorkspacesApiWorkspacesWorkspacePullrequestsSelectedUserGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPullrequests> {
            return localVarFp.workspacesWorkspacePullrequestsSelectedUserGet(requestParameters.selectedUser, requestParameters.workspace, requestParameters.state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspacesApi - interface
 */
export interface WorkspacesApiInterface {
    /**
     * Returns an object for each workspace the caller is a member of, and their effective role - the highest level of privilege the caller has. If a user is a member of multiple groups with distinct roles, only the highest level is returned.  Permissions can be:  * `owner` * `collaborator` * `member`  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  **When you move your administration from Bitbucket Cloud to admin.atlassian.com, the following fields on `workspace_membership` will no longer be present: `last_accessed` and `added_on`. See the [deprecation announcement](/cloud/bitbucket/announcement-breaking-change-workspace-membership/).**  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by workspace or permission by adding the following query string parameters:  * `q=workspace.slug=\"bbworkspace1\"` or `q=permission=\"owner\"` * `sort=workspace.slug`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  This endpoint is deprecated and will be replaced with a new endpoint by end of calendar year 2025.
     * @summary List workspaces for the current user
     * @param {WorkspacesApiUserPermissionsWorkspacesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userPermissionsWorkspacesGet(requestParameters?: WorkspacesApiUserPermissionsWorkspacesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWorkspaceMemberships>;

    /**
     * Returns a list of workspaces accessible by the authenticated user.  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by workspace or permission by adding the following query string parameters:  * `q=slug=\"bbworkspace1\"` or `q=is_private=true` * `sort=created_on`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  This endpoint is deprecated and will be replaced with a new endpoint by end of calendar year 2025.
     * @summary List workspaces for user
     * @param {WorkspacesApiWorkspacesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    workspacesGet(requestParameters?: WorkspacesApiWorkspacesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWorkspaces>;

    /**
     * Returns the requested workspace.
     * @summary Get a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceGet(requestParameters: WorkspacesApiWorkspacesWorkspaceGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Workspace>;

    /**
     * Returns a paginated list of webhooks installed on this workspace.
     * @summary List webhooks for a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceHooksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceHooksGet(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWebhookSubscriptions>;

    /**
     * Creates a new webhook on the specified workspace.  Workspace webhooks are fired for events from all repositories contained by that workspace.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/workspaces/my-workspace/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  This call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  The `url` must properly resolve and cannot be an internal, non-routed address.  Only workspace owners can install webhooks on workspaces.
     * @summary Create a webhook for a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceHooksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceHooksPost(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription>;

    /**
     * Deletes the specified webhook subscription from the given workspace.
     * @summary Delete a webhook for a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceHooksUidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceHooksUidDelete(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksUidDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the webhook with the specified id installed on the given workspace.
     * @summary Get a webhook for a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceHooksUidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceHooksUidGet(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksUidGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription>;

    /**
     * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
     * @summary Update a webhook for a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceHooksUidPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceHooksUidPut(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksUidPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscription>;

    /**
     * Returns all members of the requested workspace.  This endpoint additionally supports [filtering](/cloud/bitbucket/rest/intro/#filtering) by email address, if called by a workspace administrator, integration or workspace access token. This is done by adding the following query string parameter:  * `q=user.email IN (\"user1@org.com\",\"user2@org.com\")`  When filtering by email, you can query up to 90 addresses at a time. Note that the query parameter values need to be URL escaped, so the final query string should be:  * `q=user.email%20IN%20(%22user1@org.com%22,%22user2@org.com%22)`  Email addresses that you filter by (and only these email addresses) can be included in the response using the `fields` query parameter:  * `&fields=+values.user.email` - add the `email` field to the default `user` response object * `&fields=values.user.email,values.user.account_id` - only return user email addresses and account IDs  Once again, all query parameter values must be URL escaped.
     * @summary List users in a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceMembersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceMembersGet(requestParameters: WorkspacesApiWorkspacesWorkspaceMembersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWorkspaceMemberships>;

    /**
     * Returns the workspace membership, which includes a `User` object for the member and a `Workspace` object for the requested workspace.
     * @summary Get user membership for a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceMembersMemberGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceMembersMemberGet(requestParameters: WorkspacesApiWorkspacesWorkspaceMembersMemberGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceMembership>;

    /**
     * Returns the list of members in a workspace and their permission levels. Permission can be: * `owner` * `collaborator` * `member`  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  **When you move your administration from Bitbucket Cloud to admin.atlassian.com, the following fields on `workspace_membership` will no longer be present: `last_accessed` and `added_on`. See the [deprecation announcement](/cloud/bitbucket/announcement-breaking-change-workspace-membership/).**  Results may be further [filtered](/cloud/bitbucket/rest/intro/#filtering) by permission by adding the following query string parameters:  * `q=permission=\"owner\"`
     * @summary List user permissions in a workspace
     * @param {WorkspacesApiWorkspacesWorkspacePermissionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspacePermissionsGet(requestParameters: WorkspacesApiWorkspacesWorkspacePermissionsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWorkspaceMemberships>;

    /**
     * Returns an object for each repository permission for all of a workspace\'s repositories.  Permissions returned are effective permissions: the highest level of permission the user has. This does not distinguish between direct and indirect (group) privileges.  Only users with admin permission for the team may access this resource.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by repository, user, or permission by adding the following query string parameters:  * `q=repository.name=\"geordi\"` or `q=permission>\"read\"` * `sort=user.display_name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.
     * @summary List all repository permissions for a workspace
     * @param {WorkspacesApiWorkspacesWorkspacePermissionsRepositoriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspacePermissionsRepositoriesGet(requestParameters: WorkspacesApiWorkspacesWorkspacePermissionsRepositoriesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositoryPermissions>;

    /**
     * Returns an object for the repository permission of each user in the requested repository.  Permissions returned are effective permissions: the highest level of permission the user has. This does not distinguish between direct and indirect (group) privileges.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by user, or permission by adding the following query string parameters:  * `q=permission>\"read\"` * `sort=user.display_name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.
     * @summary List a repository permissions for a workspace
     * @param {WorkspacesApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspacePermissionsRepositoriesRepoSlugGet(requestParameters: WorkspacesApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRepositoryPermissions>;

    /**
     * Returns the list of projects in this workspace.
     * @summary List projects in a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceProjectsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsGet(requestParameters: WorkspacesApiWorkspacesWorkspaceProjectsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProjects>;

    /**
     * Returns the requested project.
     * @summary Get a project for a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceProjectsProjectKeyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspaceProjectsProjectKeyGet(requestParameters: WorkspacesApiWorkspacesWorkspaceProjectsProjectKeyGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Project>;

    /**
     * Returns all workspace pull requests authored by the specified user.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary List workspace pull requests for a user
     * @param {WorkspacesApiWorkspacesWorkspacePullrequestsSelectedUserGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspacesWorkspacePullrequestsSelectedUserGet(requestParameters: WorkspacesApiWorkspacesWorkspacePullrequestsSelectedUserGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPullrequests>;

}

/**
 * Request parameters for userPermissionsWorkspacesGet operation in WorkspacesApi.
 */
export interface WorkspacesApiUserPermissionsWorkspacesGetRequest {
    /**
     *  Query string to narrow down the response. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details.
     */
    readonly q?: string

    /**
     *  Name of a response property to sort results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results) for details. 
     */
    readonly sort?: string
}

/**
 * Request parameters for workspacesGet operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesGetRequest {
    /**
     *              Filters the workspaces based on the authenticated user\&#39;s role on each workspace.              * **member**: returns a list of all the workspaces which the caller is a member of                 at least one workspace group or repository             * **collaborator**: returns a list of workspaces which the caller has write access                 to at least one repository in the workspace             * **owner**: returns a list of workspaces which the caller has administrator access             
     */
    readonly role?: WorkspacesGetRoleEnum

    /**
     *  Query string to narrow down the response. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details.
     */
    readonly q?: string

    /**
     *  Name of a response property to sort results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results) for details. 
     */
    readonly sort?: string
}

/**
 * Request parameters for workspacesWorkspaceGet operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesWorkspaceGetRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceHooksGet operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesWorkspaceHooksGetRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceHooksPost operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesWorkspaceHooksPostRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceHooksUidDelete operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesWorkspaceHooksUidDeleteRequest {
    /**
     * Installed webhook\&#39;s ID
     */
    readonly uid: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceHooksUidGet operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesWorkspaceHooksUidGetRequest {
    /**
     * Installed webhook\&#39;s ID
     */
    readonly uid: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceHooksUidPut operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesWorkspaceHooksUidPutRequest {
    /**
     * Installed webhook\&#39;s ID
     */
    readonly uid: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceMembersGet operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesWorkspaceMembersGetRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceMembersMemberGet operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesWorkspaceMembersMemberGetRequest {
    /**
     * Member\&#39;s UUID or Atlassian ID.
     */
    readonly member: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspacePermissionsGet operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesWorkspacePermissionsGetRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     *  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
     */
    readonly q?: string
}

/**
 * Request parameters for workspacesWorkspacePermissionsRepositoriesGet operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesWorkspacePermissionsRepositoriesGetRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     *  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
     */
    readonly q?: string

    /**
     *  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). 
     */
    readonly sort?: string
}

/**
 * Request parameters for workspacesWorkspacePermissionsRepositoriesRepoSlugGet operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest {
    /**
     * This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    readonly repoSlug: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     *  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
     */
    readonly q?: string

    /**
     *  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). 
     */
    readonly sort?: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsGet operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesWorkspaceProjectsGetRequest {
    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspaceProjectsProjectKeyGet operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesWorkspaceProjectsProjectKeyGetRequest {
    /**
     * The project in question. This is the actual &#x60;key&#x60; assigned to the project. 
     */
    readonly projectKey: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string
}

/**
 * Request parameters for workspacesWorkspacePullrequestsSelectedUserGet operation in WorkspacesApi.
 */
export interface WorkspacesApiWorkspacesWorkspacePullrequestsSelectedUserGetRequest {
    /**
     * This can either be the username of the pull request author, the author\&#39;s UUID surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, or the author\&#39;s Atlassian ID. 
     */
    readonly selectedUser: string

    /**
     * This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;. 
     */
    readonly workspace: string

    /**
     * Only return pull requests that are in this state. This parameter can be repeated.
     */
    readonly state?: WorkspacesWorkspacePullrequestsSelectedUserGetStateEnum
}

/**
 * WorkspacesApi - object-oriented interface
 */
export class WorkspacesApi extends BaseAPI implements WorkspacesApiInterface {
    /**
     * Returns an object for each workspace the caller is a member of, and their effective role - the highest level of privilege the caller has. If a user is a member of multiple groups with distinct roles, only the highest level is returned.  Permissions can be:  * `owner` * `collaborator` * `member`  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  **When you move your administration from Bitbucket Cloud to admin.atlassian.com, the following fields on `workspace_membership` will no longer be present: `last_accessed` and `added_on`. See the [deprecation announcement](/cloud/bitbucket/announcement-breaking-change-workspace-membership/).**  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by workspace or permission by adding the following query string parameters:  * `q=workspace.slug=\"bbworkspace1\"` or `q=permission=\"owner\"` * `sort=workspace.slug`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  This endpoint is deprecated and will be replaced with a new endpoint by end of calendar year 2025.
     * @summary List workspaces for the current user
     * @param {WorkspacesApiUserPermissionsWorkspacesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public userPermissionsWorkspacesGet(requestParameters: WorkspacesApiUserPermissionsWorkspacesGetRequest = {}, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).userPermissionsWorkspacesGet(requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of workspaces accessible by the authenticated user.  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by workspace or permission by adding the following query string parameters:  * `q=slug=\"bbworkspace1\"` or `q=is_private=true` * `sort=created_on`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  This endpoint is deprecated and will be replaced with a new endpoint by end of calendar year 2025.
     * @summary List workspaces for user
     * @param {WorkspacesApiWorkspacesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public workspacesGet(requestParameters: WorkspacesApiWorkspacesGetRequest = {}, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesGet(requestParameters.role, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the requested workspace.
     * @summary Get a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceGet(requestParameters: WorkspacesApiWorkspacesWorkspaceGetRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesWorkspaceGet(requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of webhooks installed on this workspace.
     * @summary List webhooks for a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceHooksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceHooksGet(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksGetRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesWorkspaceHooksGet(requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new webhook on the specified workspace.  Workspace webhooks are fired for events from all repositories contained by that workspace.  Example:  ``` $ curl -X POST -u credentials -H \'Content-Type: application/json\'   https://api.bitbucket.org/2.0/workspaces/my-workspace/hooks   -d \'     {       \"description\": \"Webhook Description\",       \"url\": \"https://example.com/\",       \"active\": true,       \"secret\": \"this is a really bad secret\",       \"events\": [         \"repo:push\",         \"issue:created\",         \"issue:updated\"       ]     }\' ```  When the `secret` is provided it will be used as the key to generate a HMAC digest value sent in the `X-Hub-Signature` header at delivery time. Passing a `null` or empty `secret` or not passing a `secret` will leave the webhook\'s secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook\'s secret is set.  This call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: `webhook`, `repository` and `issue`.  The `url` must properly resolve and cannot be an internal, non-routed address.  Only workspace owners can install webhooks on workspaces.
     * @summary Create a webhook for a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceHooksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceHooksPost(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksPostRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesWorkspaceHooksPost(requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified webhook subscription from the given workspace.
     * @summary Delete a webhook for a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceHooksUidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceHooksUidDelete(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksUidDeleteRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesWorkspaceHooksUidDelete(requestParameters.uid, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the webhook with the specified id installed on the given workspace.
     * @summary Get a webhook for a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceHooksUidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceHooksUidGet(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksUidGetRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesWorkspaceHooksUidGet(requestParameters.uid, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified webhook subscription.  The following properties can be mutated:  * `description` * `url` * `secret` * `active` * `events`  The hook\'s secret is used as a key to generate the HMAC hex digest sent in the `X-Hub-Signature` header at delivery time. This signature is only generated when the hook has a secret.  Set the hook\'s secret by passing the new value in the `secret` field. Passing a `null` value in the `secret` field will remove the secret from the hook. The hook\'s secret can be left unchanged by not passing the `secret` field in the request.
     * @summary Update a webhook for a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceHooksUidPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceHooksUidPut(requestParameters: WorkspacesApiWorkspacesWorkspaceHooksUidPutRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesWorkspaceHooksUidPut(requestParameters.uid, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all members of the requested workspace.  This endpoint additionally supports [filtering](/cloud/bitbucket/rest/intro/#filtering) by email address, if called by a workspace administrator, integration or workspace access token. This is done by adding the following query string parameter:  * `q=user.email IN (\"user1@org.com\",\"user2@org.com\")`  When filtering by email, you can query up to 90 addresses at a time. Note that the query parameter values need to be URL escaped, so the final query string should be:  * `q=user.email%20IN%20(%22user1@org.com%22,%22user2@org.com%22)`  Email addresses that you filter by (and only these email addresses) can be included in the response using the `fields` query parameter:  * `&fields=+values.user.email` - add the `email` field to the default `user` response object * `&fields=values.user.email,values.user.account_id` - only return user email addresses and account IDs  Once again, all query parameter values must be URL escaped.
     * @summary List users in a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceMembersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceMembersGet(requestParameters: WorkspacesApiWorkspacesWorkspaceMembersGetRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesWorkspaceMembersGet(requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the workspace membership, which includes a `User` object for the member and a `Workspace` object for the requested workspace.
     * @summary Get user membership for a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceMembersMemberGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceMembersMemberGet(requestParameters: WorkspacesApiWorkspacesWorkspaceMembersMemberGetRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesWorkspaceMembersMemberGet(requestParameters.member, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of members in a workspace and their permission levels. Permission can be: * `owner` * `collaborator` * `member`  **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information, see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**  **When you move your administration from Bitbucket Cloud to admin.atlassian.com, the following fields on `workspace_membership` will no longer be present: `last_accessed` and `added_on`. See the [deprecation announcement](/cloud/bitbucket/announcement-breaking-change-workspace-membership/).**  Results may be further [filtered](/cloud/bitbucket/rest/intro/#filtering) by permission by adding the following query string parameters:  * `q=permission=\"owner\"`
     * @summary List user permissions in a workspace
     * @param {WorkspacesApiWorkspacesWorkspacePermissionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspacePermissionsGet(requestParameters: WorkspacesApiWorkspacesWorkspacePermissionsGetRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesWorkspacePermissionsGet(requestParameters.workspace, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object for each repository permission for all of a workspace\'s repositories.  Permissions returned are effective permissions: the highest level of permission the user has. This does not distinguish between direct and indirect (group) privileges.  Only users with admin permission for the team may access this resource.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by repository, user, or permission by adding the following query string parameters:  * `q=repository.name=\"geordi\"` or `q=permission>\"read\"` * `sort=user.display_name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.
     * @summary List all repository permissions for a workspace
     * @param {WorkspacesApiWorkspacesWorkspacePermissionsRepositoriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspacePermissionsRepositoriesGet(requestParameters: WorkspacesApiWorkspacesWorkspacePermissionsRepositoriesGetRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesWorkspacePermissionsRepositoriesGet(requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object for the repository permission of each user in the requested repository.  Permissions returned are effective permissions: the highest level of permission the user has. This does not distinguish between direct and indirect (group) privileges.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * `admin` * `write` * `read`  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by user, or permission by adding the following query string parameters:  * `q=permission>\"read\"` * `sort=user.display_name`  Note that the query parameter values need to be URL escaped so that `=` would become `%3D`.
     * @summary List a repository permissions for a workspace
     * @param {WorkspacesApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspacePermissionsRepositoriesRepoSlugGet(requestParameters: WorkspacesApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesWorkspacePermissionsRepositoriesRepoSlugGet(requestParameters.repoSlug, requestParameters.workspace, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of projects in this workspace.
     * @summary List projects in a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceProjectsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsGet(requestParameters: WorkspacesApiWorkspacesWorkspaceProjectsGetRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesWorkspaceProjectsGet(requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the requested project.
     * @summary Get a project for a workspace
     * @param {WorkspacesApiWorkspacesWorkspaceProjectsProjectKeyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspaceProjectsProjectKeyGet(requestParameters: WorkspacesApiWorkspacesWorkspaceProjectsProjectKeyGetRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesWorkspaceProjectsProjectKeyGet(requestParameters.projectKey, requestParameters.workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all workspace pull requests authored by the specified user.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @summary List workspace pull requests for a user
     * @param {WorkspacesApiWorkspacesWorkspacePullrequestsSelectedUserGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public workspacesWorkspacePullrequestsSelectedUserGet(requestParameters: WorkspacesApiWorkspacesWorkspacePullrequestsSelectedUserGetRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesWorkspacePullrequestsSelectedUserGet(requestParameters.selectedUser, requestParameters.workspace, requestParameters.state, options).then((request) => request(this.axios, this.basePath));
    }
}

export const WorkspacesGetRoleEnum = {
    Owner: 'owner',
    Collaborator: 'collaborator',
    Member: 'member'
} as const;
export type WorkspacesGetRoleEnum = typeof WorkspacesGetRoleEnum[keyof typeof WorkspacesGetRoleEnum];


